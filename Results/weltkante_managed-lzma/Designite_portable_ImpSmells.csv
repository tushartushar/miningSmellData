Implementation smell,Namespace,Class,File,Method,Description
Long Method,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToDic,The method has 101 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeToDic,The method has 119 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The method has 287 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The method has 203 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The method has 503 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The method has 103 lines of code.
Long Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The method has 168 lines of code.
Long Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadArchive,The method has 155 lines of code.
Long Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadSectionDetails,The method has 108 lines of code.
Long Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadSection,The method has 120 lines of code.
Long Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The method has 140 lines of code.
Long Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The method has 107 lines of code.
Long Method,ManagedLzma.SevenZip.FileModel,ArchiveFileModelMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveFileModel.cs,ReadMetadata,The method has 100 lines of code.
Long Method,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The method has 122 lines of code.
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_ReadBlock,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc_GetMatchesSpec,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,GetMatchesSpec1,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,SkipMatchesSpec,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CMtSync,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MtSync_Create2,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,BtGetMatches,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToDic,Cyclomatic complexity of the method is 13
Complex Method,ManagedLzma.LZMA.Master,CLzma2EncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncProps_Normalize,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2Enc_EncodeMt1,Cyclomatic complexity of the method is 11
Complex Method,ManagedLzma.LZMA.Master,CMtCallbackImp,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Code,Cyclomatic complexity of the method is 11
Complex Method,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeToDic,Cyclomatic complexity of the method is 17
Complex Method,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,Cyclomatic complexity of the method is 17
Complex Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,Cyclomatic complexity of the method is 69
Complex Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,Cyclomatic complexity of the method is 22
Complex Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,Cyclomatic complexity of the method is 18
Complex Method,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_Init,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.LZMA.Master,CMtThread,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\MtCoder.cs,MtThread_Process,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.LZMA.Master,CMtCoder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\MtCoder.cs,MtCoder_Code,Cyclomatic complexity of the method is 11
Complex Method,ManagedLzma.LZMA2,Decoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma2\Decoder.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,ManagedLzma.LZMA,Decoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\Decoder.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveSectionDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveDecoder.cs,ArchiveSectionDecoder,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadArchive,Cyclomatic complexity of the method is 12
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadSectionHeader,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadSectionDetails,Cyclomatic complexity of the method is 20
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadSection,Cyclomatic complexity of the method is 24
Complex Method,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadDecoder,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.SevenZip.Reader,DecodedStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveReader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,DecodeInto,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,GlueFreeBlocks,Cyclomatic complexity of the method is 10
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,Cyclomatic complexity of the method is 17
Complex Method,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.FileModel,ArchiveFileModelMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveFileModel.cs,ReadMetadata,Cyclomatic complexity of the method is 18
Complex Method,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,Cyclomatic complexity of the method is 17
Complex Method,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteDecoderSection,Cyclomatic complexity of the method is 19
Complex Method,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,TransferSectionAsync,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,CheckName,Cyclomatic complexity of the method is 8
Complex Method,ManagedLzma.SevenZip.Writer,EncoderDefinition,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Definition.cs,Complete,Cyclomatic complexity of the method is 9
Complex Method,ManagedLzma.SevenZip.Writer,EncoderDefinition,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Definition.cs,CreateEncoderSession,Cyclomatic complexity of the method is 16
Complex Method,ManagedLzma.SevenZip.Writer,EncoderSession,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,Complete,Cyclomatic complexity of the method is 8
Long Parameter List,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,LzmaEncode,The method has 11 parameters. Parameters: dest' destLen' src' srcLen' props' propsEncoded' propsSize' writeEndMark' progress' alloc' allocBig
Long Parameter List,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,LzmaCompress,The method has 13 parameters. Parameters: dest' destLen' src' srcLen' outProps' outPropsSize' level' dictSize' lc' lp' pb' fb' numThreads
Long Parameter List,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,LzmaUncompress,The method has 6 parameters. Parameters: dest' destLen' src' srcLen' props' propsSize
Long Parameter List,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The method has 5 parameters. Parameters: historySize' keepAddBufferBefore' matchMaxLen' keepAddBufferAfter' alloc
Long Parameter List,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc_GetMatchesSpec,The method has 10 parameters. Parameters: lenLimit' curMatch' pos' cur' son' _cyclicBufferPos' _cyclicBufferSize' cutValue' distances' maxLen
Long Parameter List,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,GetMatchesSpec1,The method has 10 parameters. Parameters: lenLimit' curMatch' pos' cur' son' _cyclicBufferPos' _cyclicBufferSize' cutValue' distances' maxLen
Long Parameter List,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,SkipMatchesSpec,The method has 8 parameters. Parameters: lenLimit' curMatch' pos' cur' son' _cyclicBufferPos' _cyclicBufferSize' cutValue
Long Parameter List,ManagedLzma.LZMA.Master,IMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_Create,The method has 5 parameters. Parameters: historySize' keepAddBufferBefore' matchMaxLen' keepAddBufferAfter' alloc
Long Parameter List,ManagedLzma.LZMA.Master,MatchFinderMtBase,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,MatchFinderMt2,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,MatchFinderMt3,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,MatchFinderMt4a,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,MatchFinderMt4b,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The method has 6 parameters. Parameters: buffer' pos' hash' hashMask' heads' numHeads
Long Parameter List,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToDic,The method has 5 parameters. Parameters: dicLimit' src' srcLen' finishMode' status
Long Parameter List,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToBuf,The method has 6 parameters. Parameters: dest' destLen' src' srcLen' finishMode' status
Long Parameter List,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Decode,The method has 8 parameters. Parameters: dest' destLen' src' srcLen' prop' finishMode' status' alloc
Long Parameter List,ManagedLzma.LZMA.Master,CMtCallbackImp,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Code,The method has 6 parameters. Parameters: index' dest' destSize' src' srcSize' finished
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeToDic,The method has 5 parameters. Parameters: dicLimit' src' srcLen' finishMode' status
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeToBuf,The method has 6 parameters. Parameters: dest' destLen' src' srcLen' finishMode' status
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDecode,The method has 9 parameters. Parameters: dest' destLen' src' srcLen' propData' propSize' finishMode' status' alloc
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_IF_BIT_0,The method has 6 parameters. Parameters: p' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_UPDATE_1,The method has 5 parameters. Parameters: p' ttt' bound' range' code
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_GET_BIT2,The method has 7 parameters. Parameters: p' i' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_GET_BIT,The method has 7 parameters. Parameters: p' i' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_TREE_GET_BIT,The method has 7 parameters. Parameters: probs' i' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_TREE_DECODE,The method has 8 parameters. Parameters: probs' limit' i' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_TREE_6_DECODE,The method has 7 parameters. Parameters: probs' i' ttt' bound' range' code' buf
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_IF_BIT_0_CHECK,The method has 8 parameters. Parameters: result' p' ttt' bound' range' code' buf' bufLimit
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_GET_BIT2_CHECK,The method has 10 parameters. Parameters: p' i' A0' A1' ttt' bound' range' code' buf' bufLimit
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_GET_BIT_CHECK,The method has 8 parameters. Parameters: p' i' ttt' bound' range' code' buf' bufLimit
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_TREE_DECODE_CHECK,The method has 9 parameters. Parameters: probs' limit' i' ttt' bound' range' code' buf' bufLimit
Long Parameter List,ManagedLzma.LZMA.Master,CLenPriceEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_Encode2,The method has 5 parameters. Parameters: rc' symbol' posState' updatePrice' probPrices
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_Encode,The method has 5 parameters. Parameters: outStream' inStream' progress' alloc' allocBig
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_MemEncode,The method has 8 parameters. Parameters: dest' destLen' src' srcLen' writeEndMark' progress' alloc' allocBig
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_MemPrepare,The method has 5 parameters. Parameters: src' srcLen' keepWindowSize' alloc' allocBig
Long Parameter List,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneMemBlock,The method has 5 parameters. Parameters: reInit' dest' destLen' desiredPackSize' unpackSize
Long Parameter List,ManagedLzma.LZMA2,Decoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma2\Decoder.cs,Decode,The method has 5 parameters. Parameters: buffer' offset' length' limit' eof
Long Parameter List,ManagedLzma.LZMA,Decoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\Decoder.cs,Decode,The method has 5 parameters. Parameters: buffer' offset' length' limit' eof
Long Parameter List,ManagedLzma.SevenZip.Reader,ArchiveSectionDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveDecoder.cs,SelectStream,The method has 7 parameters. Parameters: archiveMetadata' sectionMetadata' selector' streams' decoders' result' length
Long Parameter List,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The method has 7 parameters. Parameters: stream' mStreamLength' mMajorVersion' mMinorVersion' mMetadataOffset' mMetadataLength' mMetadataChecksum
Long Parameter List,ManagedLzma.SevenZip.FileModel,ArchivedFile,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveFileModel.cs,ArchivedFile,The method has 10 parameters. Parameters: FullName' Name' Stream' Offset' Length' Checksum' Attributes' Creation' LastWrite' LastAccess
Long Parameter List,ManagedLzma.SevenZip.Metadata,ArchiveDecoderSection,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadata.cs,ArchiveDecoderSection,The method has 5 parameters. Parameters: decoders' decodedStream' length' checksum' sections
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteAlignedHeaderWithBitVector,The method has 5 parameters. Parameters: bits' vectorCount' itemCount' token' itemSize
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,TranscodeSectionAsync,The method has 5 parameters. Parameters: stream' metadata' section' selector' definition
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendFile,The method has 7 parameters. Parameters: name' length' checksum' attributes' creationDate' lastWriteDate' lastAccessDate
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendFile,The method has 7 parameters. Parameters: name' length' checksum' attributes' creationDate' lastWriteDate' lastAccessDate
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendDirectory,The method has 5 parameters. Parameters: name' attributes' creationDate' lastWriteDate' lastAccessDate
Long Parameter List,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendDirectory,The method has 5 parameters. Parameters: name' attributes' creationDate' lastWriteDate' lastAccessDate
Long Parameter List,ManagedLzma.SevenZip.Writer,EncoderSession,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,EncoderSession,The method has 7 parameters. Parameters: writer' section' definition' input' storage' connections' encoders
Long Identifier,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,,The length of the parameter LZMA2_CHUNK_SIZE_COMPRESSED_MAX is 31.
Long Identifier,ManagedLzma.SevenZip.Reader,MetadataAttributeReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataDataReader.cs,MetadataAttributeReader,The length of the parameter enablePosixFileAttributeExtension is 33.
Long Identifier,ManagedLzma.SevenZip.Reader,MetadataAttributeReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataDataReader.cs,,The length of the parameter mEnablePosixFileAttributeExtension is 34.
Long Identifier,ManagedLzma.SevenZip.Writer,EncoderConnection,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,,The length of the parameter mEncoderOutputToConnectionInput is 31.
Long Identifier,ManagedLzma.SevenZip.Writer,EncoderConnection,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,,The length of the parameter mConnectionOutputToEncoderInput is 31.
Long Statement,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,LzmaCompress,The length of the statement  "            return LzmaEncode(dest' ref destLen' src' srcLen' props' outProps' ref outPropsSize' false' null' ISzAlloc.SmallAlloc' ISzAlloc.BigAlloc); " is 138.
Long Statement,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,LzmaUncompress,The length of the statement  "            return CLzmaDec.LzmaDecode(dest' ref destLen' src' ref srcLen' props' (uint)propsSize' ELzmaFinishMode.LZMA_FINISH_ANY' out status' ISzAlloc.SmallAlloc); " is 153.
Long Statement,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt2_MatchFinder_GetMatches,The length of the statement  "                offset = (uint)(GetMatchesSpec1(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue' distances + offset' 1) - distances); " is 157.
Long Statement,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The length of the statement  "                offset = (uint)(GetMatchesSpec1(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue' distances + offset' maxLen) - distances); " is 162.
Long Statement,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The length of the statement  "                offset = (uint)(GetMatchesSpec1(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue' distances + offset' maxLen) - distances); " is 162.
Long Statement,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The length of the statement  "                offset = (uint)(Hc_GetMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue' distances + offset' maxLen) - distances); " is 164.
Long Statement,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,The length of the statement  "                            mInterface.GetHeadsFunc(base.mBuffer' base.mPos' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask' heads + 2' num); " is 122.
Long Statement,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The length of the statement  "                SRes res = mEnc.LzmaEnc_CodeOneMemBlock(mNeedInitState' outBuf + lzHeaderSize' ref packSize' LZMA2_PACK_SIZE_MAX' ref unpackSize); " is 130.
Long Statement,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2Enc_EncodeMt1,The length of the statement  "                if ((res = mEnc.LzmaEnc_PrepareForLzma2(inStream' LZMA2_KEEP_WINDOW_SIZE' mainEncoder.mAlloc' mainEncoder.mAllocBig)) != SZ_OK) " is 127.
Long Statement,ManagedLzma.LZMA.Master,CMtCallbackImp,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Code,The length of the statement  "                    if ((res = p.mEnc.LzmaEnc_MemPrepare(src' srcSize' CLzma2EncInternal.LZMA2_KEEP_WINDOW_SIZE' mLzma2Enc.mAlloc' mLzma2Enc.mAllocBig)) != SZ_OK) " is 142.
Long Statement,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The length of the statement  "                                if (!_GET_BIT2_CHECK(probLit' ref symbol' delegate { offs &= ~bit; }' delegate { offs &= bit; }' out ttt' ref bound' ref range' ref code' ref buf' bufLimit)) " is 157.
Long Statement,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The length of the statement  "                            if (!_TREE_DECODE_CHECK(prob' 1 << kNumPosSlotBits' out posSlot' out ttt' ref bound' ref range' ref code' ref buf' bufLimit)) " is 125.
Long Statement,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_GET_BIT_CHECK,The length of the statement  "                return _GET_BIT2_CHECK(p' ref i' delegate { }' delegate { }' out ttt' ref bound' ref range' ref code' ref buf' bufLimit); " is 121.
Long Statement,ManagedLzma.LZMA.Master,CLenEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_Encode,The length of the statement  "                        CLzmaEnc.RcTree_Encode(rc' P.From(mMid' posState << CLzmaEnc.kLenNumMidBits)' CLzmaEnc.kLenNumMidBits' symbol - CLzmaEnc.kLenNumLowSymbols); " is 140.
Long Statement,ManagedLzma.LZMA.Master,CLenEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_Encode,The length of the statement  "                        CLzmaEnc.RcTree_Encode(rc' mHigh' CLzmaEnc.kLenNumHighBits' symbol - CLzmaEnc.kLenNumLowSymbols - CLzmaEnc.kLenNumMidSymbols); " is 126.
Long Statement,ManagedLzma.LZMA.Master,CLenEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_SetPrices,The length of the statement  "                    prices[i] = a0 + CLzmaEnc.RcTree_GetPrice(P.From(mLow' posState << CLzmaEnc.kLenNumLowBits)' CLzmaEnc.kLenNumLowBits' i' probPrices); " is 133.
Long Statement,ManagedLzma.LZMA.Master,CLenEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_SetPrices,The length of the statement  "                    prices[i] = b0 + CLzmaEnc.RcTree_GetPrice(P.From(mMid' posState << CLzmaEnc.kLenNumMidBits)' CLzmaEnc.kLenNumMidBits' i - CLzmaEnc.kLenNumLowSymbols' probPrices); " is 162.
Long Statement,ManagedLzma.LZMA.Master,CLenEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LenEnc_SetPrices,The length of the statement  "                    prices[i] = b1 + CLzmaEnc.RcTree_GetPrice(mHigh' CLzmaEnc.kLenNumHighBits' i - (CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols)' probPrices); " is 150.
Long Statement,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,FillDistancesPrices,The length of the statement  "                    tempPrices[i] = RcTree_ReverseGetPrice(P.From(mPosEncoders' @base - posSlot - 1)' (int)footerBits' i - @base' mProbPrices); " is 123.
Long Statement,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_Alloc,The length of the statement  "                    if ((res = mMatchFinderMt.MatchFinderMt_Create(mDictSize' beforeSize' mNumFastBytes' LZMA_MATCH_LEN_MAX' allocBig)) != SZ_OK) " is 125.
Long Statement,ManagedLzma.LZMA2,Decoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma2\Decoder.cs,ReadOutputData,The length of the statement  "            Buffer.BlockCopy(mDecoder.mDecoder.mDic.mBuffer' mDecoder.mDecoder.mDic.mOffset + mDecoderPosition' buffer' offset' length); " is 124.
Long Statement,ManagedLzma.LZMA,AsyncEncoder,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\Encoder.cs,EncodeAsync,The length of the statement  "                var res = mEncoder.LzmaEnc_Encode(new AsyncOutputProvider(output)' new AsyncInputProvider(input)' null' Master.LZMA.ISzAlloc.SmallAlloc' Master.LZMA.ISzAlloc.BigAlloc); " is 168.
Long Statement,ManagedLzma.SevenZip,ArchivedAttributesExtensions,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchivedAttributes.cs,CheckArchivedAttributesConsistency,The length of the statement  "            System.Diagnostics.Debug.Assert(InvalidAttributes == ~(VisibleAttributes | DirectoryAttribute | ToleratedAttributes | StrippedAttributes | ForbiddenAttributes)); " is 161.
Long Statement,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,CheckFileHeader,The length of the statement  "            return ReadFileHeader(stream' stream.CanSeek ? stream.Length : Int64.MaxValue' out major' out minor' out offset' out length' out checksum) == null; " is 147.
Long Statement,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadMetadataCore,The length of the statement  "                var exception = ReadFileHeader(mStream' mStreamLength' out mMajorVersion' out mMinorVersion' out mMetadataOffset' out mMetadataLength' out mMetadataChecksum); " is 158.
Long Statement,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadMetadataCore,The length of the statement  "                using (var metadataStream = new ConstrainedReadStream(mStream' ArchiveMetadataFormat.kHeaderLength + mMetadataOffset' mMetadataLength)) " is 135.
Long Statement,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadRequiredBitVector,The length of the statement  "            // TODO: this calculation could overflow for malformed data' should throw an InvalidDataException instead of ArgumentOutOfRangeException " is 136.
Long Statement,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Initialize,The length of the statement  "            // The 7z AES encoder/decoder classes do not perform padding' instead they require the input stream to provide a multiple of 16 bytes. " is 134.
Long Statement,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Initialize,The length of the statement  "            // If the exception below is thrown this means the 7z file is either corrupt or a newer 7z version has been published and we haven't updated yet. " is 145.
Long Statement,ManagedLzma.SevenZip.Reader,Lzma2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Lzma2Decoder.cs,EnsureOutputData,The length of the statement  "                var written = mDecoder.Decode(mBuffer' mOffset' mEnding - mOffset' (int)Math.Min(Int32.MaxValue' mLength - mPosition)' false); " is 126.
Long Statement,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The length of the statement  "                    c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u))); " is 134.
Long Statement,ManagedLzma.SevenZip.FileModel,ArchiveFileModelMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveFileModel.cs,ReadMetadata,The length of the statement  "                return new ArchiveFileModel(metadata' BuildFolder(mRootFolder)' mSectionMap.MoveToImmutable()' finalStreamMap.ToImmutable()); " is 125.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The length of the statement  "            // TODO: we'll probably also want to have a scratch buffer to assembly vectors with no allocation overhead and in a single iteration " is 132.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The length of the statement  "            //       (a scratch buffer allows to record the vector in a single iteration and if it was unnecessary it doesn't need to be forwarded to the actual stream) " is 156.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The length of the statement  "                WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime); " is 121.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The length of the statement  "                WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime); " is 123.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The length of the statement  "                WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime); " is 122.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,CheckName,The length of the statement  "            Utilities.NeedsReview(); // TODO: we need to hardcode this so you can't write invalid filenames on non-windows platforms " is 120.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,CheckDate,The length of the statement  "                        throw new InvalidOperationException("You did not specify how to treat DateTime values which do not provide their own DateTimeKind."); " is 133.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendFile,The length of the statement  "            // TODO: replicate the checks when the metadata is queried from the provider (in particular don't forget to check that timestamps are UTC) " is 138.
Long Statement,ManagedLzma.SevenZip.Writer,ArchiveMetadataRecorder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,AppendDirectory,The length of the statement  "            // TODO: check attributes and reject invalid ones (replicate the check when writing the attributes so other metadata providers get the check too) " is 145.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderDefinition,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Definition.cs,CreateEncoderSession,The length of the statement  "                throw new ArgumentException("Number of provided storage streams does not match number of declared storage streams."' nameof(storage)); " is 134.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderDefinition,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Definition.cs,CreateEncoderSession,The length of the statement  "            var contentStream = new EncoderInput(true); // TODO: make checksum calculation configurable? I think normal 7z archives skip this one' at least with copy-aes encoder graphs? " is 173.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderConnection,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,TransferLoop,The length of the statement  "                    var fetched = await mEncoderOutputToConnectionInput.ReadAsync(buffer' ending' buffer.Length - ending' StreamMode.Partial).ConfigureAwait(false); " is 144.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderConnection,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,TransferLoop,The length of the statement  "                    var written = await mConnectionOutputToEncoderInput.WriteAsync(buffer' offset' ending - offset' StreamMode.Partial).ConfigureAwait(false); " is 138.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderSession,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,ReadInternalAsync,The length of the statement  "                mResultLength += fetched; // could be interlocked but doesn't need to be since we are currently 'owning' the stream (and also consider ourselves 'owning' this counter) " is 167.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderSession,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,Complete,The length of the statement  "                decoders.Add(new DecoderMetadata(decoderType' settings.SerializeSettings()' decoderInputs.MoveToImmutable()' decoderOutputs.MoveToImmutable())); " is 144.
Long Statement,ManagedLzma.SevenZip.Writer,EncoderSession,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,AppendStream,The length of the statement  "            // TODO: validate relative filename (in particular the directory separator and checking for invalid components like drives' '..' and '.') " is 137.
Long Statement,ManagedLzma,PasswordStorage,C:\repos\weltkante_managed-lzma\shared\Utilities\Password.cs,GetPassword,The length of the statement  "                    // Must do a second check because if a dispose happened while the array was cloned it may have been partially zeroed out. " is 121.
Long Statement,ManagedLzma,PasswordStorage,C:\repos\weltkante_managed-lzma\shared\Utilities\Password.cs,GetPassword,The length of the statement  "                // If an exception happens before we can return the accessor to the caller we need to clear potential copies of the password. " is 125.
Long Statement,ManagedLzma,AsyncTaskCompletionSource,C:\repos\weltkante_managed-lzma\shared\Utilities\Utilities.cs,Create,The length of the statement  "            return new AsyncTaskCompletionSource<T>(new TaskCompletionSource<T>(TaskCreationOptions.RunContinuationsAsynchronously)); " is 121.
Complex Conditional,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToDic,The conditional expression  "(!initDic && mNeedInitDic) || (!initState && mNeedInitState)"  is complex.
Complex Conditional,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The conditional expression  "props.mLC > LZMA_LC_MAX                      || props.mLP > LZMA_LP_MAX                      || props.mPB > LZMA_PB_MAX                      || props.mDictSize > (1u << kDicLogSizeMaxCompress)                      || props.mDictSize > (1u << 30)"  is complex.
Complex Conditional,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The conditional expression  "repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15)))"  is complex.
Complex Conditional,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The conditional expression  "(mLongestMatchLength >= mainLen && newDistance < mainDist) ||                          (mLongestMatchLength == mainLen + 1 && !ChangePair(mainDist' newDistance)) ||                          (mLongestMatchLength > mainLen + 1) ||                          (mLongestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance' mainDist))"  is complex.
Virtual Method Call from Constructor,ManagedLzma.SevenZip.Reader,ArchiveSectionDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveDecoder.cs,ArchiveSectionDecoder,The constructor "ArchiveSectionDecoder" calls a virtual method "SetInputStream".
Empty Catch Block,ManagedLzma.SevenZip.Writer,Lzma2EncoderNode,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Lzma2Encoder.cs,Dispose,The method has an empty catch block.
Empty Catch Block,ManagedLzma.SevenZip.Writer,LzmaEncoderNode,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\LzmaEncoder.cs,Dispose,The method has an empty catch block.
Magic Number,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,MatchFinder_CreateVTable,The following statement contains a magic number: if (!p.mBtMode)                  vTable = new MatchFinderHc4();              else if (p.mNumHashBytes == 2)                  vTable = new MatchFinderBt2();              else if (p.mNumHashBytes == 3)                  vTable = new MatchFinderBt3();              else                  vTable = new MatchFinderBt4();
Magic Number,ManagedLzma.LZMA.Master,LZMA,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Core.cs,MatchFinder_CreateVTable,The following statement contains a magic number: if (!p.mBtMode)                  vTable = new MatchFinderHc4();              else if (p.mNumHashBytes == 2)                  vTable = new MatchFinderBt2();              else if (p.mNumHashBytes == 3)                  vTable = new MatchFinderBt3();              else                  vTable = new MatchFinderBt4();
Magic Number,ManagedLzma.LZMA.Master,CRCUtils,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\CRC.cs,CRCUtils,The following statement contains a magic number: mTable = new uint[256];
Magic Number,ManagedLzma.LZMA.Master,CRCUtils,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\CRC.cs,CRCUtils,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));                    mTable[i] = r;              }
Magic Number,ManagedLzma.LZMA.Master,CRCUtils,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\CRC.cs,CRCUtils,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));                    mTable[i] = r;              }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,CMatchFinder,The following statement contains a magic number: mCutValue = 32;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,CMatchFinder,The following statement contains a magic number: mNumHashBytes = 4;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (historySize > ((uint)2 << 30))                      sizeReserv = historySize >> 2;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (historySize > ((uint)2 << 30))                      sizeReserv = historySize >> 2;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (historySize > ((uint)2 << 30))                      sizeReserv = historySize >> 2;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,MatchFinder_Create,The following statement contains a magic number: if (LzInWindow_Create(sizeReserv' alloc))                  {                      uint newCyclicBufferSize = historySize + 1;                      uint hs;                        mMatchMaxLen = matchMaxLen;                        {                          mFixedHashSize = 0;                            if (mNumHashBytes == 2)                          {                              hs = (1 << 16) - 1;                          }                          else                          {                              hs = historySize - 1;                              hs |= (hs >> 1);                              hs |= (hs >> 2);                              hs |= (hs >> 4);                              hs |= (hs >> 8);                              hs >>= 1;                              hs |= 0xFFFF; // don't change it! It's required for Deflate                              if (hs > (1 << 24))                              {                                  if (mNumHashBytes == 3)                                      hs = (1 << 24) - 1;                                  else                                      hs >>= 1;                              }                          }                            mHashMask = hs;                          hs++;                            if (mNumHashBytes > 2)                              mFixedHashSize += kHash2Size;                          if (mNumHashBytes > 3)                              mFixedHashSize += kHash3Size;                          if (mNumHashBytes > 4)                              mFixedHashSize += kHash4Size;                            hs += mFixedHashSize;                      }                        {                          uint prevSize = mHashSizeSum + mNumSons;                            mHistorySize = historySize;                          mHashSizeSum = hs;                          mCyclicBufferSize = newCyclicBufferSize;                          mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);                            uint newSize = mHashSizeSum + mNumSons;                          if (mHash != null && prevSize == newSize)                              return true;                            MatchFinder_FreeThisClassMemory(alloc);                            mHash = AllocRefs(newSize' alloc);                          if (mHash != null)                          {                              mSon = P.From(mHash' mHashSizeSum);                              return true;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt2_MatchFinder_GetMatches,The following statement contains a magic number: if (lenLimit < 2)                  {                      MatchFinder_MovePos();                      return 0;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt2_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = cur[0] | ((uint)cur[1] << 8);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The following statement contains a magic number: if (lenLimit < 3)                  {                      MatchFinder_MovePos();                      return 0;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The following statement contains a magic number: uint maxLen = 2;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])                  {                      while (maxLen != lenLimit)                      {                          if (cur[maxLen - delta2] != cur[maxLen])                              break;                            maxLen++;                      }                        distances[0] = maxLen;                      distances[1] = delta2 - 1;                      offset = 2;                        if (maxLen == lenLimit)                      {                          SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                            mCyclicBufferPos++;                          mBuffer++;                            if (++mPos == mPosLimit)                              MatchFinder_CheckLimits();                            return offset;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (lenLimit < 4)                  {                      MatchFinder_MovePos();                      return 0;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])                  {                      distances[0] = maxLen = 2;                      distances[1] = delta2 - 1;                      offset = 2;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])                  {                      distances[0] = maxLen = 2;                      distances[1] = delta2 - 1;                      offset = 2;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])                  {                      maxLen = 3;                      distances[offset + 1] = delta3 - 1;                      offset += 2;                      delta2 = delta3;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])                  {                      maxLen = 3;                      distances[offset + 1] = delta3 - 1;                      offset += 2;                      delta2 = delta3;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (offset != 0)                  {                      while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])                          maxLen++;                        distances[offset - 2] = maxLen;                        if (maxLen == lenLimit)                      {                          SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                          mCyclicBufferPos++;                          mBuffer++;                            if (++mPos == mPosLimit)                              MatchFinder_CheckLimits();                            return offset;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (maxLen < 3)                      maxLen = 3;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_GetMatches,The following statement contains a magic number: if (maxLen < 3)                      maxLen = 3;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (lenLimit < 4)                  {                      MatchFinder_MovePos();                      return 0;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])                  {                      TR("Hc4_MatchFinder_GetMatches:a1"' maxLen);                      TR("Hc4_MatchFinder_GetMatches:a2"' delta2);                      distances[0] = maxLen = 2;                      distances[1] = delta2 - 1;                      offset = 2;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])                  {                      TR("Hc4_MatchFinder_GetMatches:a1"' maxLen);                      TR("Hc4_MatchFinder_GetMatches:a2"' delta2);                      distances[0] = maxLen = 2;                      distances[1] = delta2 - 1;                      offset = 2;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])                  {                      TR("Hc4_MatchFinder_GetMatches:b1"' offset);                      TR("Hc4_MatchFinder_GetMatches:b2"' delta3);                      maxLen = 3;                      distances[offset + 1] = delta3 - 1;                      offset += 2;                      delta2 = delta3;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])                  {                      TR("Hc4_MatchFinder_GetMatches:b1"' offset);                      TR("Hc4_MatchFinder_GetMatches:b2"' delta3);                      maxLen = 3;                      distances[offset + 1] = delta3 - 1;                      offset += 2;                      delta2 = delta3;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (offset != 0)                  {                      while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])                          maxLen++;                        TR("Hc4_MatchFinder_GetMatches:c1"' offset);                      TR("Hc4_MatchFinder_GetMatches:c2"' maxLen);                        distances[offset - 2] = maxLen;                        if (maxLen == lenLimit)                      {                          TR("Hc4_MatchFinder_GetMatches:d"' curMatch);                          mSon[mCyclicBufferPos] = curMatch;                          mCyclicBufferPos++;                          mBuffer++;                          mPos++;                          if (mPos == mPosLimit)                              MatchFinder_CheckLimits();                          return offset;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (maxLen < 3)                      maxLen = 3;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_GetMatches,The following statement contains a magic number: if (maxLen < 3)                      maxLen = 3;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt2_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 2)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint hashValue = cur[0] | ((uint)cur[1] << 8);                        uint curMatch = mHash[hashValue];                        mHash[hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt2_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 2)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint hashValue = cur[0] | ((uint)cur[1] << 8);                        uint curMatch = mHash[hashValue];                        mHash[hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 3)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;                        uint curMatch = mHash[kFix3HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 3)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;                        uint curMatch = mHash[kFix3HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt3_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 3)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;                        uint curMatch = mHash[kFix3HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Bt4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        SkipMatchesSpec(lenLimit' curMatch' mPos' mBuffer' mSon' mCyclicBufferPos' mCyclicBufferSize' mCutValue);                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinder,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFind.cs,Hc4_MatchFinder_Skip,The following statement contains a magic number: do                  {                      uint lenLimit = mLenLimit;                      if (lenLimit < 4)                      {                          MatchFinder_MovePos();                          continue;                      }                        P<byte> cur = mBuffer;                      uint temp = cur[0].CRC() ^ cur[1];                      uint hash2Value = temp & (kHash2Size - 1);                      uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                      uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;                        uint curMatch = mHash[kFix4HashSize + hashValue];                        mHash[hash2Value] = mPos;                      mHash[kFix3HashSize + hash3Value] = mPos;                      mHash[kFix4HashSize + hashValue] = mPos;                        mSon[mCyclicBufferPos] = curMatch;                        mCyclicBufferPos++;                      mBuffer++;                        if (++mPos == mPosLimit)                          MatchFinder_CheckLimits();                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,The following statement contains a magic number: for (;;)                  {                      uint numProcessedBlocks = 0;                      Event_Wait(p.mCanStart);                      Event_Set(p.mWasStarted);                      for (;;)                      {                          if (p.mExit)                              return;                            Trace.MatchObjectWait(p' "HashThreadFunc:stop");                          if (p.mStopWriting)                          {                              Trace.MatchObjectWait(p' "HashThreadFunc:stop");                              p.mNumProcessedBlocks = numProcessedBlocks;                              Event_Set(p.mWasStopped);                              break;                          }                          Trace.MatchObjectWait(p' "HashThreadFunc:stop");                            if (base.MatchFinder_NeedMove())                          {                              CriticalSection_Enter(mBtSync.mCS);                              CriticalSection_Enter(mHashSync.mCS);                              {                                  P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();                                  base.MatchFinder_MoveBlock();                                  P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();                                  mPointerToCurPos -= beforePtr - afterPtr;                                  mLocalBuffer -= beforePtr - afterPtr;                              }                              CriticalSection_Leave(mBtSync.mCS);                              CriticalSection_Leave(mHashSync.mCS);                              continue;                          }                            Semaphore_Wait(p.mFreeSemaphore);                            base.MatchFinder_ReadIfRequired();                          if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))                          {                              uint subValue = (base.mPos - base.mHistorySize - 1);                              base.MatchFinder_ReduceOffsets(subValue);                              CMatchFinder.MatchFinder_Normalize3(subValue' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask + 1);                          }                            P<uint> heads = P.From(mHashBuf' ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);                          uint num = base.mStreamPos - base.mPos;                          heads[0] = 2;                          heads[1] = num;                          if (num >= base.mNumHashBytes)                          {                              num = num - base.mNumHashBytes + 1;                              if (num > kMtHashBlockSize - 2)                                  num = kMtHashBlockSize - 2;                              mInterface.GetHeadsFunc(base.mBuffer' base.mPos' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask' heads + 2' num);                              heads[0] += num;                          }                          base.mPos += num;                          base.mBuffer += num;                            Semaphore_Release1(p.mFilledSemaphore);                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,The following statement contains a magic number: for (;;)                  {                      uint numProcessedBlocks = 0;                      Event_Wait(p.mCanStart);                      Event_Set(p.mWasStarted);                      for (;;)                      {                          if (p.mExit)                              return;                            Trace.MatchObjectWait(p' "HashThreadFunc:stop");                          if (p.mStopWriting)                          {                              Trace.MatchObjectWait(p' "HashThreadFunc:stop");                              p.mNumProcessedBlocks = numProcessedBlocks;                              Event_Set(p.mWasStopped);                              break;                          }                          Trace.MatchObjectWait(p' "HashThreadFunc:stop");                            if (base.MatchFinder_NeedMove())                          {                              CriticalSection_Enter(mBtSync.mCS);                              CriticalSection_Enter(mHashSync.mCS);                              {                                  P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();                                  base.MatchFinder_MoveBlock();                                  P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();                                  mPointerToCurPos -= beforePtr - afterPtr;                                  mLocalBuffer -= beforePtr - afterPtr;                              }                              CriticalSection_Leave(mBtSync.mCS);                              CriticalSection_Leave(mHashSync.mCS);                              continue;                          }                            Semaphore_Wait(p.mFreeSemaphore);                            base.MatchFinder_ReadIfRequired();                          if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))                          {                              uint subValue = (base.mPos - base.mHistorySize - 1);                              base.MatchFinder_ReduceOffsets(subValue);                              CMatchFinder.MatchFinder_Normalize3(subValue' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask + 1);                          }                            P<uint> heads = P.From(mHashBuf' ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);                          uint num = base.mStreamPos - base.mPos;                          heads[0] = 2;                          heads[1] = num;                          if (num >= base.mNumHashBytes)                          {                              num = num - base.mNumHashBytes + 1;                              if (num > kMtHashBlockSize - 2)                                  num = kMtHashBlockSize - 2;                              mInterface.GetHeadsFunc(base.mBuffer' base.mPos' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask' heads + 2' num);                              heads[0] += num;                          }                          base.mPos += num;                          base.mBuffer += num;                            Semaphore_Release1(p.mFilledSemaphore);                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,The following statement contains a magic number: for (;;)                  {                      uint numProcessedBlocks = 0;                      Event_Wait(p.mCanStart);                      Event_Set(p.mWasStarted);                      for (;;)                      {                          if (p.mExit)                              return;                            Trace.MatchObjectWait(p' "HashThreadFunc:stop");                          if (p.mStopWriting)                          {                              Trace.MatchObjectWait(p' "HashThreadFunc:stop");                              p.mNumProcessedBlocks = numProcessedBlocks;                              Event_Set(p.mWasStopped);                              break;                          }                          Trace.MatchObjectWait(p' "HashThreadFunc:stop");                            if (base.MatchFinder_NeedMove())                          {                              CriticalSection_Enter(mBtSync.mCS);                              CriticalSection_Enter(mHashSync.mCS);                              {                                  P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();                                  base.MatchFinder_MoveBlock();                                  P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();                                  mPointerToCurPos -= beforePtr - afterPtr;                                  mLocalBuffer -= beforePtr - afterPtr;                              }                              CriticalSection_Leave(mBtSync.mCS);                              CriticalSection_Leave(mHashSync.mCS);                              continue;                          }                            Semaphore_Wait(p.mFreeSemaphore);                            base.MatchFinder_ReadIfRequired();                          if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))                          {                              uint subValue = (base.mPos - base.mHistorySize - 1);                              base.MatchFinder_ReduceOffsets(subValue);                              CMatchFinder.MatchFinder_Normalize3(subValue' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask + 1);                          }                            P<uint> heads = P.From(mHashBuf' ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);                          uint num = base.mStreamPos - base.mPos;                          heads[0] = 2;                          heads[1] = num;                          if (num >= base.mNumHashBytes)                          {                              num = num - base.mNumHashBytes + 1;                              if (num > kMtHashBlockSize - 2)                                  num = kMtHashBlockSize - 2;                              mInterface.GetHeadsFunc(base.mBuffer' base.mPos' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask' heads + 2' num);                              heads[0] += num;                          }                          base.mPos += num;                          base.mBuffer += num;                            Semaphore_Release1(p.mFilledSemaphore);                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,HashThreadFunc,The following statement contains a magic number: for (;;)                  {                      uint numProcessedBlocks = 0;                      Event_Wait(p.mCanStart);                      Event_Set(p.mWasStarted);                      for (;;)                      {                          if (p.mExit)                              return;                            Trace.MatchObjectWait(p' "HashThreadFunc:stop");                          if (p.mStopWriting)                          {                              Trace.MatchObjectWait(p' "HashThreadFunc:stop");                              p.mNumProcessedBlocks = numProcessedBlocks;                              Event_Set(p.mWasStopped);                              break;                          }                          Trace.MatchObjectWait(p' "HashThreadFunc:stop");                            if (base.MatchFinder_NeedMove())                          {                              CriticalSection_Enter(mBtSync.mCS);                              CriticalSection_Enter(mHashSync.mCS);                              {                                  P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();                                  base.MatchFinder_MoveBlock();                                  P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();                                  mPointerToCurPos -= beforePtr - afterPtr;                                  mLocalBuffer -= beforePtr - afterPtr;                              }                              CriticalSection_Leave(mBtSync.mCS);                              CriticalSection_Leave(mHashSync.mCS);                              continue;                          }                            Semaphore_Wait(p.mFreeSemaphore);                            base.MatchFinder_ReadIfRequired();                          if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))                          {                              uint subValue = (base.mPos - base.mHistorySize - 1);                              base.MatchFinder_ReduceOffsets(subValue);                              CMatchFinder.MatchFinder_Normalize3(subValue' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask + 1);                          }                            P<uint> heads = P.From(mHashBuf' ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);                          uint num = base.mStreamPos - base.mPos;                          heads[0] = 2;                          heads[1] = num;                          if (num >= base.mNumHashBytes)                          {                              num = num - base.mNumHashBytes + 1;                              if (num > kMtHashBlockSize - 2)                                  num = kMtHashBlockSize - 2;                              mInterface.GetHeadsFunc(base.mBuffer' base.mPos' P.From(base.mHash' base.mFixedHashSize)' base.mHashMask' heads + 2' num);                              heads[0] += num;                          }                          base.mPos += num;                          base.mBuffer += num;                            Semaphore_Release1(p.mFilledSemaphore);                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,BtGetMatches,The following statement contains a magic number: uint curPos = 2;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,BtGetMatches,The following statement contains a magic number: uint limit = kMtBtBlockSize - (mLocalMatchMaxLen * 2);
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,BtFillBlock,The following statement contains a magic number: if (mLocalPos > kMtMaxValForNormalize - kMtBtBlockSize)                  {                      uint subValue = mLocalPos - mLocalCyclicBufferSize;                      CMatchFinder.MatchFinder_Normalize3(subValue' mLocalSon' mLocalCyclicBufferSize * 2);                      mLocalPos -= subValue;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_Create,The following statement contains a magic number: if (kMtBtBlockSize <= matchMaxLen * 4)                      return SZ_ERROR_PARAM;
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_CreateVTable,The following statement contains a magic number: switch (base.mNumHashBytes)                  {                      case 2:                          vTable = mInterface = new MatchFinderMt2();                          break;                      case 3:                          vTable = mInterface = new MatchFinderMt3();                          break;                      default:  #if PROTOTYPE                      vTable = mInterface = new MatchFinderMt5();                      break;                  case 4:  #endif                          if (base.mBigHash)                              vTable = mInterface = new MatchFinderMt4b();                          else                              vTable = mInterface = new MatchFinderMt4a();                          break;                  }
Magic Number,ManagedLzma.LZMA.Master,CMatchFinderMt,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_CreateVTable,The following statement contains a magic number: switch (base.mNumHashBytes)                  {                      case 2:                          vTable = mInterface = new MatchFinderMt2();                          break;                      case 3:                          vTable = mInterface = new MatchFinderMt3();                          break;                      default:  #if PROTOTYPE                      vTable = mInterface = new MatchFinderMt5();                      break;                  case 4:  #endif                          if (base.mBigHash)                              vTable = mInterface = new MatchFinderMt4b();                          else                              vTable = mInterface = new MatchFinderMt4a();                          break;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMtBase,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_GetMatches,The following statement contains a magic number: if (len == 0)                  {                      if (p.mBtNumAvailBytes-- >= 4)                          len = (uint)(p.mInterface.MixMatchesFunc(p' p.mLzPos - p.mLocalHistorySize' distances) - distances);                  }                  else                  {                      // Condition: there are matches in btBuf with length < p.numHashBytes                      p.mBtNumAvailBytes--;                      P<uint> distances2 = p.mInterface.MixMatchesFunc(p' p.mLzPos - btBuf[1]' distances);                        do                      {                          distances2[0] = btBuf[0];                          distances2++;                          btBuf++;                            distances2[0] = btBuf[0];                          distances2++;                          btBuf++;                            len -= 2;                      }                      while (len != 0);                        len = (uint)(distances2 - distances);                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMtBase,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt_GetMatches,The following statement contains a magic number: if (len == 0)                  {                      if (p.mBtNumAvailBytes-- >= 4)                          len = (uint)(p.mInterface.MixMatchesFunc(p' p.mLzPos - p.mLocalHistorySize' distances) - distances);                  }                  else                  {                      // Condition: there are matches in btBuf with length < p.numHashBytes                      p.mBtNumAvailBytes--;                      P<uint> distances2 = p.mInterface.MixMatchesFunc(p' p.mLzPos - btBuf[1]' distances);                        do                      {                          distances2[0] = btBuf[0];                          distances2++;                          btBuf++;                            distances2[0] = btBuf[0];                          distances2++;                          btBuf++;                            len -= 2;                      }                      while (len != 0);                        len = (uint)(distances2 - distances);                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt2,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = buffer[0] | ((uint)buffer[1] << 8);                      TR("GetHeads2"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt2,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt2_GetMatches,The following statement contains a magic number: for (uint i = 0; i < len; i += 2)                  {                      distances[0] = btBuf[0];                      distances++;                      btBuf++;                        distances[0] = btBuf[0];                      distances++;                      btBuf++;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt3,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8)) & hashMask;                      TR("GetHeads3"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt3,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8)) & hashMask;                      TR("GetHeads3"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt3,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches2,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[(long)curMatch2 - lzPos] == cur[0])                  {                      distances[0] = 2;                      distances++;                      distances[0] = lzPos - curMatch2 - 1;                      distances++;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt3,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt2_Skip,The following statement contains a magic number: do                  {                      if (p.mBtBufPos == p.mBtBufPosLimit)                          p.MatchFinderMt_GetNextBlock_Bt();                        if (p.mBtNumAvailBytes-- >= 2)                      {                          P<byte> cur = p.mPointerToCurPos;                          uint[] hash = p.mLocalHash;                          uint hash2Value = (cur[0].CRC() ^ cur[1]) & (kHash2Size - 1);                          hash[hash2Value] = p.mLzPos;                      }                        p.mLzPos++;                      p.mPointerToCurPos++;                      p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])                  {                      distances[1] = lzPos - curMatch2 - 1;                        if (cur[curMatch2 - lzPos + 2] == cur[2])                      {                          distances[0] = 3;                          return distances + 2;                      }                        distances[0] = 2;                      distances += 2;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MixMatches3,The following statement contains a magic number: if (curMatch3 >= matchMinPos && cur[curMatch3 - lzPos] == cur[0])                  {                      distances[0] = 3;                      distances++;                        distances[0] = lzPos - curMatch3 - 1;                      distances++;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt3_Skip,The following statement contains a magic number: do                  {                      if (p.mBtBufPos == p.mBtBufPosLimit)                          p.MatchFinderMt_GetNextBlock_Bt();                        if (p.mBtNumAvailBytes-- >= 3)                      {                          P<byte> cur = p.mPointerToCurPos;                          uint[] hash = p.mLocalHash;                          uint temp = cur[0].CRC() ^ cur[1];                          uint hash2Value = temp & (kHash2Size - 1);                          uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                          hash[kFix3HashSize + hash3Value] = p.mLzPos;                          hash[hash2Value] = p.mLzPos;                      }                        p.mLzPos++;                      p.mPointerToCurPos++;                      p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt3_Skip,The following statement contains a magic number: do                  {                      if (p.mBtBufPos == p.mBtBufPosLimit)                          p.MatchFinderMt_GetNextBlock_Bt();                        if (p.mBtNumAvailBytes-- >= 3)                      {                          P<byte> cur = p.mPointerToCurPos;                          uint[] hash = p.mLocalHash;                          uint temp = cur[0].CRC() ^ cur[1];                          uint hash2Value = temp & (kHash2Size - 1);                          uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                          hash[kFix3HashSize + hash3Value] = p.mLzPos;                          hash[hash2Value] = p.mLzPos;                      }                        p.mLzPos++;                      p.mPointerToCurPos++;                      p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,MatchFinderMt3_Skip,The following statement contains a magic number: do                  {                      if (p.mBtBufPos == p.mBtBufPosLimit)                          p.MatchFinderMt_GetNextBlock_Bt();                        if (p.mBtNumAvailBytes-- >= 3)                      {                          P<byte> cur = p.mPointerToCurPos;                          uint[] hash = p.mLocalHash;                          uint temp = cur[0].CRC() ^ cur[1];                          uint hash2Value = temp & (kHash2Size - 1);                          uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);                          hash[kFix3HashSize + hash3Value] = p.mLzPos;                          hash[hash2Value] = p.mLzPos;                      }                        p.mLzPos++;                      p.mPointerToCurPos++;                      p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;                  }                  while (--num != 0);
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4a,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;                      TR("GetHeads4"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4a,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;                      TR("GetHeads4"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4a,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;                      TR("GetHeads4"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4a,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;                      TR("GetHeads4"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4b,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;                      TR("GetHeads4b"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4b,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;                      TR("GetHeads4b"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4b,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;                      TR("GetHeads4b"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,MatchFinderMt4b,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzFindMt.cs,GetHeadsFunc,The following statement contains a magic number: while (numHeads != 0)                  {                      uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;                      TR("GetHeads4b"' value);                      buffer++;                      heads[0] = pos - hash[value];                      heads++;                      hash[value] = pos++;                      numHeads--;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,GetLzmaMode,The following statement contains a magic number: return (mControl >> 5) & 3;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,GetLzmaMode,The following statement contains a magic number: return (mControl >> 5) & 3;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,IsThereProp,The following statement contains a magic number: return mode >= 2;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,DicSizeFromProp,The following statement contains a magic number: return (2u | (p & 1u)) << ((p >> 1) + 11);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: if (prop > 40)                      return SZ_ERROR_UNSUPPORTED;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: uint dicSize = (prop == 40) ? 0xFFFFFFFF : DicSizeFromProp(prop);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[2] = (byte)(dicSize >> 8);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[2] = (byte)(dicSize >> 8);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[3] = (byte)(dicSize >> 16);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[3] = (byte)(dicSize >> 16);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[4] = (byte)(dicSize >> 24);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_GetOldProps,The following statement contains a magic number: props[4] = (byte)(dicSize >> 24);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_UpdateState,The following statement contains a magic number: switch (mState)                  {                      case Lzma2State.Control:                          mControl = b;                          TR("Lzma2Dec_UpdateState:1"' checked((int)mDecoder.mDicPos));                          TR("Lzma2Dec_UpdateState:2"' b);                          DebugPrint("\n {0:X4} "' mDecoder.mDicPos);                          DebugPrint(" {0:X2}"' b);                            if (mControl == 0)                              return Lzma2State.Finished;                            if (IsUncompressedState())                          {                              if ((mControl & 0x7F) > 2)                                  return Lzma2State.Error;                                mUnpackSize = 0;                          }                          else                          {                              mUnpackSize = (uint)(mControl & 0x1F) << 16;                          }                            return Lzma2State.Unpack0;                        case Lzma2State.Unpack0:                          mUnpackSize |= (uint)b << 8;                          return Lzma2State.Unpack1;                        case Lzma2State.Unpack1:                          mUnpackSize |= (uint)b;                          mUnpackSize++;                            TR("Lzma2Dec_UpdateState:3"' mUnpackSize);                          DebugPrint(" {0:00000000}"' mUnpackSize);                            if (IsUncompressedState())                              return Lzma2State.Data;                          else                              return Lzma2State.Pack0;                        case Lzma2State.Pack0:                          mPackSize = (uint)b << 8;                          return Lzma2State.Pack1;                        case Lzma2State.Pack1:                          mPackSize |= (uint)b;                          mPackSize++;                            TR("Lzma2Dec_UpdateState:4"' mPackSize);                          DebugPrint(" {0:00000000}"' mPackSize);                            if (IsThereProp(GetLzmaMode()))                              return Lzma2State.Prop;                          else if (mNeedInitProp)                              return Lzma2State.Error;                          else                              return Lzma2State.Data;                        case Lzma2State.Prop:                          if (b >= (9 * 5 * 5))                              return Lzma2State.Error;                            int lc = b % 9;                          b /= 9;                          mDecoder.mProp.mPB = b / 5;                          int lp = b % 5;                            if (lc + lp > LZMA2_LCLP_MAX)                              return Lzma2State.Error;                            mDecoder.mProp.mLC = lc;                          mDecoder.mProp.mLP = lp;                          mNeedInitProp = false;                          return Lzma2State.Data;                        default:                          return Lzma2State.Error;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Dec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Dec.cs,Lzma2Dec_DecodeToDic,The following statement contains a magic number: while (mState != Lzma2State.Finished)                  {                      long dicPos = mDecoder.mDicPos;                      if (mState == Lzma2State.Error)                          return SZ_ERROR_DATA;                        if (dicPos == dicLimit && finishMode == ELzmaFinishMode.LZMA_FINISH_ANY)                      {                          status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;                          return SZ_OK;                      }                        if (mState != Lzma2State.Data && mState != Lzma2State.DataCont)                      {                          if (srcLen == inSize)                          {                              status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;                              return SZ_OK;                          }                          srcLen++;                          mState = Lzma2Dec_UpdateState(src[0]);                          src++;                          continue;                      }                        long destSizeCur = dicLimit - dicPos;                      long srcSizeCur = inSize - srcLen;                      ELzmaFinishMode curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;                        if (mUnpackSize <= destSizeCur)                      {                          destSizeCur = mUnpackSize;                          curFinishMode = ELzmaFinishMode.LZMA_FINISH_END;                      }                        if (IsUncompressedState())                      {                          if (srcLen == inSize)                          {                              status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;                              return SZ_OK;                          }                            if (mState == Lzma2State.Data)                          {                              bool initDic = (mControl == LZMA2_CONTROL_COPY_RESET_DIC);                              if (initDic)                                  mNeedInitProp = mNeedInitState = true;                              else if (mNeedInitDic)                                  return SZ_ERROR_DATA;                                mNeedInitDic = false;                              mDecoder.LzmaDec_InitDicAndState(initDic' false);                          }                            if (srcSizeCur > destSizeCur)                              srcSizeCur = destSizeCur;                            if (srcSizeCur == 0)                              return SZ_ERROR_DATA;                            LzmaDec_UpdateWithUncompressed(mDecoder' src' srcSizeCur);                            src += srcSizeCur;                          srcLen += srcSizeCur;                          mUnpackSize -= (uint)srcSizeCur;                          mState = (mUnpackSize == 0) ? Lzma2State.Control : Lzma2State.DataCont;                      }                      else                      {                          long outSizeProcessed;                            if (mState == Lzma2State.Data)                          {                              int mode = GetLzmaMode();                              bool initDic = (mode == 3);                              bool initState = (mode > 0);                              if ((!initDic && mNeedInitDic) || (!initState && mNeedInitState))                                  return SZ_ERROR_DATA;                                mDecoder.LzmaDec_InitDicAndState(initDic' initState);                              mNeedInitDic = false;                              mNeedInitState = false;                              mState = Lzma2State.DataCont;                          }                            if (srcSizeCur > mPackSize)                              srcSizeCur = mPackSize;                            SRes res = mDecoder.LzmaDec_DecodeToDic(dicPos + destSizeCur' src' ref srcSizeCur' curFinishMode' out status);                            src += srcSizeCur;                          srcLen += srcSizeCur;                          mPackSize -= (uint)srcSizeCur;                            outSizeProcessed = mDecoder.mDicPos - dicPos;                          mUnpackSize -= (uint)outSizeProcessed;                            if (res != SZ_OK)                              return res;                            if (status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)                              return res;                            if (srcSizeCur == 0 && outSizeProcessed == 0)                          {                              if (status != ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK || mUnpackSize != 0 || mPackSize != 0)                                  return SZ_ERROR_DATA;                                mState = Lzma2State.Control;                          }                            if (status == ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)                              status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncProps_Normalize,The following statement contains a magic number: if (mBlockSize == 0)                  {                      uint dictSize = mLzmaProps.mDictSize;                      long blockSize = (long)dictSize << 2;                        const uint kMinSize = 1 << 20;                      const uint kMaxSize = 1 << 28;                        if (blockSize < kMinSize)                          blockSize = kMinSize;                        if (blockSize > kMaxSize)                          blockSize = kMaxSize;                        if (blockSize < dictSize)                          blockSize = dictSize;                        mBlockSize = blockSize;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncProps_Normalize,The following statement contains a magic number: if (mBlockSize == 0)                  {                      uint dictSize = mLzmaProps.mDictSize;                      long blockSize = (long)dictSize << 2;                        const uint kMinSize = 1 << 20;                      const uint kMaxSize = 1 << 28;                        if (blockSize < kMinSize)                          blockSize = kMinSize;                        if (blockSize > kMaxSize)                          blockSize = kMaxSize;                        if (blockSize < dictSize)                          blockSize = dictSize;                        mBlockSize = blockSize;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncProps_Normalize,The following statement contains a magic number: if (mBlockSize == 0)                  {                      uint dictSize = mLzmaProps.mDictSize;                      long blockSize = (long)dictSize << 2;                        const uint kMinSize = 1 << 20;                      const uint kMaxSize = 1 << 28;                        if (blockSize < kMinSize)                          blockSize = kMinSize;                        if (blockSize > kMaxSize)                          blockSize = kMaxSize;                        if (blockSize < dictSize)                          blockSize = dictSize;                        mBlockSize = blockSize;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (res == SZ_OK)                      useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));                  else                  {                      if (res != SZ_ERROR_OUTPUT_EOF)                          return res;                      res = SZ_OK;                      useCopyBlock = true;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (res == SZ_OK)                      useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));                  else                  {                      if (res != SZ_ERROR_OUTPUT_EOF)                          return res;                      res = SZ_OK;                      useCopyBlock = true;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2EncInternal,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2EncInt_EncodeSubblock,The following statement contains a magic number: if (useCopyBlock)                  {                      long destPos = 0;                      DebugPrint("################# COPY           ");                        while (unpackSize > 0)                      {                          uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;                          if (packSizeLimit - destPos < u + 3)                              return SZ_ERROR_OUTPUT_EOF;                            outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);                          outBuf[destPos++] = (byte)((u - 1) >> 8);                          outBuf[destPos++] = (byte)(u - 1);                            CUtils.memcpy(outBuf + destPos' mEnc.LzmaEnc_GetCurBuf() - unpackSize' u);                            unpackSize -= u;                          destPos += u;                          mSrcPos += u;                            if (outStream != null)                          {                              packSizeRes += destPos;                              if (outStream.Write(outBuf' destPos) != destPos)                                  return SZ_ERROR_WRITE;                              destPos = 0;                          }                          else                          {                              packSizeRes = destPos;                          }                            /* needInitState = true; */                      }                        mEnc.LzmaEnc_RestoreState();                      return SZ_OK;                  }                  else                  {                      long destPos = 0;                      uint u = unpackSize - 1;                      uint pm = (uint)(packSize - 1);                        uint mode;                      if (mSrcPos == 0)                          mode = 3;                      else if (!mNeedInitState)                          mode = 0;                      else if (!mNeedInitProp)                          mode = 1;                      else                          mode = 2;                        DebugPrint("               ");                        outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));                      outBuf[destPos++] = (byte)(u >> 8);                      outBuf[destPos++] = (byte)u;                      outBuf[destPos++] = (byte)(pm >> 8);                      outBuf[destPos++] = (byte)pm;                        if (mNeedInitProp)                          outBuf[destPos++] = mProps;                        mNeedInitProp = false;                      mNeedInitState = false;                      destPos += packSize;                      mSrcPos += unpackSize;                        if (outStream != null && outStream.Write(outBuf' destPos) != destPos)                          return SZ_ERROR_WRITE;                        packSizeRes = destPos;                      return SZ_OK;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2Enc_WriteProperties,The following statement contains a magic number: while (i < 40 && dicSize > LZMA2_DIC_SIZE_FROM_PROP(i))                      i++;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2Enc_Encode,The following statement contains a magic number: mMtCoder.mDestBlockSize = mProps.mBlockSize + (mProps.mBlockSize >> 10) + 16;
Magic Number,ManagedLzma.LZMA.Master,CLzma2Enc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\Lzma2Enc.cs,Lzma2Enc_Encode,The following statement contains a magic number: mMtCoder.mDestBlockSize = mProps.mBlockSize + (mProps.mBlockSize >> 10) + 16;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: if (d >= (9 * 5 * 5))                      return SZ_ERROR_UNSUPPORTED;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: if (d >= (9 * 5 * 5))                      return SZ_ERROR_UNSUPPORTED;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: if (d >= (9 * 5 * 5))                      return SZ_ERROR_UNSUPPORTED;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: mLC = d % 9;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: d /= 9;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: mPB = d / 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaProps_Decode,The following statement contains a magic number: mLP = d % 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: uint rep2 = mReps[2];
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: uint rep3 = mReps[3];
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: do                  {                      uint bound;                      uint ttt;                      uint posState = processedPos & pbMask;                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                      {                          _UPDATE_0(prob' ttt' bound' ref range);                          prob = probs + kLiteral;                          if (checkDicSize != 0 || processedPos != 0)                              prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)                                  + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));                            uint symbol;                          if (state < kNumLitStates)                          {                              state -= (state < 4) ? state : 3;                              symbol = 1;                              do { _GET_BIT(prob + symbol' ref symbol' out ttt' out bound' ref range' ref code' ref buf); }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                              uint offs = 0x100;                              state -= (state < 10) ? 3u : 6u;                              symbol = 1;                              do                              {                                  uint bit;                                  P<ushort> probLit;                                  matchByte <<= 1;                                  bit = (matchByte & offs);                                  probLit = prob + offs + bit + symbol;                                  if (_GET_BIT2(probLit' ref symbol' out ttt' out bound' ref range' ref code' ref buf))                                      offs &= bit;                                  else                                      offs &= ~bit;                              }                              while (symbol < 0x100);                          }                          dic[dicPos++] = (byte)symbol;                          processedPos++;                          continue;                      }                      else                      {                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                          prob = probs + kIsRep + state;                          if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                          {                              _UPDATE_0(prob' ttt' bound' ref range);                              state += kNumStates;                              prob = probs + kLenCoder;                          }                          else                          {                              _UPDATE_1(prob' ttt' bound' ref range' ref code);                              if (checkDicSize == 0 && processedPos == 0)                                  return SZ_ERROR_DATA;                              prob = probs + kIsRepG0 + state;                              if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(prob' ttt' bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];                                      dicPos++;                                      processedPos++;                                      state = state < kNumLitStates ? 9u : 11u;                                      continue;                                  }                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                              }                              else                              {                                  uint distance;                                  _UPDATE_1(prob' ttt' bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(prob' ttt' bound' ref range);                                      distance = rep1;                                  }                                  else                                  {                                      _UPDATE_1(prob' ttt' bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (_IF_BIT_0(prob' out ttt' out bound' ref range' ref code' ref buf))                                      {                                          _UPDATE_0(prob' ttt' bound' ref range);                                          distance = rep2;                                      }                                      else                                      {                                          _UPDATE_1(prob' ttt' bound' ref range' ref code);                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              state = state < kNumLitStates ? 8u : 11u;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit2' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                              {                                  _UPDATE_0(probLen' ttt' bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit2 = (1 << kLenNumLowBits);                              }                              else                              {                                  _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (_IF_BIT_0(probLen' out ttt' out bound' ref range' ref code' ref buf))                                  {                                      _UPDATE_0(probLen' ttt' bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit2 = (1 << kLenNumMidBits);                                  }                                  else                                  {                                      _UPDATE_1(probLen' ttt' bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit2 = (1 << kLenNumHighBits);                                  }                              }                              _TREE_DECODE(probLen' limit2' out len' out ttt' out bound' ref range' ref code' ref buf);                              len += offset;                          }                            if (state >= kNumStates)                          {                              uint distance;                              prob = probs + kPosSlot +                                  ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              _TREE_6_DECODE(prob' out distance' out ttt' out bound' ref range' ref code' ref buf);                              if (distance >= kStartPosModelIndex)                              {                                  uint posSlot = (uint)distance;                                  int numDirectBits = (int)(((distance >> 1) - 1));                                  distance = (2 | (distance & 1));                                  if (posSlot < kEndPosModelIndex)                                  {                                      distance <<= numDirectBits;                                      prob = probs + kSpecPos + distance - posSlot - 1;                                      {                                          uint mask = 1;                                          uint i = 1;                                          do                                          {                                              if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf))                                                  distance |= mask;                                              mask <<= 1;                                          }                                          while (--numDirectBits != 0);                                      }                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          _NORMALIZE(ref range' ref code' ref buf);                                          range >>= 1;                                            {                                              uint t;                                              code -= range;                                              t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */                                              distance = (distance << 1) + (t + 1);                                              code += range & t;                                          }                                          /*                                          distance <<= 1;                                          if (code >= range)                                          {                                            code -= range;                                            distance |= 1;                                          }                                          */                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      distance <<= kNumAlignBits;                                      {                                          uint i = 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 1;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 2;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 4;                                          if (_GET_BIT2(prob + i' ref i' out ttt' out bound' ref range' ref code' ref buf)) distance |= 8;                                      }                                      if (distance == (uint)0xFFFFFFFF)                                      {                                          len += kMatchSpecLenStart;                                          state -= kNumStates;                                          break;                                      }                                  }                              }                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              rep0 = distance + 1;                              if (checkDicSize == 0)                              {                                  if (distance >= processedPos)                                      return SZ_ERROR_DATA;                              }                              else if (distance >= checkDicSize)                                  return SZ_ERROR_DATA;                              state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;                          }                            len += kMatchMinLen;                            if (limit == dicPos)                              return SZ_ERROR_DATA;                          {                              long rem = limit - dicPos;                              uint curLen = ((rem < len) ? (uint)rem : len);                              long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);                                processedPos += curLen;                                len -= curLen;                              if (pos + curLen <= dicBufSize)                              {                                  P<byte> dest = dic + dicPos;                                  long src = (long)pos - (long)dicPos;                                  P<byte> lim = dest + curLen;                                  dicPos += curLen;                                  do { dest[0] = dest[src]; }                                  while (++dest != lim);                              }                              else                              {                                  do                                  {                                      dic[dicPos++] = dic[pos];                                      if (++pos == dicBufSize)                                          pos = 0;                                  }                                  while (--curLen != 0);                              }                          }                      }                  }                  while (dicPos < limit && buf < bufLimit);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: mReps[2] = rep2;
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_DecodeReal,The following statement contains a magic number: mReps[3] = rep3;
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The following statement contains a magic number: {                      bool xxx;                        uint bound;                      uint ttt;                      uint posState = mProcessedPos & ((1u << mProp.mPB) - 1);                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                          return ELzmaDummy.DUMMY_ERROR;                      if (xxx)                      {                          _UPDATE_0_CHECK(bound' ref range);                            /* if (bufLimit - buf >= 7) return DUMMY_LIT; */                            prob = probs + kLiteral;                          if (mCheckDicSize != 0 || mProcessedPos != 0)                              prob += LZMA_LIT_SIZE *                                  (((mProcessedPos & ((1 << mProp.mLP) - 1)) << mProp.mLC) +                                  (mDic[(mDicPos == 0 ? mDicBufSize : mDicPos) - 1] >> (8 - mProp.mLC)));                            if (state < kNumLitStates)                          {                              uint symbol = 1;                              do                              {                                  if (!_GET_BIT_CHECK(prob + symbol' ref symbol' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[mDicPos - mReps[0] + (mDicPos < mReps[0] ? mDicBufSize : 0)];                              uint offs = 0x100;                              uint symbol = 1;                              do                              {                                  matchByte <<= 1;                                  uint bit = matchByte & offs;                                  P<ushort> probLit = prob + offs + bit + symbol;                                  if (!_GET_BIT2_CHECK(probLit' ref symbol' delegate { offs &= ~bit; }' delegate { offs &= bit; }' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          res = ELzmaDummy.DUMMY_LIT;                      }                      else                      {                          uint len;                          _UPDATE_1_CHECK(bound' ref range' ref code);                            prob = probs + kIsRep + state;                          if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                              return ELzmaDummy.DUMMY_ERROR;                          if (xxx)                          {                              _UPDATE_0_CHECK(bound' ref range);                              state = 0;                              prob = probs + kLenCoder;                              res = ELzmaDummy.DUMMY_MATCH;                          }                          else                          {                              _UPDATE_1_CHECK(bound' ref range' ref code);                              res = ELzmaDummy.DUMMY_REP;                              prob = probs + kIsRepG0 + state;                              if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      return ELzmaDummy.DUMMY_REP;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                  }                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      if (xxx)                                      {                                          _UPDATE_0_CHECK(bound' ref range);                                      }                                      else                                      {                                          _UPDATE_1_CHECK(bound' ref range' ref code);                                      }                                  }                              }                              state = kNumStates;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit = 1 << kLenNumLowBits;                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit = 1 << kLenNumMidBits;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit = 1 << kLenNumHighBits;                                  }                              }                              if (!_TREE_DECODE_CHECK(probLen' limit' out len' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              len += offset;                          }                            if (state < 4)                          {                              prob = probs + kPosSlot + ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              uint posSlot;                              if (!_TREE_DECODE_CHECK(prob' 1 << kNumPosSlotBits' out posSlot' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (posSlot >= kStartPosModelIndex)                              {                                  int numDirectBits = (((int)posSlot >> 1) - 1);                                    /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */                                    if (posSlot < kEndPosModelIndex)                                  {                                      prob = probs + kSpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                            range >>= 1;                                            //code -= range & (((code - range) >> 31) - 1);                                          if (code >= range)                                              code -= range;                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      numDirectBits = kNumAlignBits;                                  }                                  {                                      uint i = 1;                                      do                                      {                                          if (!_GET_BIT_CHECK(prob + i' ref i' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                      }                                      while (--numDirectBits != 0);                                  }                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The following statement contains a magic number: {                      bool xxx;                        uint bound;                      uint ttt;                      uint posState = mProcessedPos & ((1u << mProp.mPB) - 1);                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                          return ELzmaDummy.DUMMY_ERROR;                      if (xxx)                      {                          _UPDATE_0_CHECK(bound' ref range);                            /* if (bufLimit - buf >= 7) return DUMMY_LIT; */                            prob = probs + kLiteral;                          if (mCheckDicSize != 0 || mProcessedPos != 0)                              prob += LZMA_LIT_SIZE *                                  (((mProcessedPos & ((1 << mProp.mLP) - 1)) << mProp.mLC) +                                  (mDic[(mDicPos == 0 ? mDicBufSize : mDicPos) - 1] >> (8 - mProp.mLC)));                            if (state < kNumLitStates)                          {                              uint symbol = 1;                              do                              {                                  if (!_GET_BIT_CHECK(prob + symbol' ref symbol' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[mDicPos - mReps[0] + (mDicPos < mReps[0] ? mDicBufSize : 0)];                              uint offs = 0x100;                              uint symbol = 1;                              do                              {                                  matchByte <<= 1;                                  uint bit = matchByte & offs;                                  P<ushort> probLit = prob + offs + bit + symbol;                                  if (!_GET_BIT2_CHECK(probLit' ref symbol' delegate { offs &= ~bit; }' delegate { offs &= bit; }' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          res = ELzmaDummy.DUMMY_LIT;                      }                      else                      {                          uint len;                          _UPDATE_1_CHECK(bound' ref range' ref code);                            prob = probs + kIsRep + state;                          if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                              return ELzmaDummy.DUMMY_ERROR;                          if (xxx)                          {                              _UPDATE_0_CHECK(bound' ref range);                              state = 0;                              prob = probs + kLenCoder;                              res = ELzmaDummy.DUMMY_MATCH;                          }                          else                          {                              _UPDATE_1_CHECK(bound' ref range' ref code);                              res = ELzmaDummy.DUMMY_REP;                              prob = probs + kIsRepG0 + state;                              if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      return ELzmaDummy.DUMMY_REP;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                  }                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      if (xxx)                                      {                                          _UPDATE_0_CHECK(bound' ref range);                                      }                                      else                                      {                                          _UPDATE_1_CHECK(bound' ref range' ref code);                                      }                                  }                              }                              state = kNumStates;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit = 1 << kLenNumLowBits;                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit = 1 << kLenNumMidBits;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit = 1 << kLenNumHighBits;                                  }                              }                              if (!_TREE_DECODE_CHECK(probLen' limit' out len' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              len += offset;                          }                            if (state < 4)                          {                              prob = probs + kPosSlot + ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              uint posSlot;                              if (!_TREE_DECODE_CHECK(prob' 1 << kNumPosSlotBits' out posSlot' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (posSlot >= kStartPosModelIndex)                              {                                  int numDirectBits = (((int)posSlot >> 1) - 1);                                    /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */                                    if (posSlot < kEndPosModelIndex)                                  {                                      prob = probs + kSpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                            range >>= 1;                                            //code -= range & (((code - range) >> 31) - 1);                                          if (code >= range)                                              code -= range;                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      numDirectBits = kNumAlignBits;                                  }                                  {                                      uint i = 1;                                      do                                      {                                          if (!_GET_BIT_CHECK(prob + i' ref i' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                      }                                      while (--numDirectBits != 0);                                  }                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_TryDummy,The following statement contains a magic number: {                      bool xxx;                        uint bound;                      uint ttt;                      uint posState = mProcessedPos & ((1u << mProp.mPB) - 1);                        P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                          return ELzmaDummy.DUMMY_ERROR;                      if (xxx)                      {                          _UPDATE_0_CHECK(bound' ref range);                            /* if (bufLimit - buf >= 7) return DUMMY_LIT; */                            prob = probs + kLiteral;                          if (mCheckDicSize != 0 || mProcessedPos != 0)                              prob += LZMA_LIT_SIZE *                                  (((mProcessedPos & ((1 << mProp.mLP) - 1)) << mProp.mLC) +                                  (mDic[(mDicPos == 0 ? mDicBufSize : mDicPos) - 1] >> (8 - mProp.mLC)));                            if (state < kNumLitStates)                          {                              uint symbol = 1;                              do                              {                                  if (!_GET_BIT_CHECK(prob + symbol' ref symbol' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          else                          {                              uint matchByte = mDic[mDicPos - mReps[0] + (mDicPos < mReps[0] ? mDicBufSize : 0)];                              uint offs = 0x100;                              uint symbol = 1;                              do                              {                                  matchByte <<= 1;                                  uint bit = matchByte & offs;                                  P<ushort> probLit = prob + offs + bit + symbol;                                  if (!_GET_BIT2_CHECK(probLit' ref symbol' delegate { offs &= ~bit; }' delegate { offs &= bit; }' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                              }                              while (symbol < 0x100);                          }                          res = ELzmaDummy.DUMMY_LIT;                      }                      else                      {                          uint len;                          _UPDATE_1_CHECK(bound' ref range' ref code);                            prob = probs + kIsRep + state;                          if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                              return ELzmaDummy.DUMMY_ERROR;                          if (xxx)                          {                              _UPDATE_0_CHECK(bound' ref range);                              state = 0;                              prob = probs + kLenCoder;                              res = ELzmaDummy.DUMMY_MATCH;                          }                          else                          {                              _UPDATE_1_CHECK(bound' ref range' ref code);                              res = ELzmaDummy.DUMMY_REP;                              prob = probs + kIsRepG0 + state;                              if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      return ELzmaDummy.DUMMY_REP;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                  }                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  prob = probs + kIsRepG1 + state;                                  if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      prob = probs + kIsRepG2 + state;                                      if (!_IF_BIT_0_CHECK(out xxx' prob' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                          return ELzmaDummy.DUMMY_ERROR;                                      if (xxx)                                      {                                          _UPDATE_0_CHECK(bound' ref range);                                      }                                      else                                      {                                          _UPDATE_1_CHECK(bound' ref range' ref code);                                      }                                  }                              }                              state = kNumStates;                              prob = probs + kRepLenCoder;                          }                          {                              uint limit' offset;                              P<ushort> probLen = prob + kLenChoice;                              if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (xxx)                              {                                  _UPDATE_0_CHECK(bound' ref range);                                  probLen = prob + kLenLow + (posState << kLenNumLowBits);                                  offset = 0;                                  limit = 1 << kLenNumLowBits;                              }                              else                              {                                  _UPDATE_1_CHECK(bound' ref range' ref code);                                  probLen = prob + kLenChoice2;                                  if (!_IF_BIT_0_CHECK(out xxx' probLen' out ttt' out bound' ref range' ref code' ref buf' bufLimit))                                      return ELzmaDummy.DUMMY_ERROR;                                  if (xxx)                                  {                                      _UPDATE_0_CHECK(bound' ref range);                                      probLen = prob + kLenMid + (posState << kLenNumMidBits);                                      offset = kLenNumLowSymbols;                                      limit = 1 << kLenNumMidBits;                                  }                                  else                                  {                                      _UPDATE_1_CHECK(bound' ref range' ref code);                                      probLen = prob + kLenHigh;                                      offset = kLenNumLowSymbols + kLenNumMidSymbols;                                      limit = 1 << kLenNumHighBits;                                  }                              }                              if (!_TREE_DECODE_CHECK(probLen' limit' out len' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              len += offset;                          }                            if (state < 4)                          {                              prob = probs + kPosSlot + ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);                              uint posSlot;                              if (!_TREE_DECODE_CHECK(prob' 1 << kNumPosSlotBits' out posSlot' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                  return ELzmaDummy.DUMMY_ERROR;                              if (posSlot >= kStartPosModelIndex)                              {                                  int numDirectBits = (((int)posSlot >> 1) - 1);                                    /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */                                    if (posSlot < kEndPosModelIndex)                                  {                                      prob = probs + kSpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;                                  }                                  else                                  {                                      numDirectBits -= kNumAlignBits;                                      do                                      {                                          if (!_NORMALIZE_CHECK(ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                            range >>= 1;                                            //code -= range & (((code - range) >> 31) - 1);                                          if (code >= range)                                              code -= range;                                      }                                      while (--numDirectBits != 0);                                      prob = probs + kAlign;                                      numDirectBits = kNumAlignBits;                                  }                                  {                                      uint i = 1;                                      do                                      {                                          if (!_GET_BIT_CHECK(prob + i' ref i' out ttt' ref bound' ref range' ref code' ref buf' bufLimit))                                              return ELzmaDummy.DUMMY_ERROR;                                      }                                      while (--numDirectBits != 0);                                  }                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitRc,The following statement contains a magic number: mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitStateReal,The following statement contains a magic number: mReps[2] = 1;
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,LzmaDec_InitStateReal,The following statement contains a magic number: mReps[3] = 1;
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_NORMALIZE,The following statement contains a magic number: if (range < kTopValue)                  {                      range <<= 8;                      code = (code << 8) | buf[0];                      buf++;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_NORMALIZE,The following statement contains a magic number: if (range < kTopValue)                  {                      range <<= 8;                      code = (code << 8) | buf[0];                      buf++;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_TREE_6_DECODE,The following statement contains a magic number: _TREE_DECODE(probs' 1 << 6' out i' out ttt' out bound' ref range' ref code' ref buf);
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_NORMALIZE_CHECK,The following statement contains a magic number: if (range < kTopValue)                  {                      if (buf >= bufLimit)                          return false; // ELzmaDummy.DUMMY_ERROR;                        range <<= 8;                      code = (code << 8) | buf[0];                      buf++;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaDec,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaDec.cs,_NORMALIZE_CHECK,The following statement contains a magic number: if (range < kTopValue)                  {                      if (buf >= bufLimit)                          return false; // ELzmaDummy.DUMMY_ERROR;                        range <<= 8;                      code = (code << 8) | buf[0];                      buf++;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,CLzmaEncProps,The following statement contains a magic number: this.mLevel = 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (level < 0)                      level = 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize == 0)                  {                      if (level <= 5)                          mDictSize = (1u << (level * 2 + 14));                      else if (level == 6)                          mDictSize = (1u << 25);                      else                          mDictSize = (1u << 26);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize > mReduceSize)                  {                      for (int i = 15; i <= 30; i++)                      {                          if (mReduceSize <= (2u << i))                          {                              mDictSize = (2u << i);                              break;                          }                          if (mReduceSize <= (3u << i))                          {                              mDictSize = (3u << i);                              break;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mDictSize > mReduceSize)                  {                      for (int i = 15; i <= 30; i++)                      {                          if (mReduceSize <= (2u << i))                          {                              mDictSize = (2u << i);                              break;                          }                          if (mReduceSize <= (3u << i))                          {                              mDictSize = (3u << i);                              break;                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mLC < 0)                      mLC = 3;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mPB < 0)                      mPB = 2;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mAlgo < 0)                      mAlgo = (level < 5 ? 0 : 1);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mFB < 0)                      mFB = (level < 7 ? 32 : 64);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mFB < 0)                      mFB = (level < 7 ? 32 : 64);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mFB < 0)                      mFB = (level < 7 ? 32 : 64);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mNumHashBytes < 0)                      mNumHashBytes = 4;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEncProps,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEncProps_Normalize,The following statement contains a magic number: if (mNumThreads < 0)                      mNumThreads =  #if !_7ZIP_ST                          ((mBtMode != 0 && mAlgo != 0) ? 2 : 1);
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_ShiftLow,The following statement contains a magic number: if ((uint)mLow < (uint)0xFF000000 || (int)(mLow >> 32) != 0)                  {                      byte temp = mCache;                      do                      {                          P<byte> buf = mBuf;                          buf[0] = (byte)(temp + (byte)(mLow >> 32));                          buf++;                          mBuf = buf;                          if (buf == mBufLim)                              RangeEnc_FlushStream();                          temp = 0xFF;                      }                      while (--mCacheSize != 0);                        mCache = (byte)((uint)mLow >> 24);                  }
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_ShiftLow,The following statement contains a magic number: if ((uint)mLow < (uint)0xFF000000 || (int)(mLow >> 32) != 0)                  {                      byte temp = mCache;                      do                      {                          P<byte> buf = mBuf;                          buf[0] = (byte)(temp + (byte)(mLow >> 32));                          buf++;                          mBuf = buf;                          if (buf == mBufLim)                              RangeEnc_FlushStream();                          temp = 0xFF;                      }                      while (--mCacheSize != 0);                        mCache = (byte)((uint)mLow >> 24);                  }
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_ShiftLow,The following statement contains a magic number: if ((uint)mLow < (uint)0xFF000000 || (int)(mLow >> 32) != 0)                  {                      byte temp = mCache;                      do                      {                          P<byte> buf = mBuf;                          buf[0] = (byte)(temp + (byte)(mLow >> 32));                          buf++;                          mBuf = buf;                          if (buf == mBufLim)                              RangeEnc_FlushStream();                          temp = 0xFF;                      }                      while (--mCacheSize != 0);                        mCache = (byte)((uint)mLow >> 24);                  }
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_ShiftLow,The following statement contains a magic number: mLow = (uint)mLow << 8;
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      RangeEnc_ShiftLow();
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_EncodeDirectBits,The following statement contains a magic number: do                  {                      mRange >>= 1;                      mLow += mRange & (0 - ((value >> --numBits) & 1));                      if (mRange < CLzmaEnc.kTopValue)                      {                          mRange <<= 8;                          RangeEnc_ShiftLow();                      }                  }                  while (numBits != 0);
Magic Number,ManagedLzma.LZMA.Master,CRangeEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,RangeEnc_EncodeBit,The following statement contains a magic number: if (mRange < CLzmaEnc.kTopValue)                  {                      mRange <<= 8;                      RangeEnc_ShiftLow();                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_FastPosInit,The following statement contains a magic number: int i = 2;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_FastPosInit,The following statement contains a magic number: for (int slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)                  {                      int k = 1 << ((slotFast >> 1) - 1);                      for (int j = 0; j < k; j++)                          mFastPos[i++] = (byte)slotFast;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_FastPosInit,The following statement contains a magic number: for (int slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)                  {                      int k = 1 << ((slotFast >> 1) - 1);                      for (int j = 0; j < k; j++)                          mFastPos[i++] = (byte)slotFast;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,BSR2_RET,The following statement contains a magic number: uint i = 6 + ((kNumLogBits - 1) & (0 - ((((1 << (kNumLogBits + 6)) - 1) - pos) >> 31)));
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,BSR2_RET,The following statement contains a magic number: uint i = 6 + ((kNumLogBits - 1) & (0 - ((((1 << (kNumLogBits + 6)) - 1) - pos) >> 31)));
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,BSR2_RET,The following statement contains a magic number: uint i = 6 + ((kNumLogBits - 1) & (0 - ((((1 << (kNumLogBits + 6)) - 1) - pos) >> 31)));
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,BSR2_RET,The following statement contains a magic number: return mFastPos[pos >> (int)i] + (i * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,IsCharState,The following statement contains a magic number: return s < 7;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetLenToPosState,The following statement contains a magic number: return (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_Encode,The following statement contains a magic number: do                  {                      p.RangeEnc_EncodeBit(probs + (symbol >> 8)' (symbol >> 7) & 1);                      symbol <<= 1;                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_Encode,The following statement contains a magic number: do                  {                      p.RangeEnc_EncodeBit(probs + (symbol >> 8)' (symbol >> 7) & 1);                      symbol <<= 1;                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_EncodeMatched,The following statement contains a magic number: do                  {                      matchByte <<= 1;                      p.RangeEnc_EncodeBit(probs + (offs + (matchByte & offs) + (symbol >> 8))' (symbol >> 7) & 1);                      symbol <<= 1;                      offs &= ~(matchByte ^ symbol);                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_EncodeMatched,The following statement contains a magic number: do                  {                      matchByte <<= 1;                      p.RangeEnc_EncodeBit(probs + (offs + (matchByte & offs) + (symbol >> 8))' (symbol >> 7) & 1);                      symbol <<= 1;                      offs &= ~(matchByte ^ symbol);                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_InitPriceTables,The following statement contains a magic number: for (uint i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))                  {                      const int kCyclesBits = kNumBitPriceShiftBits;                        uint w = i;                      uint bitCount = 0;                      for (int j = 0; j < kCyclesBits; j++)                      {                          w = w * w;                          bitCount <<= 1;                          while (w >= ((uint)1 << 16))                          {                              w >>= 1;                              bitCount++;                          }                      }                        probPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_InitPriceTables,The following statement contains a magic number: for (uint i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))                  {                      const int kCyclesBits = kNumBitPriceShiftBits;                        uint w = i;                      uint bitCount = 0;                      for (int j = 0; j < kCyclesBits; j++)                      {                          w = w * w;                          bitCount <<= 1;                          while (w >= ((uint)1 << 16))                          {                              w >>= 1;                              bitCount++;                          }                      }                        probPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_InitPriceTables,The following statement contains a magic number: for (uint i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))                  {                      const int kCyclesBits = kNumBitPriceShiftBits;                        uint w = i;                      uint bitCount = 0;                      for (int j = 0; j < kCyclesBits; j++)                      {                          w = w * w;                          bitCount <<= 1;                          while (w >= ((uint)1 << 16))                          {                              w >>= 1;                              bitCount++;                          }                      }                        probPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_GetPrice,The following statement contains a magic number: do                  {                      price += GET_PRICE(probPrices' probs[symbol >> 8]' (symbol >> 7) & 1);                      symbol <<= 1;                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_GetPrice,The following statement contains a magic number: do                  {                      price += GET_PRICE(probPrices' probs[symbol >> 8]' (symbol >> 7) & 1);                      symbol <<= 1;                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_GetPriceMatched,The following statement contains a magic number: do                  {                      matchByte <<= 1;                      price += GET_PRICE(probPrices' probs[offs + (matchByte & offs) + (symbol >> 8)]' (symbol >> 7) & 1);                      symbol <<= 1;                      offs &= ~(matchByte ^ symbol);                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LitEnc_GetPriceMatched,The following statement contains a magic number: do                  {                      matchByte <<= 1;                      price += GET_PRICE(probPrices' probs[offs + (matchByte & offs) + (symbol >> 8)]' (symbol >> 7) & 1);                      symbol <<= 1;                      offs &= ~(matchByte ^ symbol);                  }                  while (symbol < 0x10000);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LIT_PROBS,The following statement contains a magic number: return P.From(mLitProbs' (((pos & mLpMask) << mLC) + ((uint)prevByte >> (8 - mLC))) * 0x300);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,ChangePair,The following statement contains a magic number: return (bigDist >> 7) > smallDist;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (props.mLC > LZMA_LC_MAX                      || props.mLP > LZMA_LP_MAX                      || props.mPB > LZMA_PB_MAX                      || props.mDictSize > (1u << kDicLogSizeMaxCompress)                      || props.mDictSize > (1u << 30))                      return SZ_ERROR_PARAM;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (fb < 5)                      fb = 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (fb < 5)                      fb = 5;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: uint numHashBytes = 4;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (props.mBtMode != 0)                  {                      if (props.mNumHashBytes < 2)                          numHashBytes = 2;                      else if (props.mNumHashBytes < 4)                          numHashBytes = (uint)props.mNumHashBytes;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (props.mBtMode != 0)                  {                      if (props.mNumHashBytes < 2)                          numHashBytes = 2;                      else if (props.mNumHashBytes < 4)                          numHashBytes = (uint)props.mNumHashBytes;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SetProps,The following statement contains a magic number: if (props.mBtMode != 0)                  {                      if (props.mNumHashBytes < 2)                          numHashBytes = 2;                      else if (props.mNumHashBytes < 4)                          numHashBytes = (uint)props.mNumHashBytes;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: props[0] = (byte)((mPB * 5 + mLP) * 9 + mLC);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: props[0] = (byte)((mPB * 5 + mLP) * 9 + mLC);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 11; i <= 30; i++)                  {                      if (dictSize <= (2u << i))                      {                          dictSize = (2u << i);                          break;                      }                      if (dictSize <= (3u << i))                      {                          dictSize = (3u << i);                          break;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 11; i <= 30; i++)                  {                      if (dictSize <= (2u << i))                      {                          dictSize = (2u << i);                          break;                      }                      if (dictSize <= (3u << i))                      {                          dictSize = (3u << i);                          break;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      props[1 + i] = (byte)(dictSize >> (8 * i));
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      props[1 + i] = (byte)(dictSize >> (8 * i));
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,memcpy,The following statement contains a magic number: if (dst.Length != src.Length || size != src.Length * 2)                      throw new InvalidOperationException();
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,memcpy,The following statement contains a magic number: if (dst.Length != src.Length || size != src.Length * 4)                      throw new InvalidOperationException();
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: for (int i = 0; i < kNumStates; i++)                  {                      memcpy(mSaveState.mIsMatch[i]' mIsMatch[i]' LZMA_NUM_PB_STATES_MAX * 2);                      memcpy(mSaveState.mIsRep0Long[i]' mIsRep0Long[i]' LZMA_NUM_PB_STATES_MAX * 2);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: for (int i = 0; i < kNumStates; i++)                  {                      memcpy(mSaveState.mIsMatch[i]' mIsMatch[i]' LZMA_NUM_PB_STATES_MAX * 2);                      memcpy(mSaveState.mIsRep0Long[i]' mIsRep0Long[i]' LZMA_NUM_PB_STATES_MAX * 2);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: for (int i = 0; i < kNumLenToPosStates; i++)                      memcpy(mSaveState.mPosSlotEncoder[i]' mPosSlotEncoder[i]' (1 << kNumPosSlotBits) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mIsRep' mIsRep' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mIsRepG0' mIsRepG0' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mIsRepG1' mIsRepG1' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mIsRepG2' mIsRepG2' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mPosEncoders' mPosEncoders' (kNumFullDistances - kEndPosModelIndex) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mPosAlignEncoder' mPosAlignEncoder' (1 << kNumAlignBits) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_SaveState,The following statement contains a magic number: memcpy(mSaveState.mLitProbs' mLitProbs' (0x300 << mLcLp) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: for (int i = 0; i < kNumStates; i++)                  {                      memcpy(mIsMatch[i]' mSaveState.mIsMatch[i]' LZMA_NUM_PB_STATES_MAX * 2);                      memcpy(mIsRep0Long[i]' mSaveState.mIsRep0Long[i]' LZMA_NUM_PB_STATES_MAX * 2);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: for (int i = 0; i < kNumStates; i++)                  {                      memcpy(mIsMatch[i]' mSaveState.mIsMatch[i]' LZMA_NUM_PB_STATES_MAX * 2);                      memcpy(mIsRep0Long[i]' mSaveState.mIsRep0Long[i]' LZMA_NUM_PB_STATES_MAX * 2);                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: for (int i = 0; i < kNumLenToPosStates; i++)                      memcpy(mPosSlotEncoder[i]' mSaveState.mPosSlotEncoder[i]' (1 << kNumPosSlotBits) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mIsRep' mSaveState.mIsRep' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mIsRepG0' mSaveState.mIsRepG0' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mIsRepG1' mSaveState.mIsRepG1' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mIsRepG2' mSaveState.mIsRepG2' kNumStates * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mPosEncoders' mSaveState.mPosEncoders' (kNumFullDistances - kEndPosModelIndex) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mPosAlignEncoder' mSaveState.mPosAlignEncoder' (1 << kNumAlignBits) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_RestoreState,The following statement contains a magic number: memcpy(mLitProbs' mSaveState.mLitProbs' (0x300 << mLcLp) * 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: {                      if (mOptimumEndIndex != mOptimumCurrentIndex)                      {                          COptimal opt = mOpt[mOptimumCurrentIndex];                          uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;                          backRes = opt.mBackPrev;                          mOptimumCurrentIndex = opt.mPosPrev;                          return lenRes;                      }                        mOptimumCurrentIndex = 0;                      mOptimumEndIndex = 0;                        uint mainLen' numPairs;                      if (mAdditionalOffset == 0)                      {                          mainLen = ReadMatchDistances(out numPairs);                      }                      else                      {                          mainLen = mLongestMatchLength;                          numPairs = mNumPairs;                      }                        numAvail = mNumAvail;                      if (numAvail < 2)                      {                          backRes = ~0u;                          return 1;                      }                      if (numAvail > LZMA_MATCH_LEN_MAX)                          numAvail = LZMA_MATCH_LEN_MAX;                        P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      OptimumReps repLens = new OptimumReps();                      uint repMaxIndex = 0;                      for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          reps[i] = mReps[i];                          TR("GetOptimum:reps[i]"' reps[i]);                          P<byte> data2 = data - (reps[i] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                          {                              repLens[i] = 0;                              continue;                          }                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            repLens[i] = lenTest;                          if (lenTest > repLens[repMaxIndex])                              repMaxIndex = i;                      }                        if (repLens[repMaxIndex] >= mNumFastBytes)                      {                          uint lenRes;                          backRes = repMaxIndex;                          lenRes = repLens[repMaxIndex];                          MovePos(lenRes - 1);                          return lenRes;                      }                        matches = mMatches;                      if (mainLen >= mNumFastBytes)                      {                          backRes = matches[numPairs - 1] + LZMA_NUM_REPS;                          MovePos(mainLen - 1);                          return mainLen;                      }                        byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)                      {                          backRes = ~0u;                          return 1;                      }                        mOpt[0].mState = mState;                        uint posState = (position & mPbMask);                        {                          P<ushort> probs = LIT_PROBS(position' (data - 1)[0]);                          mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +                              (!IsCharState(mState) ?                                LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices) :                                LitEnc_GetPrice(probs' curByte' mProbPrices));                      }                        mOpt[1].MakeAsChar();                        uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);                        if (matchByte == curByte)                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState' posState);                          if (shortRepPrice < mOpt[1].mPrice)                          {                              mOpt[1].mPrice = shortRepPrice;                              mOpt[1].MakeAsShortRep();                          }                      }                      lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);                        if (lenEnd < 2)                      {                          backRes = mOpt[1].mBackPrev;                          return 1;                      }                        mOpt[1].mPosPrev = 0;                      mOpt[0].mBacks = reps;                        uint len = lenEnd;                      do { mOpt[len--].mPrice = kInfinityPrice; }                      while (len >= 2);                        for (uint i = 0; i < LZMA_NUM_REPS; i++)                      {                          uint repLen = repLens[i];                          if (repLen < 2)                              continue;                          uint price = repMatchPrice + GetPureRepPrice(i' mState' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];                              COptimal opt = mOpt[repLen];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = i;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--repLen >= 2);                      }                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);                        len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);                      if (len <= mainLen)                      {                          uint offs = 0;                          while (len > matches[offs])                              offs += 2;                          for (; ; len++)                          {                              uint distance = matches[offs + 1];                                uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(len);                              if (distance < kNumFullDistances)                              {                                  curAndLenPrice += mDistancesPrices[lenToPosState][distance];                              }                              else                              {                                  uint slot = GetPosSlot2(distance);                                  curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];                              }                                COptimal opt = mOpt[len];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = 0;                                  opt.mBackPrev = distance + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                              if (len == matches[offs])                              {                                  offs += 2;                                  if (offs == numPairs)                                      break;                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimum,The following statement contains a magic number: for (;;)                  {                      cur++;                      if (cur == lenEnd)                          return Backward(out backRes' cur);                        uint numPairs;                      uint newLen = ReadMatchDistances(out numPairs);                      if (newLen >= mNumFastBytes)                      {                          mNumPairs = numPairs;                          mLongestMatchLength = newLen;                          return Backward(out backRes' cur);                      }                      position++;                        uint state;                      COptimal curOpt = mOpt[cur];                      uint posPrev = curOpt.mPosPrev;                      if (curOpt.mPrev1IsChar)                      {                          posPrev--;                          if (curOpt.mPrev2)                          {                              state = mOpt[curOpt.mPosPrev2].mState;                              if (curOpt.mBackPrev2 < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          else                          {                              state = mOpt[posPrev].mState;                          }                          state = kLiteralNextStates[state];                      }                      else                      {                          state = mOpt[posPrev].mState;                      }                      if (posPrev == cur - 1)                      {                          if (curOpt.IsShortRep())                              state = kShortRepNextStates[state];                          else                              state = kLiteralNextStates[state];                      }                      else                      {                          uint pos;                          if (curOpt.mPrev1IsChar && curOpt.mPrev2)                          {                              posPrev = curOpt.mPosPrev2;                              pos = curOpt.mBackPrev2;                              state = kRepNextStates[state];                          }                          else                          {                              pos = curOpt.mBackPrev;                              if (pos < LZMA_NUM_REPS)                                  state = kRepNextStates[state];                              else                                  state = kMatchNextStates[state];                          }                          COptimal prevOpt = mOpt[posPrev];                          if (pos < LZMA_NUM_REPS)                          {                              reps._0 = prevOpt.mBacks[pos];                              uint i = 1;                              for (; i <= pos; i++)                                  reps[i] = prevOpt.mBacks[i - 1];                              for (; i < LZMA_NUM_REPS; i++)                                  reps[i] = prevOpt.mBacks[i];                          }                          else                          {                              reps._0 = pos - LZMA_NUM_REPS;                              reps._1 = prevOpt.mBacks._0;                              reps._2 = prevOpt.mBacks._1;                              reps._3 = prevOpt.mBacks._2;                          }                      }                      curOpt.mState = state;                      curOpt.mBacks = reps;                        uint curPrice = curOpt.mPrice;                      bool nextIsChar = false;                      P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                      byte curByte = data[0];                      byte matchByte = (data - (reps._0 + 1))[0];                        uint posState = (position & mPbMask);                        uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);                      {                          P<ushort> probs = LIT_PROBS(position' data[-1]);                          if (!IsCharState(state))                              curAnd1Price += LitEnc_GetPriceMatched(probs' curByte' matchByte' mProbPrices);                          else                              curAnd1Price += LitEnc_GetPrice(probs' curByte' mProbPrices);                      }                        COptimal nextOpt = mOpt[cur + 1];                        if (curAnd1Price < nextOpt.mPrice)                      {                          nextOpt.mPrice = curAnd1Price;                          nextOpt.mPosPrev = cur;                          nextOpt.MakeAsChar();                          nextIsChar = true;                      }                        uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);                      uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);                        if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))                      {                          uint shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                          if (shortRepPrice <= nextOpt.mPrice)                          {                              nextOpt.mPrice = shortRepPrice;                              nextOpt.mPosPrev = cur;                              nextOpt.MakeAsShortRep();                              nextIsChar = true;                          }                      }                        uint numAvailFull = Math.Min(mNumAvail' kNumOpts - 1 - cur);                      if (numAvailFull < 2)                          continue;                        numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);                        if (!nextIsChar && matchByte != curByte) /* speed optimization */                      {                          /* try Literal + rep0 */                          P<byte> data2 = data - (reps._0 + 1);                          uint limit = mNumFastBytes + 1;                          if (limit > numAvailFull)                              limit = numAvailFull;                            uint temp = 1;                          while (temp < limit && data[temp] == data2[temp])                              temp++;                            uint lenTest2 = temp - 1;                          if (lenTest2 >= 2)                          {                              uint state2 = kLiteralNextStates[state];                              uint posStateNext = (position + 1) & mPbMask;                              uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);                              /* for (; lenTest2 >= 2; lenTest2--) */                              {                                  uint offset = cur + 1 + lenTest2;                                  while (lenEnd < offset)                                      mOpt[++lenEnd].mPrice = kInfinityPrice;                                  uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  COptimal opt = mOpt[offset];                                  if (curAndLenPrice < opt.mPrice)                                  {                                      opt.mPrice = curAndLenPrice;                                      opt.mPosPrev = cur + 1;                                      opt.mBackPrev = 0;                                      opt.mPrev1IsChar = true;                                      opt.mPrev2 = false;                                  }                              }                          }                      }                        uint startLen = 2; /* speed optimization */                        for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)                      {                          P<byte> data2 = data - (reps[repIndex] + 1);                          if (data[0] != data2[0] || data[1] != data2[1])                              continue;                            uint lenTest = 2;                          while (lenTest < numAvail && data[lenTest] == data2[lenTest])                              lenTest++;                            while (lenEnd < cur + lenTest)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint lenTestTemp = lenTest;                          uint price = repMatchPrice + GetPureRepPrice(repIndex' state' posState);                          do                          {                              uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];                              COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = repIndex;                                  opt.mPrev1IsChar = false;                              }                          }                          while (--lenTest >= 2);                          lenTest = lenTestTemp;                            if (repIndex == 0)                              startLen = lenTest + 1;                            {                              uint lenTest2 = lenTest + 1;                                uint limit = lenTest2 + mNumFastBytes;                              if (limit > numAvailFull)                                  limit = numAvailFull;                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                  lenTest2++;                                lenTest2 -= lenTest + 1;                              if (lenTest2 >= 2)                              {                                  uint state2 = kRepNextStates[state];                                  uint posStateNext = (position + lenTest) & mPbMask;                                  uint curAndLenCharPrice = price                                      + mRepLenEnc.mPrices[posState][lenTest - 2]                                      + GET_PRICE_0(mIsMatch[state2][posStateNext])                                      + LitEnc_GetPriceMatched(                                          LIT_PROBS(position + lenTest' data[lenTest - 1])'                                          data[lenTest]' data2[lenTest]' mProbPrices);                                    state2 = kLiteralNextStates[state2];                                  posStateNext = (position + lenTest + 1) & mPbMask;                                  uint nextRepMatchPrice = curAndLenCharPrice                                      + GET_PRICE_1(mIsMatch[state2][posStateNext])                                      + GET_PRICE_1(mIsRep[state2]);                                    /* for (; lenTest2 >= 2; lenTest2--) */                                  {                                      uint offset = cur + lenTest + 1 + lenTest2;                                      while (lenEnd < offset)                                          mOpt[++lenEnd].mPrice = kInfinityPrice;                                        uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                        COptimal opt = mOpt[offset];                                      if (curAndLenPrice < opt.mPrice)                                      {                                          opt.mPrice = curAndLenPrice;                                          opt.mPosPrev = cur + lenTest + 1;                                          opt.mBackPrev = 0;                                          opt.mPrev1IsChar = true;                                          opt.mPrev2 = true;                                          opt.mPosPrev2 = cur;                                          opt.mBackPrev2 = repIndex;                                      }                                  }                              }                          }                      }                        /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */                      if (newLen > numAvail)                      {                          newLen = numAvail;                          numPairs = 0;                          while (newLen > matches[numPairs])                              numPairs += 2;                          matches[numPairs] = newLen;                          numPairs += 2;                      }                      if (newLen >= startLen)                      {                          uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);                            while (lenEnd < cur + newLen)                              mOpt[++lenEnd].mPrice = kInfinityPrice;                            uint offs = 0;                          while (startLen > matches[offs])                              offs += 2;                            uint curBack = matches[offs + 1];                          uint posSlot = GetPosSlot2(curBack);                          for (uint lenTest = /*2*/ startLen; ; lenTest++)                          {                              uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];                              uint lenToPosState = GetLenToPosState(lenTest);                              if (curBack < kNumFullDistances)                                  curAndLenPrice += mDistancesPrices[lenToPosState][curBack];                              else                                  curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];                                COptimal opt = mOpt[cur + lenTest];                              if (curAndLenPrice < opt.mPrice)                              {                                  opt.mPrice = curAndLenPrice;                                  opt.mPosPrev = cur;                                  opt.mBackPrev = curBack + LZMA_NUM_REPS;                                  opt.mPrev1IsChar = false;                              }                                if (lenTest == matches[offs])                              {                                  /* Try Match + Literal + Rep0 */                                  P<byte> data2 = data - (curBack + 1);                                  uint lenTest2 = lenTest + 1;                                  uint limit = lenTest2 + mNumFastBytes;                                  uint nextRepMatchPrice;                                  if (limit > numAvailFull)                                      limit = numAvailFull;                                    while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])                                      lenTest2++;                                    lenTest2 -= lenTest + 1;                                  if (lenTest2 >= 2)                                  {                                      uint state2 = kMatchNextStates[state];                                      uint posStateNext = (position + lenTest) & mPbMask;                                      uint curAndLenCharPrice = curAndLenPrice                                          + GET_PRICE_0(mIsMatch[state2][posStateNext])                                          + LitEnc_GetPriceMatched(                                              LIT_PROBS(position + lenTest' data[lenTest - 1])'                                              data[lenTest]' data2[lenTest]' mProbPrices);                                        state2 = kLiteralNextStates[state2];                                      posStateNext = (posStateNext + 1) & mPbMask;                                      nextRepMatchPrice = curAndLenCharPrice                                          + GET_PRICE_1(mIsMatch[state2][posStateNext])                                          + GET_PRICE_1(mIsRep[state2]);                                        /* for (; lenTest2 >= 2; lenTest2--) */                                      {                                          uint offset = cur + lenTest + 1 + lenTest2;                                          uint curAndLenPrice4;                                          while (lenEnd < offset)                                              mOpt[++lenEnd].mPrice = kInfinityPrice;                                          curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                          COptimal opt4 = mOpt[offset];                                          if (curAndLenPrice4 < opt4.mPrice)                                          {                                              opt4.mPrice = curAndLenPrice4;                                              opt4.mPosPrev = cur + lenTest + 1;                                              opt4.mBackPrev = 0;                                              opt4.mPrev1IsChar = true;                                              opt4.mPrev2 = true;                                              opt4.mPosPrev2 = cur;                                              opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;                                          }                                      }                                  }                                    offs += 2;                                  if (offs == numPairs)                                      break;                                    curBack = matches[offs + 1];                                  if (curBack >= kNumFullDistances)                                      posSlot = GetPosSlot2(curBack);                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (numAvail < 2)                      return 1;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: for (uint i = 0; i < LZMA_NUM_REPS; i++)                  {                      P<byte> data2 = data - (mReps[i] + 1);                      TR("GetOptimumFast:reps[i]:a"' mReps[i]);                      if (data[0] != data2[0] || data[1] != data2[1])                          continue;                        uint len = 2;                      while (len < numAvail && data[len] == data2[len])                          len++;                        if (len >= mNumFastBytes)                      {                          backRes = i;                          MovePos(len - 1);                          return len;                      }                        if (len > repLen)                      {                          repIndex = i;                          repLen = len;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen >= 2)                  {                      mainDist = matches[numPairs - 1];                      while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)                      {                          if (!ChangePair(matches[numPairs - 3]' mainDist))                              break;                            numPairs -= 2;                          mainLen = matches[numPairs - 2];                          mainDist = matches[numPairs - 1];                      }                        if (mainLen == 2 && mainDist >= 0x80)                          mainLen = 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15))))                  {                      backRes = repIndex;                      MovePos(repLen - 1);                      return repLen;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15))))                  {                      backRes = repIndex;                      MovePos(repLen - 1);                      return repLen;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15))))                  {                      backRes = repIndex;                      MovePos(repLen - 1);                      return repLen;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15))))                  {                      backRes = repIndex;                      MovePos(repLen - 1);                      return repLen;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (repLen >= 2 && (                      (repLen + 1 >= mainLen) ||                      (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||                      (repLen + 3 >= mainLen && mainDist >= (1 << 15))))                  {                      backRes = repIndex;                      MovePos(repLen - 1);                      return repLen;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen < 2 || numAvail <= 2)                      return 1;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mainLen < 2 || numAvail <= 2)                      return 1;
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mLongestMatchLength >= 2)                  {                      uint newDistance = matches[mNumPairs - 1];                      if ((mLongestMatchLength >= mainLen && newDistance < mainDist) ||                          (mLongestMatchLength == mainLen + 1 && !ChangePair(mainDist' newDistance)) ||                          (mLongestMatchLength > mainLen + 1) ||                          (mLongestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance' mainDist)))                          return 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: if (mLongestMatchLength >= 2)                  {                      uint newDistance = matches[mNumPairs - 1];                      if ((mLongestMatchLength >= mainLen && newDistance < mainDist) ||                          (mLongestMatchLength == mainLen + 1 && !ChangePair(mainDist' newDistance)) ||                          (mLongestMatchLength > mainLen + 1) ||                          (mLongestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance' mainDist)))                          return 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: for (uint i = 0; i < LZMA_NUM_REPS; i++)                  {                      TR("GetOptimumFast:reps[i]:b"' mReps[i]);                      P<byte> data2 = data - (mReps[i] + 1);                      if (data[0] != data2[0] || data[1] != data2[1])                          continue;                        uint limit = mainLen - 1;                        uint len = 2;                      while (len < limit && data[len] == data2[len])                          len++;                        if (len >= limit)                          return 1;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetOptimumFast,The following statement contains a magic number: MovePos(mainLen - 2);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,WriteEndMarker,The following statement contains a magic number: mRC.RangeEnc_EncodeDirectBits(((1u << 30) - 1) >> kNumAlignBits' 30 - kNumAlignBits);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,WriteEndMarker,The following statement contains a magic number: mRC.RangeEnc_EncodeDirectBits(((1u << 30) - 1) >> kNumAlignBits' 30 - kNumAlignBits);
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_CodeOneBlock,The following statement contains a magic number: if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)                  {                      for (;;)                      {                          uint len' pos;                          if (mFastMode)                              len = GetOptimumFast(out pos);                          else                              len = GetOptimum(nowPos32' out pos);                            TR("CodeOneBlock:nowPos32"' nowPos32);                          TR("CodeOneBlock:len"' len);                          TR("CodeOneBlock:pos"' pos);    #if SHOW_STAT2                          Print("\n pos = {0:X4}'   len = {1}   pos = {2}"' nowPos32' len' pos);  #endif                            uint posState = nowPos32 & mPbMask;                          if (len == 1 && pos == ~0u)                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 0);                              P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;                              byte curByte = data[0];                              P<ushort> probs = LIT_PROBS(nowPos32' (data - 1)[0]);                                if (IsCharState(mState))                                  LitEnc_Encode(mRC' probs' curByte);                              else                                  LitEnc_EncodeMatched(mRC' probs' curByte' (data - mReps._0 - 1)[0]);                                mState = kLiteralNextStates[mState];                          }                          else                          {                              mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState]' 1);                              if (pos < LZMA_NUM_REPS)                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 1);                                  if (pos == 0)                                  {                                      mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 0);                                      mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState]' (len == 1) ? 0u : 1u);                                  }                                  else                                  {                                      uint distance = mReps[pos];                                      TR("CodeOneBlock:push-rep-0"' pos);                                      TR("CodeOneBlock:push-rep-1"' distance);                                        mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState]' 1);                                        if (pos == 1)                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 0);                                      }                                      else                                      {                                          mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState]' 1);                                          mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState]' pos - 2);                                          if (pos == 3)                                              mReps._3 = mReps._2;                                          mReps._2 = mReps._1;                                      }                                        mReps._1 = mReps._0;                                      mReps._0 = distance;                                  }                                    if (len == 1)                                  {                                      mState = kShortRepNextStates[mState];                                  }                                  else                                  {                                      mRepLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                      mState = kRepNextStates[mState];                                  }                              }                              else                              {                                  mRC.RangeEnc_EncodeBit(ref mIsRep[mState]' 0);                                  mState = kMatchNextStates[mState];                                  mLenEnc.LenEnc_Encode2(mRC' len - LZMA_MATCH_LEN_MIN' posState' !mFastMode' mProbPrices);                                  pos -= LZMA_NUM_REPS;                                  uint posSlot = GetPosSlot(pos);                                  RcTree_Encode(mRC' mPosSlotEncoder[GetLenToPosState(len)]' kNumPosSlotBits' posSlot);                                    if (posSlot >= kStartPosModelIndex)                                  {                                      int footerBits = (int)((posSlot >> 1) - 1);                                      uint @base = ((2 | (posSlot & 1)) << footerBits);                                      uint posReduced = pos - @base;                                        if (posSlot < kEndPosModelIndex)                                          RcTree_ReverseEncode(mRC' P.From(mPosEncoders' @base - posSlot - 1)' footerBits' posReduced);                                      else                                      {                                          mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits' (footerBits - kNumAlignBits));                                          RcTree_ReverseEncode(mRC' mPosAlignEncoder' kNumAlignBits' posReduced & kAlignMask);                                          mAlignPriceCount++;                                      }                                  }                                  TR("CodeOneBlock:push-rep-2"' pos);                                  mReps._3 = mReps._2;                                  mReps._2 = mReps._1;                                  mReps._1 = mReps._0;                                  mReps._0 = pos;                                  mMatchPriceCount++;                              }                          }                            mAdditionalOffset -= len;                          nowPos32 += len;                            if (mAdditionalOffset == 0)                          {                              if (!mFastMode)                              {                                  if (mMatchPriceCount >= (1 << 7))                                      FillDistancesPrices();                                  if (mAlignPriceCount >= kAlignTableSize)                                      FillAlignPrices();                              }                                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)                                  break;                                uint processed = nowPos32 - startPos32;                              if (useLimits)                              {                                  if (processed + kNumOpts + 300 >= maxUnpackSize                                      || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)                                      break;                              }                              else if (processed >= (1 << 15))                              {                                  mNowPos64 += nowPos32 - startPos32;                                  TRS("CodeOneBlock"' "chunk");                                  TR("CodeOneBlock:start"' startPos32);                                  TR("CodeOneBlock:now"' nowPos32);                                  return CheckErrors();                              }                          }                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,LzmaEnc_AllocAndInit,The following statement contains a magic number: {                      uint i;                      for (i = 0; i < (uint)kDicLogSizeMaxCompress; i++)                          if (mDictSize <= (1u << (int)i))                              break;                        mDistTableSize = i * 2;                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,ReadMatchDistances,The following statement contains a magic number: if (numPairs > 0)                  {                      lenRes = mMatches[numPairs - 2];                      if (lenRes == mNumFastBytes)                      {                          P<byte> pby = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;                          uint distance = mMatches[numPairs - 1] + 1;                            uint numAvail = mNumAvail;                          if (numAvail > LZMA_MATCH_LEN_MAX)                              numAvail = LZMA_MATCH_LEN_MAX;                            P<byte> pby2 = pby - distance;                          while (lenRes < numAvail && pby[lenRes] == pby2[lenRes])                              lenRes++;                      }                  }
Magic Number,ManagedLzma.LZMA.Master,CLzmaEnc,C:\repos\weltkante_managed-lzma\shared\Compression\Implementation\LzmaEnc.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)                  {                      price = GET_PRICE_0(mIsRepG0[state]);                      price += GET_PRICE_1(mIsRep0Long[state][posState]);                  }                  else                  {                      price = GET_PRICE_1(mIsRepG0[state]);                      if (repIndex == 1)                      {                          price += GET_PRICE_0(mIsRepG1[state]);                      }                      else                      {                          price += GET_PRICE_1(mIsRepG1[state]);                          price += GET_PRICE(mIsRepG2[state]' repIndex - 2);                      }                  }
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: byte lc = (byte)(bt % 9);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: bt /= 9;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: byte pb = (byte)(bt / 5);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: byte lp = (byte)(bt % 5);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 2] << 8;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 2] << 8;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 3] << 16;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 3] << 16;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 4] << 24;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,ReadFrom,The following statement contains a magic number: dictSize |= (uint)data[offset + 4] << 24;
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,DecoderSettings,The following statement contains a magic number: if ((mLC = lc) > 8)                  throw new ArgumentOutOfRangeException(nameof(lc));
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,DecoderSettings,The following statement contains a magic number: if ((mPB = pb) > 4)                  throw new ArgumentOutOfRangeException(nameof(pb));
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,DecoderSettings,The following statement contains a magic number: if ((mLP = lp) > 4)                  throw new ArgumentOutOfRangeException(nameof(lp));
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset] = (byte)((mPB * 5 + mLP) * 9 + mLC);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset] = (byte)((mPB * 5 + mLP) * 9 + mLC);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 2] = (byte)(mDictSize >> 8);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 2] = (byte)(mDictSize >> 8);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 3] = (byte)(mDictSize >> 16);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 3] = (byte)(mDictSize >> 16);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 4] = (byte)(mDictSize >> 24);
Magic Number,ManagedLzma.LZMA,DecoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\DecoderSettings.cs,WriteTo,The following statement contains a magic number: buffer[offset + 4] = (byte)(mDictSize >> 24);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,EncoderSettings,The following statement contains a magic number: SetLevel(5);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level < 0 || level > 9)                  throw new ArgumentOutOfRangeException(nameof(level));
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 5)                  mDictionarySize = (1 << (level * 2 + 14));              else if (level == 6)                  mDictionarySize = (1 << 25);              else                  mDictionarySize = (1 << 26);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mLC = 3;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mPB = 2;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mFastMode = (level <= 4);
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mFB = (level <= 6) ? 32 : 64;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mFB = (level <= 6) ? 32 : 64;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mFB = (level <= 6) ? 32 : 64;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: mHashBytes = 4;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 4)                  mMC = 16;              else if (level <= 6)                  mMC = 32;              else                  mMC = 48;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 4)                  mMC = 16;              else if (level <= 6)                  mMC = 32;              else                  mMC = 48;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 4)                  mMC = 16;              else if (level <= 6)                  mMC = 32;              else                  mMC = 48;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 4)                  mMC = 16;              else if (level <= 6)                  mMC = 32;              else                  mMC = 48;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,SetLevel,The following statement contains a magic number: if (level <= 4)                  mMC = 16;              else if (level <= 6)                  mMC = 32;              else                  mMC = 48;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,GetInternalSettings,The following statement contains a magic number: settings.mNumThreads = mMultiThreaded ? 2 : 1;
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: props.Add((byte)((settings.mPB * 5 + settings.mLP) * 9 + settings.mLC));
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: props.Add((byte)((settings.mPB * 5 + settings.mLP) * 9 + settings.mLC));
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 11; i <= 30; i++)              {                  if (dictSize <= (2u << i))                  {                      dictSize = (2u << i);                      break;                  }                  if (dictSize <= (3u << i))                  {                      dictSize = (3u << i);                      break;                  }              }
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 11; i <= 30; i++)              {                  if (dictSize <= (2u << i))                  {                      dictSize = (2u << i);                      break;                  }                  if (dictSize <= (3u << i))                  {                      dictSize = (3u << i);                      break;                  }              }
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  props.Add((byte)(dictSize >> (8 * i)));
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,LzmaEnc_WriteProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  props.Add((byte)(dictSize >> (8 * i)));
Magic Number,ManagedLzma.LZMA,EncoderSettings,C:\repos\weltkante_managed-lzma\shared\Compression\Lzma\EncoderSettings.cs,GetSerializedSettings,The following statement contains a magic number: var props = ImmutableArray.CreateBuilder<byte>(5);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: for (int i = 0; i < 6; i++)                  if (header[i] != ArchiveMetadataFormat.kFileSignature[i])                      return new InvalidDataException("File is not a 7z archive.");
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: mMajorVersion = header[6];
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: mMinorVersion = header[7];
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: mMetadataOffset = GetInt64(header' 12);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: mMetadataLength = GetInt64(header' 20);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: mMetadataChecksum = new Checksum(GetInt32(header' 28));
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadFileHeader,The following statement contains a magic number: if ((int)crc != GetInt32(header' 8))                  return new InvalidDataException("Invalid header checksum.");
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt32,The following statement contains a magic number: return (int)buffer[offset]                  | ((int)buffer[offset + 1] << 8)                  | ((int)buffer[offset + 2] << 16)                  | ((int)buffer[offset + 3] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt32,The following statement contains a magic number: return (int)buffer[offset]                  | ((int)buffer[offset + 1] << 8)                  | ((int)buffer[offset + 2] << 16)                  | ((int)buffer[offset + 3] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt32,The following statement contains a magic number: return (int)buffer[offset]                  | ((int)buffer[offset + 1] << 8)                  | ((int)buffer[offset + 2] << 16)                  | ((int)buffer[offset + 3] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt32,The following statement contains a magic number: return (int)buffer[offset]                  | ((int)buffer[offset + 1] << 8)                  | ((int)buffer[offset + 2] << 16)                  | ((int)buffer[offset + 3] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt32,The following statement contains a magic number: return (int)buffer[offset]                  | ((int)buffer[offset + 1] << 8)                  | ((int)buffer[offset + 2] << 16)                  | ((int)buffer[offset + 3] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,GetInt64,The following statement contains a magic number: return (long)buffer[offset]                  | ((long)buffer[offset + 1] << 8)                  | ((long)buffer[offset + 2] << 16)                  | ((long)buffer[offset + 3] << 24)                  | ((long)buffer[offset + 4] << 32)                  | ((long)buffer[offset + 5] << 40)                  | ((long)buffer[offset + 6] << 48)                  | ((long)buffer[offset + 7] << 56);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadArchive,The following statement contains a magic number: if (token != ArchiveMetadataToken.End)              {                  if (token != ArchiveMetadataToken.Files)                      throw new InvalidDataException();                    var fileCount = ReadNumberAsInt32();                  Initialize(fileCount);                    for (;;)                  {                      token = ReadToken();                      if (token == ArchiveMetadataToken.End)                          break;                        var recordSize = (long)ReadNumber();                      if (recordSize < 0)                          throw new InvalidDataException();                        var oldOffset = GetCurrentOffset();                        #region File Metadata                        switch (token)                      {                          case ArchiveMetadataToken.Name:                              using (SelectStream(streams))                              {                                  var reader = new MetadataStringReader(this' fileCount);                                  ReadNames(reader);                                  reader.Complete();                              }                              break;                            case ArchiveMetadataToken.WinAttributes:                              {                                  var vector = ReadOptionalBitVector(fileCount);                                  using (SelectStream(streams))                                  {                                      var reader = new MetadataAttributeReader(this' fileCount' vector' EnablePosixFileAttributeExtension);                                      ReadAttributes(reader);                                      reader.Complete();                                  }                                    break;                              }                            case ArchiveMetadataToken.EmptyStream:                              {                                  var emptyStreams = ReadRequiredBitVector(fileCount);                                  emptyStreamCount = emptyStreams.CountSetBits();                                    var reader = new MetadataBitReader(this' emptyStreams);                                  ReadEmptyStreamMarkers(reader);                                  reader.Complete();                                  break;                              }                            case ArchiveMetadataToken.EmptyFile:                              {                                  if (emptyStreamCount == null)                                      throw new InvalidDataException();                                    var reader = new MetadataBitReader(this' ReadRequiredBitVector(emptyStreamCount.Value));                                  ReadEmptyFileMarkers(reader);                                  reader.Complete();                                  break;                              }                            case ArchiveMetadataToken.Anti:                              {                                  if (emptyStreamCount == null)                                      throw new InvalidDataException();                                    var reader = new MetadataBitReader(this' ReadRequiredBitVector(emptyStreamCount.Value));                                  ReadRemovedFileMarkers(reader);                                  reader.Complete();                                  break;                              }                            case ArchiveMetadataToken.StartPos:                              {                                  var vector = ReadOptionalBitVector(fileCount);                                  using (SelectStream(streams))                                  {                                      var reader = new MetadataNumberReader(this' fileCount' vector);                                      ReadOffsets(reader);                                      reader.Complete();                                  }                                    break;                              }                            case ArchiveMetadataToken.CTime:                              {                                  var vector = ReadOptionalBitVector(fileCount);                                  using (SelectStream(streams))                                  {                                      var reader = new MetadataDateReader(this' fileCount' vector);                                      ReadCTime(reader);                                      reader.Complete();                                  }                                    break;                              }                            case ArchiveMetadataToken.ATime:                              {                                  var vector = ReadOptionalBitVector(fileCount);                                  using (SelectStream(streams))                                  {                                      var reader = new MetadataDateReader(this' fileCount' vector);                                      ReadATime(reader);                                      reader.Complete();                                  }                                    break;                              }                            case ArchiveMetadataToken.MTime:                              {                                  var vector = ReadOptionalBitVector(fileCount);                                  using (SelectStream(streams))                                  {                                      var reader = new MetadataDateReader(this' fileCount' vector);                                      ReadMTime(reader);                                      reader.Complete();                                  }                                    break;                              }                            case ArchiveMetadataToken.Padding:                              // TODO: what does the reference implementation do here? just skip it? then we shouldn't throw an exception!                              for (int i = 0; i < recordSize; i++)                                  if (ReadByte() != 0)                                      throw new InvalidDataException();                                break;                            default:                              // TODO: skip data                              break;                      }                        #endregion                        // Up until version 0.3 there was a bug which could emit invalid record sizes' but it didn't really matter.                      // Starting from version 0.3 there have been extensions to the file format which require correct record sizes.                      if (!(mMajorVersion == 0 && mMinorVersion < 3))                      {                          var newOffset = GetCurrentOffset();                          if (newOffset - oldOffset != recordSize)                              throw new InvalidDataException();                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadDecoder,The following statement contains a magic number: if (idLen > 4)                  throw new InvalidDataException();
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadDecoder,The following statement contains a magic number: for (int i = idLen - 1; i >= 0; i--)                  id |= ReadByte() << (i * 8);
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadRequiredBitVector,The following statement contains a magic number: var buffer = new byte[(count + 7) >> 3];
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadRequiredBitVector,The following statement contains a magic number: var buffer = new byte[(count + 7) >> 3];
Magic Number,ManagedLzma.SevenZip.Reader,ArchiveMetadataReader,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadToken,The following statement contains a magic number: if (token > 25)                  return ArchiveMetadataToken.Unknown;              else                  return (ArchiveMetadataToken)token;
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,PrefetchBuffer,The following statement contains a magic number: var buffer = (size <= mBuffer.Length) ? mBuffer : new byte[Math.Max(mBuffer.Length * 2' size)];
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadUInt32,The following statement contains a magic number: EnsureBuffer(4);
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadUInt32,The following statement contains a magic number: mBufferOffset += 4;
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadUInt64,The following statement contains a magic number: EnsureBuffer(8);
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadUInt64,The following statement contains a magic number: mBufferOffset += 8;
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      if ((firstByte & mask) == 0)                      {                          ulong highPart = firstByte & (mask - 1u);                          value += highPart << (i * 8);                          return value;                      }                        EnsureBuffer(1);                      value |= (ulong)ReadByte() << (8 * i);                      mask >>= 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      if ((firstByte & mask) == 0)                      {                          ulong highPart = firstByte & (mask - 1u);                          value += highPart << (i * 8);                          return value;                      }                        EnsureBuffer(1);                      value |= (ulong)ReadByte() << (8 * i);                      mask >>= 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      if ((firstByte & mask) == 0)                      {                          ulong highPart = firstByte & (mask - 1u);                          value += highPart << (i * 8);                          return value;                      }                        EnsureBuffer(1);                      value |= (ulong)ReadByte() << (8 * i);                      mask >>= 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadString,The following statement contains a magic number: for (;;)                  {                      EnsureBuffer(length + 2);                      if (mBuffer[mBufferOffset + length] == 0 && mBuffer[mBufferOffset + length + 1] == 0)                          break;                        length += 2;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadString,The following statement contains a magic number: for (;;)                  {                      EnsureBuffer(length + 2);                      if (mBuffer[mBufferOffset + length] == 0 && mBuffer[mBufferOffset + length + 1] == 0)                          break;                        length += 2;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StreamScope,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadataReader.cs,ReadString,The following statement contains a magic number: mBufferOffset += length + 2;
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Initialize,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Initialize,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Initialize,The following statement contains a magic number: if (((uint)input.Length & 15) != 0)                  throw new NotSupportedException("7z requires AES streams to be properly padded.");
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,DecodeInto,The following statement contains a magic number: if (mEnding - mOffset < 16)              {                  Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                  mEnding -= mOffset;                  mOffset = 0;                    do                  {                      int read = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                      if (read == 0)                      {                          // We are not done decoding and have less than 16 bytes.                          throw new EndOfStreamException();                      }                        mEnding += read;                  }                  while (mEnding - mOffset < 16);              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,DecodeInto,The following statement contains a magic number: if (mEnding - mOffset < 16)              {                  Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                  mEnding -= mOffset;                  mOffset = 0;                    do                  {                      int read = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                      if (read == 0)                      {                          // We are not done decoding and have less than 16 bytes.                          throw new EndOfStreamException();                      }                        mEnding += read;                  }                  while (mEnding - mOffset < 16);              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,DecodeInto,The following statement contains a magic number: if (count < 16)                  return HandleUnderflow(buffer' offset' count);
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,DecodeInto,The following statement contains a magic number: int processed = mDecoder.TransformBlock(mBuffer' mOffset' count & ~15' buffer' offset);
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: int saltSize = (bt >> 7) & 1;
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: int ivSize = (bt >> 6) & 1;
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: saltSize += (bt2 >> 4);
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: ivSize += (bt2 & 15);
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: if (info.Length < 2 + saltSize + ivSize)                  throw new InvalidDataException();
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < saltSize; i++)                  salt[i] = info[i + 2];
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: iv = new byte[16];
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < ivSize; i++)                  iv[i] = info[i + saltSize + 2];
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,Init,The following statement contains a magic number: if (numCyclesPower > 24)                  throw new NotSupportedException();
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {  #if BUILD_PORTABLE                  var stream = new KeyDataStream();                    var task = Task.Run(delegate {                      using (var sha = System.Security.Cryptography.SHA256.Create())                          return sha.ComputeHash(stream);                  });                    byte[] counter = new byte[8];                  long numRounds = 1L << mNumCyclesPower;                  for (long round = 0; round < numRounds; round++)                  {                      stream.ProvideData(salt' 0' salt.Length);                      stream.ProvideData(pass' 0' pass.Length);                      stream.ProvideData(counter' 0' 8);                        // This mirrors the counter so we don't have to convert long to byte[] each round.                      // (It also ensures the counter is little endian' which BitConverter does not.)                      for (int i = 0; i < 8; i++)                          if (++counter[i] != 0)                              break;                  }                    stream.Complete();                  return task.GetAwaiter().GetResult();  #else                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }  #endif              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {  #if BUILD_PORTABLE                  var stream = new KeyDataStream();                    var task = Task.Run(delegate {                      using (var sha = System.Security.Cryptography.SHA256.Create())                          return sha.ComputeHash(stream);                  });                    byte[] counter = new byte[8];                  long numRounds = 1L << mNumCyclesPower;                  for (long round = 0; round < numRounds; round++)                  {                      stream.ProvideData(salt' 0' salt.Length);                      stream.ProvideData(pass' 0' pass.Length);                      stream.ProvideData(counter' 0' 8);                        // This mirrors the counter so we don't have to convert long to byte[] each round.                      // (It also ensures the counter is little endian' which BitConverter does not.)                      for (int i = 0; i < 8; i++)                          if (++counter[i] != 0)                              break;                  }                    stream.Complete();                  return task.GetAwaiter().GetResult();  #else                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }  #endif              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {  #if BUILD_PORTABLE                  var stream = new KeyDataStream();                    var task = Task.Run(delegate {                      using (var sha = System.Security.Cryptography.SHA256.Create())                          return sha.ComputeHash(stream);                  });                    byte[] counter = new byte[8];                  long numRounds = 1L << mNumCyclesPower;                  for (long round = 0; round < numRounds; round++)                  {                      stream.ProvideData(salt' 0' salt.Length);                      stream.ProvideData(pass' 0' pass.Length);                      stream.ProvideData(counter' 0' 8);                        // This mirrors the counter so we don't have to convert long to byte[] each round.                      // (It also ensures the counter is little endian' which BitConverter does not.)                      for (int i = 0; i < 8; i++)                          if (++counter[i] != 0)                              break;                  }                    stream.Complete();                  return task.GetAwaiter().GetResult();  #else                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }  #endif              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {  #if BUILD_PORTABLE                  var stream = new KeyDataStream();                    var task = Task.Run(delegate {                      using (var sha = System.Security.Cryptography.SHA256.Create())                          return sha.ComputeHash(stream);                  });                    byte[] counter = new byte[8];                  long numRounds = 1L << mNumCyclesPower;                  for (long round = 0; round < numRounds; round++)                  {                      stream.ProvideData(salt' 0' salt.Length);                      stream.ProvideData(pass' 0' pass.Length);                      stream.ProvideData(counter' 0' 8);                        // This mirrors the counter so we don't have to convert long to byte[] each round.                      // (It also ensures the counter is little endian' which BitConverter does not.)                      for (int i = 0; i < 8; i++)                          if (++counter[i] != 0)                              break;                  }                    stream.Complete();                  return task.GetAwaiter().GetResult();  #else                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }  #endif              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {  #if BUILD_PORTABLE                  var stream = new KeyDataStream();                    var task = Task.Run(delegate {                      using (var sha = System.Security.Cryptography.SHA256.Create())                          return sha.ComputeHash(stream);                  });                    byte[] counter = new byte[8];                  long numRounds = 1L << mNumCyclesPower;                  for (long round = 0; round < numRounds; round++)                  {                      stream.ProvideData(salt' 0' salt.Length);                      stream.ProvideData(pass' 0' pass.Length);                      stream.ProvideData(counter' 0' 8);                        // This mirrors the counter so we don't have to convert long to byte[] each round.                      // (It also ensures the counter is little endian' which BitConverter does not.)                      for (int i = 0; i < 8; i++)                          if (++counter[i] != 0)                              break;                  }                    stream.Complete();                  return task.GetAwaiter().GetResult();  #else                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }  #endif              }
Magic Number,ManagedLzma.SevenZip.Reader,AesArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\AesDecoder.cs,HandleUnderflow,The following statement contains a magic number: if (mUnderflow == 0)              {                  int blockSize = (mEnding - mOffset) & ~15;                  mUnderflow = mDecoder.TransformBlock(mBuffer' mOffset' blockSize' mBuffer' mOffset);              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,SetInputStream,The following statement contains a magic number: switch (index)              {                  case 0: mMainStream = stream; break;                  case 1: mCallStream = stream; break;                  case 2: mJumpStream = stream; break;                  case 3: mRangeDecoder = new RangeDecoder(stream); break;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,SetInputStream,The following statement contains a magic number: switch (index)              {                  case 0: mMainStream = stream; break;                  case 1: mCallStream = stream; break;                  case 2: mJumpStream = stream; break;                  case 3: mRangeDecoder = new RangeDecoder(stream); break;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Read,The following statement contains a magic number: if (mStatusDecoder == null)              {                  mStatusDecoder = new StatusDecoder[256 + 2];                  for (int i = 0; i < mStatusDecoder.Length; i++)                      mStatusDecoder[i] = new StatusDecoder();                    mIter = Run().GetEnumerator();              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Read,The following statement contains a magic number: if (mStatusDecoder == null)              {                  mStatusDecoder = new StatusDecoder[256 + 2];                  for (int i = 0; i < mStatusDecoder.Length; i++)                      mStatusDecoder[i] = new StatusDecoder();                    mIter = Run().GetEnumerator();              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,GetIndex,The following statement contains a magic number: if (b1 == 0xE8)                  return b0;              else if (b1 == 0xE9)                  return 256;              else                  return 257;
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,GetIndex,The following statement contains a magic number: if (b1 == 0xE8)                  return b0;              else if (b1 == 0xE9)                  return 256;              else                  return 257;
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: const uint kBurstSize = (1u << 18);
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,Bcj2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      if (mMainStream.Read(tempBuffer' 0' 1) == 0)                          yield break;                        b = tempBuffer[0];                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      var s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          if (s.Read(tempBuffer' 0' 1) == 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= tempBuffer[0];                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,RangeDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,RangeDecoder,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | ReadByte();
Magic Number,ManagedLzma.SevenZip.Reader,RangeDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,RangeDecoder,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | ReadByte();
Magic Number,ManagedLzma.SevenZip.Reader,StatusDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,StatusDecoder,The following statement contains a magic number: Prob = kBitModelTotal / 2;
Magic Number,ManagedLzma.SevenZip.Reader,StatusDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StatusDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StatusDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,StatusDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Bcj2Decoder.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,BcjArchiveDecoder,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,BcjArchiveDecoder,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,DecodeInto,The following statement contains a magic number: while (mEnding - mOffset < 5)              {                  if (mInputEnd)                  {                      // if less than 5 bytes are left they are copied                      int n = 0;                      while (mOffset < mEnding && count > 0)                      {                          buffer[offset++] = mBuffer[mOffset++];                          count--;                          n++;                      }                      return n;                  }                    if (mBuffer.Length - mOffset < 5)                  {                      Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                      mEnding -= mOffset;                      mOffset = 0;                  }                    int delta = mInput.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                  if (delta == 0)                      mInputEnd = true;                  else                      mEnding += delta;              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,DecodeInto,The following statement contains a magic number: while (mEnding - mOffset < 5)              {                  if (mInputEnd)                  {                      // if less than 5 bytes are left they are copied                      int n = 0;                      while (mOffset < mEnding && count > 0)                      {                          buffer[offset++] = mBuffer[mOffset++];                          count--;                          n++;                      }                      return n;                  }                    if (mBuffer.Length - mOffset < 5)                  {                      Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                      mEnding -= mOffset;                      mOffset = 0;                  }                    int delta = mInput.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                  if (delta == 0)                      mInputEnd = true;                  else                      mEnding += delta;              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: if (size < 5)                  return 0;
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: ip += 5;
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  var p = data + bufferPos;                  var limit = data + size - 4;                    while (p < limit && (p[0] & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,BcjArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\BcjDecoder.cs,x86_Convert,The following statement contains a magic number: mState = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
Magic Number,ManagedLzma.SevenZip.Reader,Lzma2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Lzma2Decoder.cs,Lzma2ArchiveDecoder,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,Lzma2ArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\Lzma2Decoder.cs,Lzma2ArchiveDecoder,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: if (settings.Length != 5)                  throw new InvalidDataException();
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PpmdArchiveDecoder,The following statement contains a magic number: mSettingMemory = (uint)settings[1] | ((uint)settings[2] << 8) | ((uint)settings[3] << 16) | ((uint)settings[4] << 24);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd_See_Update,The following statement contains a magic number: if (p.Shift < PPMD_PERIOD_BITS && --p.Count == 0)              {                  p.Summ <<= 1;                  p.Count = (byte)(3 << p.Shift++);              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,PPMD_SetAllBitsIn256Bytes,The following statement contains a magic number: for (int i = 0; i < 256 / sizeof(uint); i += 8)              {                  p[i + 7] = p[i + 6] = p[i + 5] = p[i + 4] = p[i + 3] = p[i + 2] = p[i + 1] = p[i + 0] = ~0u;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_GetBinSumm,The following statement contains a magic number: return ref p.BinSumm[Ppmd7Context_OneState(p.MinContext)->Freq - 1]                       [p.PrevSuccess                           + p.NS2BSIndx[Ppmd7_GetContext(p' p.MinContext->Suffix)->NumStats - 1]                           + (p.HiBitsFlag = p.HB2Flag[p.FoundState->Symbol])                           + 2 * p.HB2Flag[Ppmd7Context_OneState(p.MinContext)->Symbol]                           + ((p.RunLength >> 26) & 0x20)];
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_GetBinSumm,The following statement contains a magic number: return ref p.BinSumm[Ppmd7Context_OneState(p.MinContext)->Freq - 1]                       [p.PrevSuccess                           + p.NS2BSIndx[Ppmd7_GetContext(p' p.MinContext->Suffix)->NumStats - 1]                           + (p.HiBitsFlag = p.HB2Flag[p.FoundState->Symbol])                           + 2 * p.HB2Flag[Ppmd7Context_OneState(p.MinContext)->Symbol]                           + ((p.RunLength >> 26) & 0x20)];
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0' k = 0; i < PPMD_NUM_INDEXES; i++)              {                  uint step = (i >= 12 ? 4 : (i >> 2) + 1);                  do { p.Units2Indx[k++] = (byte)i; } while (--step != 0);                  p.Indx2Units[i] = (byte)k;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0' k = 0; i < PPMD_NUM_INDEXES; i++)              {                  uint step = (i >= 12 ? 4 : (i >> 2) + 1);                  do { p.Units2Indx[k++] = (byte)i; } while (--step != 0);                  p.Indx2Units[i] = (byte)k;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0' k = 0; i < PPMD_NUM_INDEXES; i++)              {                  uint step = (i >= 12 ? 4 : (i >> 2) + 1);                  do { p.Units2Indx[k++] = (byte)i; } while (--step != 0);                  p.Indx2Units[i] = (byte)k;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 9; i++)                  p.NS2BSIndx[i + 2] = 2 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 9; i++)                  p.NS2BSIndx[i + 2] = 2 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 9; i++)                  p.NS2BSIndx[i + 2] = 2 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 256 - 11; i++)                  p.NS2BSIndx[i + 11] = 3 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 256 - 11; i++)                  p.NS2BSIndx[i + 11] = 3 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 256 - 11; i++)                  p.NS2BSIndx[i + 11] = 3 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 256 - 11; i++)                  p.NS2BSIndx[i + 11] = 3 << 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 3; i++)                  p.NS2Indx[i] = (byte)i;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (m = i' k = 1; i < 256; i++)              {                  p.NS2Indx[i] = (byte)m;                    if (--k == 0)                      k = (++m) - 2;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (m = i' k = 1; i < 256; i++)              {                  p.NS2Indx[i] = (byte)m;                    if (--k == 0)                      k = (++m) - 2;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Construct,The following statement contains a magic number: for (i = 0; i < 0x100 - 0x40; i++)                  p.HB2Flag[i + 0x40] = 8;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Alloc,The following statement contains a magic number: if (p.Base == null || p.Size != size)              {                  Ppmd7_Free(p' alloc);                  p.AlignOffset = 4 - (size & 3);                  if ((p.Base = (byte*)alloc.Alloc(alloc' p.AlignOffset + size + UNIT_SIZE)) == null)                      return false;                  p.Size = size;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Alloc,The following statement contains a magic number: if (p.Base == null || p.Size != size)              {                  Ppmd7_Free(p' alloc);                  p.AlignOffset = 4 - (size & 3);                  if ((p.Base = (byte*)alloc.Alloc(alloc' p.AlignOffset + size + UNIT_SIZE)) == null)                      return false;                  p.Size = size;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,GlueFreeBlocks,The following statement contains a magic number: p.GlueCount = 255;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,GlueFreeBlocks,The following statement contains a magic number: for (n = NODE(p' head)->Next; n != head;)              {                  CPpmd7_Node* node = NODE(p' n);                  uint nu;                  CPpmd7_Node_Ref next = node->Next;                  for (nu = node->NU; nu > 128; nu -= 128' node += 128)                      InsertNode(p' node' PPMD_NUM_INDEXES - 1);                  if (I2U(p' i = U2I(p' nu)) != nu)                  {                      uint k = I2U(p' --i);                      InsertNode(p' node + k' nu - k - 1);                  }                  InsertNode(p' node' i);                  n = next;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,GlueFreeBlocks,The following statement contains a magic number: for (n = NODE(p' head)->Next; n != head;)              {                  CPpmd7_Node* node = NODE(p' n);                  uint nu;                  CPpmd7_Node_Ref next = node->Next;                  for (nu = node->NU; nu > 128; nu -= 128' node += 128)                      InsertNode(p' node' PPMD_NUM_INDEXES - 1);                  if (I2U(p' i = U2I(p' nu)) != nu)                  {                      uint k = I2U(p' --i);                      InsertNode(p' node + k' nu - k - 1);                  }                  InsertNode(p' node' i);                  n = next;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,GlueFreeBlocks,The following statement contains a magic number: for (n = NODE(p' head)->Next; n != head;)              {                  CPpmd7_Node* node = NODE(p' n);                  uint nu;                  CPpmd7_Node_Ref next = node->Next;                  for (nu = node->NU; nu > 128; nu -= 128' node += 128)                      InsertNode(p' node' PPMD_NUM_INDEXES - 1);                  if (I2U(p' i = U2I(p' nu)) != nu)                  {                      uint k = I2U(p' --i);                      InsertNode(p' node + k' nu - k - 1);                  }                  InsertNode(p' node' i);                  n = next;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,MyMem12Cpy,The following statement contains a magic number: do              {                  d[0] = s[0];                  d[1] = s[1];                  d[2] = s[2];                  s += 3;                  d += 3;              }              while (--n != 0);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,MyMem12Cpy,The following statement contains a magic number: do              {                  d[0] = s[0];                  d[1] = s[1];                  d[2] = s[2];                  s += 3;                  d += 3;              }              while (--n != 0);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,MyMem12Cpy,The following statement contains a magic number: do              {                  d[0] = s[0];                  d[1] = s[1];                  d[2] = s[2];                  s += 3;                  d += 3;              }              while (--n != 0);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,MyMem12Cpy,The following statement contains a magic number: do              {                  d[0] = s[0];                  d[1] = s[1];                  d[2] = s[2];                  s += 3;                  d += 3;              }              while (--n != 0);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,SetSuccessor,The following statement contains a magic number: (p)->SuccessorHigh = (ushort)(v.Value >> 16);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.LoUnit = p.UnitsStart = p.HiUnit - p.Size / 8 / UNIT_SIZE * 7 * UNIT_SIZE;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.LoUnit = p.UnitsStart = p.HiUnit - p.Size / 8 / UNIT_SIZE * 7 * UNIT_SIZE;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.RunLength = p.InitRL = -(Int32)((p.MaxOrder < 12) ? p.MaxOrder : 12) - 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.RunLength = p.InitRL = -(Int32)((p.MaxOrder < 12) ? p.MaxOrder : 12) - 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.MinContext->NumStats = 256;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.MinContext->SummFreq = 256 + 1;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.LoUnit += U2B(256 / 2);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: p.LoUnit += U2B(256 / 2);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 256; i++)              {                  CPpmd_State* s = &p.FoundState[i];                  s->Symbol = (byte)i;                  s->Freq = 1;                  SetSuccessor(s' default(CPpmd_Void_Ref));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 128; i++)                  for (k = 0; k < 8; k++)                  {                      ushort* dest = p.BinSumm[i] + k;                      ushort val = (ushort)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));                      for (m = 0; m < 64; m += 8)                          dest[m] = val;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 128; i++)                  for (k = 0; k < 8; k++)                  {                      ushort* dest = p.BinSumm[i] + k;                      ushort val = (ushort)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));                      for (m = 0; m < 64; m += 8)                          dest[m] = val;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 128; i++)                  for (k = 0; k < 8; k++)                  {                      ushort* dest = p.BinSumm[i] + k;                      ushort val = (ushort)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));                      for (m = 0; m < 64; m += 8)                          dest[m] = val;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 128; i++)                  for (k = 0; k < 8; k++)                  {                      ushort* dest = p.BinSumm[i] + k;                      ushort val = (ushort)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));                      for (m = 0; m < 64; m += 8)                          dest[m] = val;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 128; i++)                  for (k = 0; k < 8; k++)                  {                      ushort* dest = p.BinSumm[i] + k;                      ushort val = (ushort)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 2));                      for (m = 0; m < 64; m += 8)                          dest[m] = val;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,RestartModel,The following statement contains a magic number: for (i = 0; i < 25; i++)                  for (k = 0; k < 16; k++)                  {                      CPpmd_See* s = &p.See[i][k];                      s->Summ = (ushort)((5 * i + 10) << (s->Shift = PPMD_PERIOD_BITS - 4));                      s->Count = 4;                  }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Init,The following statement contains a magic number: p.DummySee->Count = 64;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,The following statement contains a magic number: if (c->NumStats == 1)                  upState.Freq = ONE_STATE(c)->Freq;              else              {                  uint cf' s0;                  CPpmd_State* s;                  for (s = STATS(p' c); s->Symbol != upState.Symbol; s++) ;                  cf = s->Freq - 1u;                  s0 = (uint)c->SummFreq - (uint)c->NumStats - cf;                  upState.Freq = (byte)(1 + ((2 * cf <= s0)                      ? (5 * cf > s0 ? 1u : 0u)                      : ((2 * cf + 3 * s0 - 1) / (2 * s0))));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,The following statement contains a magic number: if (c->NumStats == 1)                  upState.Freq = ONE_STATE(c)->Freq;              else              {                  uint cf' s0;                  CPpmd_State* s;                  for (s = STATS(p' c); s->Symbol != upState.Symbol; s++) ;                  cf = s->Freq - 1u;                  s0 = (uint)c->SummFreq - (uint)c->NumStats - cf;                  upState.Freq = (byte)(1 + ((2 * cf <= s0)                      ? (5 * cf > s0 ? 1u : 0u)                      : ((2 * cf + 3 * s0 - 1) / (2 * s0))));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,The following statement contains a magic number: if (c->NumStats == 1)                  upState.Freq = ONE_STATE(c)->Freq;              else              {                  uint cf' s0;                  CPpmd_State* s;                  for (s = STATS(p' c); s->Symbol != upState.Symbol; s++) ;                  cf = s->Freq - 1u;                  s0 = (uint)c->SummFreq - (uint)c->NumStats - cf;                  upState.Freq = (byte)(1 + ((2 * cf <= s0)                      ? (5 * cf > s0 ? 1u : 0u)                      : ((2 * cf + 3 * s0 - 1) / (2 * s0))));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,The following statement contains a magic number: if (c->NumStats == 1)                  upState.Freq = ONE_STATE(c)->Freq;              else              {                  uint cf' s0;                  CPpmd_State* s;                  for (s = STATS(p' c); s->Symbol != upState.Symbol; s++) ;                  cf = s->Freq - 1u;                  s0 = (uint)c->SummFreq - (uint)c->NumStats - cf;                  upState.Freq = (byte)(1 + ((2 * cf <= s0)                      ? (5 * cf > s0 ? 1u : 0u)                      : ((2 * cf + 3 * s0 - 1) / (2 * s0))));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CreateSuccessors,The following statement contains a magic number: if (c->NumStats == 1)                  upState.Freq = ONE_STATE(c)->Freq;              else              {                  uint cf' s0;                  CPpmd_State* s;                  for (s = STATS(p' c); s->Symbol != upState.Symbol; s++) ;                  cf = s->Freq - 1u;                  s0 = (uint)c->SummFreq - (uint)c->NumStats - cf;                  upState.Freq = (byte)(1 + ((2 * cf <= s0)                      ? (5 * cf > s0 ? 1u : 0u)                      : ((2 * cf + 3 * s0 - 1) / (2 * s0))));              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)              {                  c = SUFFIX(p' p.MinContext);                    if (c->NumStats == 1)                  {                      CPpmd_State* s = ONE_STATE(c);                      if (s->Freq < 32)                          s->Freq++;                  }                  else                  {                      CPpmd_State* s = STATS(p' c);                      if (s->Symbol != p.FoundState->Symbol)                      {                          do { s++; } while (s->Symbol != p.FoundState->Symbol);                          if (s[0].Freq >= s[-1].Freq)                          {                              SwapStates(&s[0]' &s[-1]);                              s--;                          }                      }                      if (s->Freq < MAX_FREQ - 9)                      {                          s->Freq += 2;                          c->SummFreq += 2;                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)              {                  c = SUFFIX(p' p.MinContext);                    if (c->NumStats == 1)                  {                      CPpmd_State* s = ONE_STATE(c);                      if (s->Freq < 32)                          s->Freq++;                  }                  else                  {                      CPpmd_State* s = STATS(p' c);                      if (s->Symbol != p.FoundState->Symbol)                      {                          do { s++; } while (s->Symbol != p.FoundState->Symbol);                          if (s[0].Freq >= s[-1].Freq)                          {                              SwapStates(&s[0]' &s[-1]);                              s--;                          }                      }                      if (s->Freq < MAX_FREQ - 9)                      {                          s->Freq += 2;                          c->SummFreq += 2;                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)              {                  c = SUFFIX(p' p.MinContext);                    if (c->NumStats == 1)                  {                      CPpmd_State* s = ONE_STATE(c);                      if (s->Freq < 32)                          s->Freq++;                  }                  else                  {                      CPpmd_State* s = STATS(p' c);                      if (s->Symbol != p.FoundState->Symbol)                      {                          do { s++; } while (s->Symbol != p.FoundState->Symbol);                          if (s[0].Freq >= s[-1].Freq)                          {                              SwapStates(&s[0]' &s[-1]);                              s--;                          }                      }                      if (s->Freq < MAX_FREQ - 9)                      {                          s->Freq += 2;                          c->SummFreq += 2;                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)              {                  c = SUFFIX(p' p.MinContext);                    if (c->NumStats == 1)                  {                      CPpmd_State* s = ONE_STATE(c);                      if (s->Freq < 32)                          s->Freq++;                  }                  else                  {                      CPpmd_State* s = STATS(p' c);                      if (s->Symbol != p.FoundState->Symbol)                      {                          do { s++; } while (s->Symbol != p.FoundState->Symbol);                          if (s[0].Freq >= s[-1].Freq)                          {                              SwapStates(&s[0]' &s[-1]);                              s--;                          }                      }                      if (s->Freq < MAX_FREQ - 9)                      {                          s->Freq += 2;                          c->SummFreq += 2;                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)              {                  c = SUFFIX(p' p.MinContext);                    if (c->NumStats == 1)                  {                      CPpmd_State* s = ONE_STATE(c);                      if (s->Freq < 32)                          s->Freq++;                  }                  else                  {                      CPpmd_State* s = STATS(p' c);                      if (s->Symbol != p.FoundState->Symbol)                      {                          do { s++; } while (s->Symbol != p.FoundState->Symbol);                          if (s[0].Freq >= s[-1].Freq)                          {                              SwapStates(&s[0]' &s[-1]);                              s--;                          }                      }                      if (s->Freq < MAX_FREQ - 9)                      {                          s->Freq += 2;                          c->SummFreq += 2;                      }                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,UpdateModel,The following statement contains a magic number: for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p' c))              {                  uint ns1;                  uint cf' sf;                  if ((ns1 = c->NumStats) != 1)                  {                      if ((ns1 & 1) == 0)                      {                          /* Expand for one UNIT */                          uint oldNU = ns1 >> 1;                          uint i = U2I(p' oldNU);                          if (i != U2I(p' oldNU + 1))                          {                              void* ptr = AllocUnits(p' i + 1);                              void* oldPtr;                              if (ptr == null)                              {                                  RestartModel(p);                                  return;                              }                              oldPtr = STATS(p' c);                              MyMem12Cpy(ptr' oldPtr' oldNU);                              InsertNode(p' oldPtr' i);                              c->Stats = STATS_REF(p' ptr);                          }                      }                      c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));                  }                  else                  {                      CPpmd_State* s = (CPpmd_State*)AllocUnits(p' 0);                      if (s == null)                      {                          RestartModel(p);                          return;                      }                      *s = *ONE_STATE(c);                      c->Stats = REF(p' s);                      if (s->Freq < MAX_FREQ / 4 - 1)                          s->Freq <<= 1;                      else                          s->Freq = MAX_FREQ - 4;                      c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));                  }                  cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);                  sf = (uint)s0 + c->SummFreq;                  if (cf < 6 * sf)                  {                      cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);                      c->SummFreq += 3;                  }                  else                  {                      cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);                      c->SummFreq = (ushort)(c->SummFreq + cf);                  }                  {                      CPpmd_State* s = STATS(p' c) + ns1;                      SetSuccessor(s' successor);                      s->Symbol = p.FoundState->Symbol;                      s->Freq = (byte)cf;                      c->NumStats = (ushort)(ns1 + 1);                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Rescale,The following statement contains a magic number: s->Freq += 4;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_MakeEscFreq,The following statement contains a magic number: if (p.MinContext->NumStats != 256)              {                  see = p.See[p.NS2Indx[nonMasked - 1]] +                      (nonMasked < (uint)SUFFIX(p' p.MinContext)->NumStats - p.MinContext->NumStats ? 1 : 0) +                      2 * (p.MinContext->SummFreq < 11 * p.MinContext->NumStats ? 1 : 0) +                      4 * (numMasked > nonMasked ? 1 : 0) +                      p.HiBitsFlag;                  {                      uint r = ((uint)see->Summ >> see->Shift);                      see->Summ = (ushort)(see->Summ - r);                      *escFreq = r + ((r == 0) ? 1u : 0u);                  }              }              else              {                  see = p.DummySee;                  *escFreq = 1;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_MakeEscFreq,The following statement contains a magic number: if (p.MinContext->NumStats != 256)              {                  see = p.See[p.NS2Indx[nonMasked - 1]] +                      (nonMasked < (uint)SUFFIX(p' p.MinContext)->NumStats - p.MinContext->NumStats ? 1 : 0) +                      2 * (p.MinContext->SummFreq < 11 * p.MinContext->NumStats ? 1 : 0) +                      4 * (numMasked > nonMasked ? 1 : 0) +                      p.HiBitsFlag;                  {                      uint r = ((uint)see->Summ >> see->Shift);                      see->Summ = (ushort)(see->Summ - r);                      *escFreq = r + ((r == 0) ? 1u : 0u);                  }              }              else              {                  see = p.DummySee;                  *escFreq = 1;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_MakeEscFreq,The following statement contains a magic number: if (p.MinContext->NumStats != 256)              {                  see = p.See[p.NS2Indx[nonMasked - 1]] +                      (nonMasked < (uint)SUFFIX(p' p.MinContext)->NumStats - p.MinContext->NumStats ? 1 : 0) +                      2 * (p.MinContext->SummFreq < 11 * p.MinContext->NumStats ? 1 : 0) +                      4 * (numMasked > nonMasked ? 1 : 0) +                      p.HiBitsFlag;                  {                      uint r = ((uint)see->Summ >> see->Shift);                      see->Summ = (ushort)(see->Summ - r);                      *escFreq = r + ((r == 0) ? 1u : 0u);                  }              }              else              {                  see = p.DummySee;                  *escFreq = 1;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_MakeEscFreq,The following statement contains a magic number: if (p.MinContext->NumStats != 256)              {                  see = p.See[p.NS2Indx[nonMasked - 1]] +                      (nonMasked < (uint)SUFFIX(p' p.MinContext)->NumStats - p.MinContext->NumStats ? 1 : 0) +                      2 * (p.MinContext->SummFreq < 11 * p.MinContext->NumStats ? 1 : 0) +                      4 * (numMasked > nonMasked ? 1 : 0) +                      p.HiBitsFlag;                  {                      uint r = ((uint)see->Summ >> see->Shift);                      see->Summ = (ushort)(see->Summ - r);                      *escFreq = r + ((r == 0) ? 1u : 0u);                  }              }              else              {                  see = p.DummySee;                  *escFreq = 1;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update1,The following statement contains a magic number: s->Freq += 4;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update1,The following statement contains a magic number: p.MinContext->SummFreq += 4;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update1_0,The following statement contains a magic number: var bit = (2 * p.FoundState->Freq > p.MinContext->SummFreq) ? (byte)1 : (byte)0;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update1_0,The following statement contains a magic number: p.MinContext->SummFreq += 4;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update1_0,The following statement contains a magic number: if ((p.FoundState->Freq += 4) > MAX_FREQ)                  Rescale(p);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_UpdateBin,The following statement contains a magic number: p.FoundState->Freq = (byte)(p.FoundState->Freq + (p.FoundState->Freq < 128 ? 1 : 0));
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update2,The following statement contains a magic number: p.MinContext->SummFreq += 4;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_Update2,The following statement contains a magic number: if ((p.FoundState->Freq += 4) > MAX_FREQ)                  Rescale(p);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7z_RangeDec_Init,The following statement contains a magic number: for (i = 0; i < 4; i++)                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7z_RangeDec_Init,The following statement contains a magic number: for (i = 0; i < 4; i++)                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Range_Normalize,The following statement contains a magic number: if (p.Range < kTopValue)              {                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                  p.Range <<= 8;                  if (p.Range < kTopValue)                  {                      p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                      p.Range <<= 8;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Range_Normalize,The following statement contains a magic number: if (p.Range < kTopValue)              {                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                  p.Range <<= 8;                  if (p.Range < kTopValue)                  {                      p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                      p.Range <<= 8;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Range_Normalize,The following statement contains a magic number: if (p.Range < kTopValue)              {                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                  p.Range <<= 8;                  if (p.Range < kTopValue)                  {                      p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                      p.Range <<= 8;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Range_Normalize,The following statement contains a magic number: if (p.Range < kTopValue)              {                  p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                  p.Range <<= 8;                  if (p.Range < kTopValue)                  {                      p.Code = (p.Code << 8) | p.Stream.Read(p.Stream);                      p.Range <<= 8;                  }              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Range_DecodeBit,The following statement contains a magic number: uint newBound = (p.Range >> 14) * size0;
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The following statement contains a magic number: uint* charMask = stackalloc uint[256 / sizeof(uint)];
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The following statement contains a magic number: if (p.MinContext->NumStats != 1)              {                  CPpmd_State* s = Ppmd7_GetStats(p' p.MinContext);                  uint i;                  uint count' hiCnt;                  if ((count = rc.GetThreshold(rc' p.MinContext->SummFreq)) < (hiCnt = s->Freq))                  {                      byte symbol;                      rc.Decode(rc' 0' s->Freq);                      p.FoundState = s;                      symbol = s->Symbol;                      Ppmd7_Update1_0(p);                      return symbol;                  }                  p.PrevSuccess = 0;                  i = p.MinContext->NumStats - 1u;                  do                  {                      if ((hiCnt += (++s)->Freq) > count)                      {                          byte symbol;                          rc.Decode(rc' hiCnt - s->Freq' s->Freq);                          p.FoundState = s;                          symbol = s->Symbol;                          Ppmd7_Update1(p);                          return symbol;                      }                  }                  while (--i != 0);                  if (count >= p.MinContext->SummFreq)                      return -2;                  p.HiBitsFlag = p.HB2Flag[p.FoundState->Symbol];                  rc.Decode(rc' hiCnt' p.MinContext->SummFreq - hiCnt);                  PPMD_SetAllBitsIn256Bytes(charMask);                  MASK_SET(charMask' s->Symbol' 0);                  i = p.MinContext->NumStats - 1u;                  do { MASK_SET(charMask' (--s)->Symbol' 0); } while (--i != 0);              }              else              {                  ref ushort prob = ref Ppmd7_GetBinSumm(p);                  if (rc.DecodeBit(rc' prob) == 0)                  {                      byte symbol;                      PPMD_UPDATE_PROB_0(ref prob);                      symbol = (p.FoundState = Ppmd7Context_OneState(p.MinContext))->Symbol;                      Ppmd7_UpdateBin(p);                      return symbol;                  }                  PPMD_UPDATE_PROB_1(ref prob);                  p.InitEsc = PPMD7_kExpEscape[prob >> 10];                  PPMD_SetAllBitsIn256Bytes(charMask);                  MASK_SET(charMask' Ppmd7Context_OneState(p.MinContext)->Symbol' 0);                  p.PrevSuccess = 0;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The following statement contains a magic number: if (p.MinContext->NumStats != 1)              {                  CPpmd_State* s = Ppmd7_GetStats(p' p.MinContext);                  uint i;                  uint count' hiCnt;                  if ((count = rc.GetThreshold(rc' p.MinContext->SummFreq)) < (hiCnt = s->Freq))                  {                      byte symbol;                      rc.Decode(rc' 0' s->Freq);                      p.FoundState = s;                      symbol = s->Symbol;                      Ppmd7_Update1_0(p);                      return symbol;                  }                  p.PrevSuccess = 0;                  i = p.MinContext->NumStats - 1u;                  do                  {                      if ((hiCnt += (++s)->Freq) > count)                      {                          byte symbol;                          rc.Decode(rc' hiCnt - s->Freq' s->Freq);                          p.FoundState = s;                          symbol = s->Symbol;                          Ppmd7_Update1(p);                          return symbol;                      }                  }                  while (--i != 0);                  if (count >= p.MinContext->SummFreq)                      return -2;                  p.HiBitsFlag = p.HB2Flag[p.FoundState->Symbol];                  rc.Decode(rc' hiCnt' p.MinContext->SummFreq - hiCnt);                  PPMD_SetAllBitsIn256Bytes(charMask);                  MASK_SET(charMask' s->Symbol' 0);                  i = p.MinContext->NumStats - 1u;                  do { MASK_SET(charMask' (--s)->Symbol' 0); } while (--i != 0);              }              else              {                  ref ushort prob = ref Ppmd7_GetBinSumm(p);                  if (rc.DecodeBit(rc' prob) == 0)                  {                      byte symbol;                      PPMD_UPDATE_PROB_0(ref prob);                      symbol = (p.FoundState = Ppmd7Context_OneState(p.MinContext))->Symbol;                      Ppmd7_UpdateBin(p);                      return symbol;                  }                  PPMD_UPDATE_PROB_1(ref prob);                  p.InitEsc = PPMD7_kExpEscape[prob >> 10];                  PPMD_SetAllBitsIn256Bytes(charMask);                  MASK_SET(charMask' Ppmd7Context_OneState(p.MinContext)->Symbol' 0);                  p.PrevSuccess = 0;              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The following statement contains a magic number: for (;;)              {                  CPpmd_State** ps = stackalloc CPpmd_State*[256];                  CPpmd_State* s;                  uint freqSum' count' hiCnt;                  CPpmd_See* see;                  uint i' num' numMasked = p.MinContext->NumStats;                  do                  {                      p.OrderFall++;                      if (p.MinContext->Suffix.Value == 0)                          return -1;                      p.MinContext = Ppmd7_GetContext(p' p.MinContext->Suffix);                  }                  while (p.MinContext->NumStats == numMasked);                  hiCnt = 0;                  s = Ppmd7_GetStats(p' p.MinContext);                  i = 0;                  num = p.MinContext->NumStats - numMasked;                  do                  {                      uint k = (uint)(int)(MASK_GET(charMask' s->Symbol));                      hiCnt += (s->Freq & k);                      ps[i] = s++;                      i -= k;                  }                  while (i != num);                    see = Ppmd7_MakeEscFreq(p' numMasked' &freqSum);                  freqSum += hiCnt;                  count = rc.GetThreshold(rc' freqSum);                    if (count < hiCnt)                  {                      byte symbol;                      CPpmd_State** pps = ps;                      for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++) ;                      s = *pps;                      rc.Decode(rc' hiCnt - s->Freq' s->Freq);                      Ppmd_See_Update(ref *see);                      p.FoundState = s;                      symbol = s->Symbol;                      Ppmd7_Update2(p);                      return symbol;                  }                  if (count >= freqSum)                      return -2;                  rc.Decode(rc' hiCnt' freqSum - hiCnt);                  see->Summ = (ushort)(see->Summ + freqSum);                  do { MASK_SET(charMask' ps[--i]->Symbol' 0); } while (i != 0);              }
Magic Number,ManagedLzma.SevenZip.Reader,PPMD,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,Ppmd7_DecodeSymbol,The following statement contains a magic number: for (;;)              {                  CPpmd_State** ps = stackalloc CPpmd_State*[256];                  CPpmd_State* s;                  uint freqSum' count' hiCnt;                  CPpmd_See* see;                  uint i' num' numMasked = p.MinContext->NumStats;                  do                  {                      p.OrderFall++;                      if (p.MinContext->Suffix.Value == 0)                          return -1;                      p.MinContext = Ppmd7_GetContext(p' p.MinContext->Suffix);                  }                  while (p.MinContext->NumStats == numMasked);                  hiCnt = 0;                  s = Ppmd7_GetStats(p' p.MinContext);                  i = 0;                  num = p.MinContext->NumStats - numMasked;                  do                  {                      uint k = (uint)(int)(MASK_GET(charMask' s->Symbol));                      hiCnt += (s->Freq & k);                      ps[i] = s++;                      i -= k;                  }                  while (i != num);                    see = Ppmd7_MakeEscFreq(p' numMasked' &freqSum);                  freqSum += hiCnt;                  count = rc.GetThreshold(rc' freqSum);                    if (count < hiCnt)                  {                      byte symbol;                      CPpmd_State** pps = ps;                      for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++) ;                      s = *pps;                      rc.Decode(rc' hiCnt - s->Freq' s->Freq);                      Ppmd_See_Update(ref *see);                      p.FoundState = s;                      symbol = s->Symbol;                      Ppmd7_Update2(p);                      return symbol;                  }                  if (count >= freqSum)                      return -2;                  rc.Decode(rc' hiCnt' freqSum - hiCnt);                  see->Summ = (ushort)(see->Summ + freqSum);                  do { MASK_SET(charMask' ps[--i]->Symbol' 0); } while (i != 0);              }
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: mBackingSee = Marshal.AllocCoTaskMem(kSeeSize * (25 * 16 + 1));
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: mBackingSee = Marshal.AllocCoTaskMem(kSeeSize * (25 * 16 + 1));
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: for (int i = 0; i < 25; i++)                  {                      See[i] = DummySee;                      DummySee += 16;                  }
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: for (int i = 0; i < 25; i++)                  {                      See[i] = DummySee;                      DummySee += 16;                  }
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: mBackingBinSumm = Marshal.AllocCoTaskMem(128 * 64 * 2);
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: mBackingBinSumm = Marshal.AllocCoTaskMem(128 * 64 * 2);
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: mBackingBinSumm = Marshal.AllocCoTaskMem(128 * 64 * 2);
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: for (int i = 0; i < 128; i++)                  {                      BinSumm[i] = p;                      p += 64;                  }
Magic Number,ManagedLzma.SevenZip.Reader,CPpmd7,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CPpmd7,The following statement contains a magic number: for (int i = 0; i < 128; i++)                  {                      BinSumm[i] = p;                      p += 64;                  }
Magic Number,ManagedLzma.SevenZip.Metadata,DecodedStreamIndex,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadata.cs,GetHashCode,The following statement contains a magic number: return (mSectionIndex << 16) + mStreamIndex;
Magic Number,ManagedLzma.SevenZip.Metadata,DecoderInputMetadata,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveMetadata.cs,GetHashCode,The following statement contains a magic number: return (mDecoderIndex << 16) + mStreamIndex;
Magic Number,ManagedLzma.SevenZip.Metadata,CompressionMethod,C:\repos\weltkante_managed-lzma\shared\SevenZip\CompressionMethod.cs,CheckInputOutputCount,The following statement contains a magic number: switch (~mSignature)              {                  case kCopy:                  case kDeflate:                  case kLZMA:                  case kLZMA2:                  case kAES:                  case kBCJ:                  case kPPMD:                      if (inputCount != 1)                          throw new InvalidDataException();                        if (outputCount != 1)                          throw new InvalidDataException();                        break;                    case kBCJ2:                      if (inputCount != 4)                          throw new InvalidDataException();                        if (outputCount != 1)                          throw new InvalidDataException();                        break;                    case kDelta:                  case kBZip2:                      throw new NotImplementedException();                    default:                      throw new InvalidDataException();              }
Magic Number,ManagedLzma.SevenZip.Metadata,CompressionMethod,C:\repos\weltkante_managed-lzma\shared\SevenZip\CompressionMethod.cs,GetInputCount,The following statement contains a magic number: switch (~mSignature)              {                  case kCopy:                  case kDeflate:                  case kLZMA:                  case kLZMA2:                  case kAES:                  case kBCJ:                  case kPPMD:                      return 1;                    case kBCJ2:                      return 4;                    case kDelta:                  case kBZip2:                      throw new NotImplementedException();                    default:                      throw new InternalFailureException();              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt32,The following statement contains a magic number: buffer[offset + 1] = (byte)(value >> 8);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt32,The following statement contains a magic number: buffer[offset + 2] = (byte)(value >> 16);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt32,The following statement contains a magic number: buffer[offset + 2] = (byte)(value >> 16);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt32,The following statement contains a magic number: buffer[offset + 3] = (byte)(value >> 24);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt32,The following statement contains a magic number: buffer[offset + 3] = (byte)(value >> 24);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt64,The following statement contains a magic number: PutInt32(buffer' offset + 4' (int)(value >> 32));
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PutInt64,The following statement contains a magic number: PutInt32(buffer' offset + 4' (int)(value >> 32));
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteMetadata,The following statement contains a magic number: if (subStreamCount > 0)              {                  WriteToken(ArchiveMetadataToken.Files);                  WriteNumber(metadataCount);                    #region Types                  {                      int emptyStreamCount = 0;                        for (int i = 0; i < metadataCount; i++)                          if (!metadata.HasStream(i))                              emptyStreamCount++;                        if (emptyStreamCount > 0)                      {                          WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyStream'                              Enumerable.Range(0' metadataCount)                              .Select(x => !metadata.HasStream(x))'                              metadataCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => !metadata.IsDirectory(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.EmptyFile'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => !metadata.IsDirectory(x))'                                  emptyStreamCount);                            if (Enumerable.Range(0' metadataCount).Where(x => !metadata.HasStream(x)).Any(x => metadata.IsDeleted(x)))                              WriteBitVectorWithHeader(ArchiveMetadataToken.Anti'                                  Enumerable.Range(0' metadataCount)                                  .Where(x => !metadata.HasStream(x))                                  .Select(x => metadata.IsDeleted(x))'                                  emptyStreamCount);                      }                  }                  #endregion                    #region Names                  {                      bool hasNames = false;                      int nameSize = 1;                        for (int i = 0; i < subStreamCount; i++)                      {                          var name = metadata.GetName(i);                          if (!string.IsNullOrEmpty(name))                          {                              hasNames = true;                              nameSize += (name.Length + 1) * 2;                          }                          else                          {                              nameSize += 2;                          }                      }                        if (hasNames)                      {                          WritePadding(2 + GetNumberSize(nameSize)' 16);                          WriteToken(ArchiveMetadataToken.Name);                          WriteNumber(nameSize);                          WriteByte(0);                            System.Diagnostics.Debug.Assert((mArchiveStream.Position & 15) == 0);                            for (int i = 0; i < subStreamCount; i++)                          {                              var name = metadata.GetName(i);                              foreach (char ch in name)                              {                                  WriteByte((byte)ch);                                  WriteByte((byte)(ch >> 8));                              }                              WriteByte(0);                              WriteByte(0);                          }                      }                  }                  #endregion                    WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetCreationDate(x))' ArchiveMetadataToken.CTime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastAccessDate(x))' ArchiveMetadataToken.ATime);                  WriteDateVector(Enumerable.Range(0' metadataCount).Select(x => metadata.GetLastWriteDate(x))' ArchiveMetadataToken.MTime);                  // TODO: what does the start position mean? it doesn't seem to be what I thought it was.                  WriteUInt64Vector(Enumerable.Range(0' metadataCount).Select(x => default(ulong?))' ArchiveMetadataToken.StartPos);                  WriteUInt32Vector(Enumerable.Range(0' metadataCount).Select(x => {                      var attr = metadata.GetAttributes(x);                      return attr.HasValue ? (uint)attr.Value : default(uint?);                  })' ArchiveMetadataToken.WinAttributes);                    WriteToken(ArchiveMetadataToken.End);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteBitVectorWithHeader,The following statement contains a magic number: WriteNumber((count + 7) / 8);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteBitVectorWithHeader,The following statement contains a magic number: WriteNumber((count + 7) / 8);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteAlignedHeaderWithBitVector,The following statement contains a magic number: var vectorSize = (itemCount == vectorCount) ? 0 : (vectorCount + 7) / 8;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteAlignedHeaderWithBitVector,The following statement contains a magic number: var vectorSize = (itemCount == vectorCount) ? 0 : (vectorCount + 7) / 8;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteAlignedHeaderWithBitVector,The following statement contains a magic number: var contentSize = 2 + vectorSize + itemCount * itemSize;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteAlignedHeaderWithBitVector,The following statement contains a magic number: WritePadding(3 + vectorSize + GetNumberSize(contentSize)' itemSize);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt64Vector,The following statement contains a magic number: if (defined > 0)              {                  WriteAlignedHeaderWithBitVector(vector.Select(x => x.HasValue)' count' defined' token' 8);                  System.Diagnostics.Debug.Assert((mArchiveStream.Position & 7) == 0);                    foreach (var slot in vector)                      if (slot.HasValue)                          WriteUInt64(slot.Value);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt64Vector,The following statement contains a magic number: if (defined > 0)              {                  WriteAlignedHeaderWithBitVector(vector.Select(x => x.HasValue)' count' defined' token' 8);                  System.Diagnostics.Debug.Assert((mArchiveStream.Position & 7) == 0);                    foreach (var slot in vector)                      if (slot.HasValue)                          WriteUInt64(slot.Value);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt32Vector,The following statement contains a magic number: if (defined > 0)              {                  WriteAlignedHeaderWithBitVector(vector.Select(x => x.HasValue)' count' defined' token' 4);                  System.Diagnostics.Debug.Assert((mArchiveStream.Position & 3) == 0);                    foreach (var slot in vector)                      if (slot.HasValue)                          WriteInt32((int)slot.Value);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt32Vector,The following statement contains a magic number: if (defined > 0)              {                  WriteAlignedHeaderWithBitVector(vector.Select(x => x.HasValue)' count' defined' token' 4);                  System.Diagnostics.Debug.Assert((mArchiveStream.Position & 3) == 0);                    foreach (var slot in vector)                      if (slot.HasValue)                          WriteInt32((int)slot.Value);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteDecoderSection,The following statement contains a magic number: for (int i = 0; i < definition.Decoders.Length; i++)              {                  var decoder = definition.Decoders[i];                  var id = decoder.DecoderType.Encode();                  var multiStream = decoder.InputStreams.Length != 1 || decoder.OutputStreams.Length != 1;                    var settings = decoder.Settings;                  var hasSettings = !settings.IsDefaultOrEmpty;                    System.Diagnostics.Debug.Assert(!id.IsDefaultOrEmpty && id.Length <= 15);                  var flags = (byte)id.Length;                  if (multiStream) flags |= 0x10;                  if (hasSettings) flags |= 0x20;                    WriteByte(flags);                  foreach (var bt in id)                      WriteByte(bt);                    if (multiStream)                  {                      WriteNumber(decoder.InputStreams.Length);                      WriteNumber(decoder.OutputStreams.Length);                  }                    if (hasSettings)                  {                      WriteNumber(settings.Length);                      foreach (var bt in settings)                          WriteByte(bt);                  }              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteToken,The following statement contains a magic number: System.Diagnostics.Debug.Assert(0 <= (int)token && (int)token <= 25);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WritePadding,The following statement contains a magic number: if (offset > 0)              {                  var padding = alignment - offset;                    if (padding < 2)                      padding += alignment;                    padding -= 2;                    WriteToken(ArchiveMetadataToken.Padding);                  WriteByte((byte)padding);                    for (int i = 0; i < padding; i++)                      WriteByte(0);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WritePadding,The following statement contains a magic number: if (offset > 0)              {                  var padding = alignment - offset;                    if (padding < 2)                      padding += alignment;                    padding -= 2;                    WriteToken(ArchiveMetadataToken.Padding);                  WriteByte((byte)padding);                    for (int i = 0; i < padding; i++)                      WriteByte(0);              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteInt32,The following statement contains a magic number: WriteByte((byte)(value >> 8));
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteInt32,The following statement contains a magic number: WriteByte((byte)(value >> 16));
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteInt32,The following statement contains a magic number: WriteByte((byte)(value >> 24));
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  WriteByte((byte)value);                  value >>= 8;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteUInt64,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  WriteByte((byte)value);                  value >>= 8;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteNumber,The following statement contains a magic number: while (count < 8)              {                  if (value < (1L << (7 * (count + 1))))                  {                      header |= (byte)(value >> (8 * count));                      break;                  }                    header |= mask;                  mask >>= 1;                  count += 1;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteNumber,The following statement contains a magic number: while (count < 8)              {                  if (value < (1L << (7 * (count + 1))))                  {                      header |= (byte)(value >> (8 * count));                      break;                  }                    header |= mask;                  mask >>= 1;                  count += 1;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteNumber,The following statement contains a magic number: while (count < 8)              {                  if (value < (1L << (7 * (count + 1))))                  {                      header |= (byte)(value >> (8 * count));                      break;                  }                    header |= mask;                  mask >>= 1;                  count += 1;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,WriteNumber,The following statement contains a magic number: while (count > 0)              {                  WriteByte((byte)value);                  value >>= 8;                  count -= 1;              }
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,GetNumberSize,The following statement contains a magic number: while (length < 9 && value >= (1L << (length * 7)))                  length++;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,GetNumberSize,The following statement contains a magic number: while (length < 9 && value >= (1L << (length * 7)))                  length++;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: buffer[6] = kMajorVersion;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: buffer[7] = kMinorVersion;
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: PutInt32(buffer' 8' (int)crc);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: PutInt64(buffer' 12' metadataOffset);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: PutInt64(buffer' 20' mMetadataLength);
Magic Number,ManagedLzma.SevenZip.Writer,ArchiveWriter,C:\repos\weltkante_managed-lzma\shared\SevenZip\ArchiveWriter.cs,PrepareHeader,The following statement contains a magic number: PutInt32(buffer' 28' mMetadataChecksum.Value);
Magic Number,ManagedLzma.SevenZip.Writer,AesEncoderSeed,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CreateRandom,The following statement contains a magic number: var seed = new byte[8];
Magic Number,ManagedLzma.SevenZip.Writer,AesEncoderSeed,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,AesEncoderSeed,The following statement contains a magic number: mSeed16 = new byte[16];
Magic Number,ManagedLzma.SevenZip.Writer,AesEncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,AesEncoderSettings,The following statement contains a magic number: mSlowdown = 19;
Magic Number,ManagedLzma.SevenZip.Writer,AesEncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,SerializeSettings,The following statement contains a magic number: var buffer = ImmutableArray.CreateBuilder<byte>(2 + saltSize + seedSize);
Magic Number,ManagedLzma.SevenZip.Writer,AesEncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,SerializeSettings,The following statement contains a magic number: buffer.Add((byte)((encodedSaltSize << 4) | encodedSeedSize));
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,EncryptionStream,The following statement contains a magic number: mBuffer1 = new byte[16];
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,EncryptionStream,The following statement contains a magic number: mBuffer2 = new byte[16];
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,WriteAsync,The following statement contains a magic number: for (;;)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                          System.Diagnostics.Debug.Assert(written == 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      System.Diagnostics.Debug.Assert(copy > 0);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      result += copy;                      offset += copy;                      length -= copy;                        if (length == 0 || mode == StreamMode.Partial)                          return result;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,WriteAsync,The following statement contains a magic number: for (;;)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                          System.Diagnostics.Debug.Assert(written == 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      System.Diagnostics.Debug.Assert(copy > 0);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      result += copy;                      offset += copy;                      length -= copy;                        if (length == 0 || mode == StreamMode.Partial)                          return result;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,WriteAsync,The following statement contains a magic number: for (;;)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                          System.Diagnostics.Debug.Assert(written == 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      System.Diagnostics.Debug.Assert(copy > 0);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      result += copy;                      offset += copy;                      length -= copy;                        if (length == 0 || mode == StreamMode.Partial)                          return result;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,WriteAsync,The following statement contains a magic number: for (;;)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                          System.Diagnostics.Debug.Assert(written == 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      System.Diagnostics.Debug.Assert(copy > 0);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      result += copy;                      offset += copy;                      length -= copy;                        if (length == 0 || mode == StreamMode.Partial)                          return result;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,WriteAsync,The following statement contains a magic number: for (;;)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                          System.Diagnostics.Debug.Assert(written == 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      System.Diagnostics.Debug.Assert(copy > 0);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      result += copy;                      offset += copy;                      length -= copy;                        if (length == 0 || mode == StreamMode.Partial)                          return result;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CompleteAsync,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        System.Diagnostics.Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                      System.Diagnostics.Debug.Assert(written == 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CompleteAsync,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        System.Diagnostics.Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                      System.Diagnostics.Debug.Assert(written == 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CompleteAsync,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        System.Diagnostics.Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                      System.Diagnostics.Debug.Assert(written == 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CompleteAsync,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        System.Diagnostics.Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                      System.Diagnostics.Debug.Assert(written == 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.SevenZip.Writer,EncryptionStream,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\AesEncoder.cs,CompleteAsync,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        System.Diagnostics.Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      var written = await mOutput.WriteAsync(mBuffer2' 0' 16' StreamMode.Complete).ConfigureAwait(false);                      System.Diagnostics.Debug.Assert(written == 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.SevenZip.Writer,Lzma2EncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Lzma2Encoder.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.SevenZip.Writer,Lzma2EncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Lzma2Encoder.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.SevenZip.Writer,Lzma2EncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Lzma2Encoder.cs,LZMA2_DIC_SIZE_FROM_PROP,The following statement contains a magic number: return (uint)(2 | (p & 1)) << (p / 2 + 11);
Magic Number,ManagedLzma.SevenZip.Writer,Lzma2EncoderSettings,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Lzma2Encoder.cs,Lzma2Enc_WriteProperties,The following statement contains a magic number: while (i < 40 && dicSize > LZMA2_DIC_SIZE_FROM_PROP(i))                  i++;
Magic Number,ManagedLzma.SevenZip.Writer,EncoderInput,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,Dispose,The following statement contains a magic number: if (mFinalized != 3)                  System.Diagnostics.Debugger.Break();
Magic Number,ManagedLzma.SevenZip.Writer,EncoderInput,C:\repos\weltkante_managed-lzma\shared\SevenZip\Encoders\Runtime.cs,GetFinalChecksum,The following statement contains a magic number: mFinalized |= 2;
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));                    kTable[i] = r;              }
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));                    kTable[i] = r;              }
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 256; i < kTable.Length; i++)              {                  uint r = kTable[i - 256];                  kTable[i] = kTable[r & 0xFF] ^ (r >> 8);              }
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 256; i < kTable.Length; i++)              {                  uint r = kTable[i - 256];                  kTable[i] = kTable[r & 0xFF] ^ (r >> 8);              }
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 256; i < kTable.Length; i++)              {                  uint r = kTable[i - 256];                  kTable[i] = kTable[r & 0xFF] ^ (r >> 8);              }
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,From,The following statement contains a magic number: byte[] buffer = new byte[Math.Min(length' 4 << 10)];
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,From,The following statement contains a magic number: byte[] buffer = new byte[Math.Min(length' 4 << 10)];
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,Update,The following statement contains a magic number: return kTable[(crc & 0xFF) ^ bt] ^ (crc >> 8);
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,Update,The following statement contains a magic number: return kTable[0x300 + (crc & 0xFF)]                  ^ kTable[0x200 + ((crc >> 8) & 0xFF)]                  ^ kTable[0x100 + ((crc >> 16) & 0xFF)]                  ^ kTable[0x000 + (crc >> 24)];
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,Update,The following statement contains a magic number: return kTable[0x300 + (crc & 0xFF)]                  ^ kTable[0x200 + ((crc >> 8) & 0xFF)]                  ^ kTable[0x100 + ((crc >> 16) & 0xFF)]                  ^ kTable[0x000 + (crc >> 24)];
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,Update,The following statement contains a magic number: return kTable[0x300 + (crc & 0xFF)]                  ^ kTable[0x200 + ((crc >> 8) & 0xFF)]                  ^ kTable[0x100 + ((crc >> 16) & 0xFF)]                  ^ kTable[0x000 + (crc >> 24)];
Magic Number,ManagedLzma,CRC,C:\repos\weltkante_managed-lzma\shared\Utilities\CRC.cs,Update,The following statement contains a magic number: return Update(Update(crc' (uint)value)' (uint)(value >> 32));
Magic Number,ManagedLzma,PasswordAccessor,C:\repos\weltkante_managed-lzma\shared\Utilities\Password.cs,GetHashCode,The following statement contains a magic number: int hash = unchecked((int)2166136261);
Magic Number,ManagedLzma,PasswordAccessor,C:\repos\weltkante_managed-lzma\shared\Utilities\Password.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < mPassword.Length; i++)                  hash = (hash ^ mPassword[i]) * 16777619;
Missing Default,ManagedLzma.SevenZip.Reader,PpmdArchiveDecoder,C:\repos\weltkante_managed-lzma\shared\SevenZip\Decoders\PpmdDecoder.cs,CodeSpec,The following switch statement is missing a default case: switch (mDecoderStatus)              {                  case kStatus.Finished:                      return HRESULT.S_OK;                    case kStatus.Error:                      return HRESULT.S_FALSE;                    case kStatus.NeedInit:                      //_inStream.Init();                      if (!PPMD.Ppmd7z_RangeDec_Init(mRangeDecoder))                      {                          mDecoderStatus = kStatus.Error;                          return HRESULT.S_FALSE;                      }                      mDecoderStatus = kStatus.Normal;                      PPMD.Ppmd7_Init(mState' mSettingOrder);                      break;              }
