Implementation smell,Namespace,Class,File,Method,Description
Long Method,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The method has 288 lines of code.
Long Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,GetNextFolderItem,The method has 104 lines of code.
Long Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadSubStreamsInfo,The method has 114 lines of code.
Long Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadHeader,The method has 200 lines of code.
Complex Method,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,Cyclomatic complexity of the method is 47
Complex Method,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,Cyclomatic complexity of the method is 10
Complex Method,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,Cyclomatic complexity of the method is 10
Complex Method,master._7zip.Legacy,DecoderStreamHelper,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\DecoderStream.cs,CreateDecoderStream,Cyclomatic complexity of the method is 8
Complex Method,master._7zip.Legacy,Lzma2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Lzma2DecoderStream.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,master._7zip.Legacy,LzmaDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\LzmaDecoderStream.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,master._7zip.Legacy,CArchiveDatabaseEx,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,FillFolderStartFileIndex,Cyclomatic complexity of the method is 9
Complex Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,GetNextFolderItem,Cyclomatic complexity of the method is 13
Complex Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadSubStreamsInfo,Cyclomatic complexity of the method is 21
Complex Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadHeader,Cyclomatic complexity of the method is 13
Complex Method,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Extract,Cyclomatic complexity of the method is 13
Complex Method,master._7zip.Legacy,CFolder,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Item.cs,CheckStructure,Cyclomatic complexity of the method is 17
Long Parameter List,ManagedLzma.LZMA.Master.SevenZip,Encoder,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishFileSet,The method has 5 parameters. Parameters: entries' inputSize' outputSize' inputHash' outputHash
Long Parameter List,ManagedLzma.LZMA.Master.SevenZip,PlainEncoder,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishFileSet,The method has 5 parameters. Parameters: entries' inputSize' outputSize' inputHash' outputHash
Long Parameter List,ManagedLzma.LZMA.Master.SevenZip,LzmaEncoder,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishFileSet,The method has 5 parameters. Parameters: entries' inputSize' outputSize' inputHash' outputHash
Long Parameter List,ManagedLzma.LZMA.Master.SevenZip,Lzma2Encoder,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishFileSet,The method has 5 parameters. Parameters: entries' inputSize' outputSize' inputHash' outputHash
Long Parameter List,master._7zip.Legacy,DecoderStreamHelper,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\DecoderStream.cs,CreateDecoderStream,The method has 6 parameters. Parameters: packStreams' packSizes' outStreams' folderInfo' coderIndex' pass
Long Parameter List,master._7zip.Legacy,DecoderStreamHelper,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\DecoderStream.cs,CreateDecoderStream,The method has 5 parameters. Parameters: inStream' startPos' packSizes' folderInfo' pass
Long Parameter List,master._7zip.Legacy,DecoderRegistry,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Registry.cs,CreateDecoderStream,The method has 5 parameters. Parameters: id' inStreams' info' pass' limit
Long Parameter List,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadStreamsInfo,The method has 8 parameters. Parameters: dataVector' dataOffset' packSizes' packCRCs' folders' numUnpackStreamsInFolders' unpackSizes' digests
Long Statement,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The length of the statement  "                WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC); " is 123.
Long Statement,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The length of the statement  "                    limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size " is 134.
Long Statement,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The length of the statement  "                    limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams " is 139.
Long Statement,ManagedLzma.LZMA.Master.SevenZip,Encoder,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,AdjustCoderForEncryption,The length of the statement  "                if (coder.InputStreams.Length != 1 || !(coder.InputStreams[0] is InputStreamRef) || ((InputStreamRef)coder.InputStreams[0]).PackedStreamIndex != 0) " is 147.
Long Statement,master._7zip.Legacy,Lzma2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Lzma2DecoderStream.cs,Read,The length of the statement  "                    mWritten + safeCount == mLimit ? LZMA.ELzmaFinishMode.LZMA_FINISH_END : LZMA.ELzmaFinishMode.LZMA_FINISH_ANY' out status); " is 122.
Long Statement,master._7zip.Legacy,Lzma2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Lzma2DecoderStream.cs,Read,The length of the statement  "                Buffer.BlockCopy(mDecoder.mDecoder.mDic.mBuffer' mDecoder.mDecoder.mDic.mOffset + (int)origin' buffer' offset' processed); " is 122.
Long Statement,master._7zip.Legacy,LzmaDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\LzmaDecoderStream.cs,Read,The length of the statement  "                    mWritten + safeCount == mLimit ? LZMA.ELzmaFinishMode.LZMA_FINISH_END : LZMA.ELzmaFinishMode.LZMA_FINISH_ANY' out status); " is 122.
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,ArchiveWriter,The following statement contains a magic number: writer.Write((byte)3);
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,WriteFinalHeader,The following statement contains a magic number: if (files.Length != 0)              {                  long headerOffset = mFileStream.Position;                    var headerStream = new master._7zip.Legacy.CrcBuilderStream(mFileStream);                  var writer = new BinaryWriter(headerStream' Encoding.Unicode);                    WriteNumber(writer' BlockType.Header);                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      WriteNumber(writer' BlockType.MainStreamsInfo);                      WriteNumber(writer' BlockType.PackInfo);                      WriteNumber(writer' (ulong)0); // offset to input streams                      WriteNumber(writer' inputStreams.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in inputStreams)                          WriteNumber(writer' stream.Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.UnpackInfo);                      WriteNumber(writer' BlockType.Folder);                      WriteNumber(writer' mFileSets.Count);                      writer.Write((byte)0); // inline data                      foreach (var fileset in mFileSets)                      {                          WriteNumber(writer' fileset.Coders.Length);                          var coderOffsetMap = new int[fileset.Coders.Length];                          var outputStreamCount = 0;                          for (int i = 0; i < coderOffsetMap.Length; i++)                          {                              coderOffsetMap[i] = outputStreamCount;                              outputStreamCount += fileset.Coders[i].OutputStreams.Length;                          }                          var inputBindPairs = new List<Tuple<int' int>>();                          var coderBindPairs = new List<Tuple<int' int>>();                          var inputStreamCount = 0;                          foreach (var coder in fileset.Coders)                          {                              int idlen = coder.MethodId.GetLength();                              if (idlen >= 8)                                  throw new NotSupportedException();                                int flags = idlen;                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  flags |= 0x10;                                if (coder.Settings != null)                                  flags |= 0x20;                                writer.Write((byte)flags);                                ulong id = coder.MethodId.Id;                              for (int i = idlen - 1; i >= 0; i--)                                  writer.Write((byte)(id >> (i * 8)));                                if ((flags & 0x10) != 0)                              {                                  WriteNumber(writer' coder.InputStreams.Length);                                  WriteNumber(writer' coder.OutputStreams.Length);                              }                                if ((flags & 0x20) != 0)                              {                                  WriteNumber(writer' coder.Settings.Length);                                  writer.Write(coder.Settings);                              }                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                                foreach (var streamRef in coder.InputStreams)                              {                                  if (streamRef is InputStreamRef)                                  {                                      var inputStreamRef = (InputStreamRef)streamRef;                                      inputBindPairs.Add(Tuple.Create(inputStreamCount++' inputStreamRef.PackedStreamIndex));                                  }                                  else                                  {                                      var coderStreamRef = (CoderStreamRef)streamRef;                                      var index = coderOffsetMap[coderStreamRef.CoderIndex] + coderStreamRef.StreamIndex;                                      coderBindPairs.Add(Tuple.Create(inputStreamCount++' index));                                  }                              }                          }                          Utils.Assert(coderBindPairs.Count == outputStreamCount - 1);                          Utils.Assert(inputBindPairs.Count == inputStreamCount - outputStreamCount + 1);                          foreach (var pair in coderBindPairs)                          {                              WriteNumber(writer' pair.Item1);                              WriteNumber(writer' pair.Item2);                          }                          if (inputBindPairs.Count > 1)                          {                              inputBindPairs.Sort((x' y) => x.Item2.CompareTo(y.Item2));                              for (int i = 0; i < inputBindPairs.Count; i++)                              {                                  if (inputBindPairs[i].Item2 != i)                                      throw new Exception("Internal Error: mismatched coder bindings");                                    WriteNumber(writer' inputBindPairs[i].Item1);                              }                          }                      }                      WriteNumber(writer' BlockType.CodersUnpackSize);                      foreach (var fileset in mFileSets)                          foreach (var coder in fileset.Coders)                              foreach (var outputInfo in coder.OutputStreams)                                  WriteNumber(writer' outputInfo.Size);                      {                          bool allHashes = true;                          bool anyHashes = false;                          // add padding so we can process blocks of 8 without running off the array                          // (all code needs to use the fileset count instead of the array length though)                          var hashes = new uint?[mFileSets.Count + 8];                          for (int i = 0; i < mFileSets.Count; i++)                          {                              if ((hashes[i] = mFileSets[i].DataStream.GetHash(mFileSets[i])).HasValue)                                  anyHashes = true;                              else                                  allHashes = false;                          }                          if (anyHashes)                          {                              WriteNumber(writer' BlockType.CRC);                              if (allHashes)                              {                                  writer.Write((byte)1);                              }                              else                              {                                  writer.Write((byte)0);                                  for (int i = 0; i < mFileSets.Count; i += 8)                                  {                                      byte bt = 0;                                      for (int j = 0; j < 8; j++)                                      {                                          bt <<= 1;                                          if (hashes[i + j] != null)                                              bt |= (byte)1;                                      }                                      writer.Write(bt);                                  }                              }                              for (int i = 0; i < mFileSets.Count; i++)                                  if (hashes[i] != null)                                      writer.Write(hashes[i].Value);                          }                      }                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.SubStreamsInfo);                      WriteNumber(writer' BlockType.NumUnpackStream);                      foreach (var stream in mFileSets)                          WriteNumber(writer' stream.Files.Length);                      WriteNumber(writer' BlockType.Size);                      foreach (var stream in mFileSets)                          for (int i = 0; i < stream.Files.Length - 1; i++)                              WriteNumber(writer' stream.Files[i].Size);                      WriteNumber(writer' BlockType.End);                      WriteNumber(writer' BlockType.End);                  }                    WriteNumber(writer' BlockType.FilesInfo);                  WriteNumber(writer' files.Length);                    WriteNumber(writer' BlockType.Name);                  WriteNumber(writer' 1 + files.Sum(file => file.Name.Length + 1) * 2);                  writer.Write((byte)0); // inline names                  for (int i = 0; i < files.Length; i++)                  {                      string name = files[i].Name;                      for (int j = 0; j < name.Length; j++)                          writer.Write(name[j]);                      writer.Write('\0');                  }                    /* had to disable empty streams and files because above BlockType.Size doesn't respect them                   * if a file is marked as empty stream it doesn't get a size/hash entry in the coder header above                   * however' to fix that' we'd need to skip coders with only empty files too' so its easier to do it this way for now                  if(files.Any(file => file.Size == 0))                  {                      int emptyStreams = 0;                        WriteNumber(writer' BlockType.EmptyStream);                      WriteNumber(writer' (files.Length + 7) / 8);                      for(int i = 0; i < files.Length; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                          {                              if(i + j < files.Length && files[i + j].Size == 0)                              {                                  mask |= 1 << (7 - j);                                  emptyStreams++;                              }                          }                          writer.Write((byte)mask);                      }                        WriteNumber(writer' BlockType.EmptyFile);                      WriteNumber(writer' (emptyStreams + 7) / 8);                      for(int i = 0; i < emptyStreams; i += 8)                      {                          int mask = 0;                          for(int j = 0; j < 8; j++)                              if(i + j < emptyStreams)                                  mask |= 1 << (7 - j);                          writer.Write((byte)mask);                      }                  }                  */                    int ctimeCount = files.Count(file => file.CTime.HasValue);                  if (ctimeCount != 0)                  {                      WriteNumber(writer' BlockType.CTime);                        if (ctimeCount == files.Length)                      {                          WriteNumber(writer' 2 + ctimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (ctimeCount + 7) / 8 + 2 + ctimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].CTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].CTime.HasValue)                              writer.Write(files[i].CTime.Value.ToFileTimeUtc());                  }                    int atimeCount = files.Count(file => file.ATime.HasValue);                  if (atimeCount != 0)                  {                      WriteNumber(writer' BlockType.ATime);                        if (atimeCount == files.Length)                      {                          WriteNumber(writer' 2 + atimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (atimeCount + 7) / 8 + 2 + atimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].ATime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].ATime.HasValue)                              writer.Write(files[i].ATime.Value.ToFileTimeUtc());                  }                    int mtimeCount = files.Count(file => file.MTime.HasValue);                  if (mtimeCount != 0)                  {                      WriteNumber(writer' BlockType.MTime);                        if (mtimeCount == files.Length)                      {                          WriteNumber(writer' 2 + mtimeCount * 8);                          writer.Write((byte)1);                      }                      else                      {                          WriteNumber(writer' (mtimeCount + 7) / 8 + 2 + mtimeCount * 8);                          writer.Write((byte)0);                            for (int i = 0; i < files.Length; i += 8)                          {                              int mask = 0;                              for (int j = 0; j < 8; j++)                                  if (i + j < files.Length && files[i + j].MTime.HasValue)                                      mask |= 1 << (7 - j);                                writer.Write((byte)mask);                          }                      }                        writer.Write((byte)0); // inline data                        for (int i = 0; i < files.Length; i++)                          if (files[i].MTime.HasValue)                              writer.Write(files[i].MTime.Value.ToFileTimeUtc());                  }                    WriteNumber(writer' BlockType.End);                    uint headerCRC = headerStream.Finish();                  long headerSize = mFileStream.Position - headerOffset;                  mFileStream.Position = mFileOrigin + 8;                  WriteHeaderInfo(new BinaryWriter(mFileStream' Encoding.Unicode)' headerOffset - mFileOrigin - 0x20' headerSize' headerCRC);              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: return 1024;
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: const int kMaxNumberLen = 9;
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,ArchiveWriter,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,CalculateHeaderLimit,The following statement contains a magic number: if (files.Length != 0)              {                  limit += kBlockTypeLen; // BlockType.Header                    var inputStreams = mFileSets.SelectMany(fileset => fileset.InputStreams).ToArray();                  if (inputStreams.Any(stream => stream.Size != 0))                  {                      limit += kBlockTypeLen; // BlockType.MainStreamsInfo                      limit += kBlockTypeLen; // BlockType.PackInfo                      limit += kZeroNumberLen; // zero = offset to input streams                      limit += kMaxNumberLen; // inputStreams.Length                      limit += kBlockTypeLen; //BlockType.Size                      limit += inputStreams.Length * kMaxNumberLen; // inputStreams: inputStream.Size                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.UnpackInfo                      limit += kBlockTypeLen; // BlockType.Folder                      limit += kMaxNumberLen; // mFileSets.Count                      limit += kZeroNumberLen; // zero = inline data                      foreach (var fileset in mFileSets)                      {                          limit += kMaxNumberLen; // fileset.Coders.Length                          foreach (var coder in fileset.Coders)                          {                              limit += 1; // flags                              limit += coder.MethodId.GetLength(); // coder.MethodId                                if (coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                              {                                  limit += kMaxNumberLen; // coder.InputStreams.Length                                  limit += kMaxNumberLen; // coder.OutputStreams.Length                              }                                if (coder.Settings != null)                              {                                  limit += kMaxNumberLen; // coder.Settings.Length                                  limit += coder.Settings.Length; // coder.Settings                              }                                // TODO: Bind pairs and association to streams ...                              if (fileset.Coders.Length > 1 || coder.InputStreams.Length != 1 || coder.OutputStreams.Length != 1)                                  throw new NotSupportedException();                          }                      }                      limit += kBlockTypeLen; // BlockType.CodersUnpackSize                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: fileset.DataStream.GetSize(fileset)                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.SubStreamsInfo                      limit += kBlockTypeLen; // BlockType.NumUnpackStream                      limit += mFileSets.Count * kMaxNumberLen; // mFileSets: stream.Files.Length                      limit += kBlockTypeLen; // BlockType.Size                      limit += mFileSets.Sum(fileset => fileset.Files.Length - 1) * kMaxNumberLen; // mFileSets: fileset.Files[0..n-1]: stream.Files[i].Size                      limit += kBlockTypeLen; // BlockType.CRC                      limit += 1 + ((mFileSets.Count + 7) / 8) + mFileSets.Count * 4; // flag + bitmask + crc list                      limit += kBlockTypeLen; // BlockType.End                      limit += kBlockTypeLen; // BlockType.End                  }                    limit += kBlockTypeLen; // BlockType.FilesInfo                  limit += kMaxNumberLen; // files.Length                    limit += kBlockTypeLen; // BlockType.Name                  limit += kMaxNumberLen; // 1 + files.Sum(file => file.Name.Length + 1) * 2                  limit += kZeroNumberLen; // zero = inline names                  for (int i = 0; i < files.Length; i++)                      limit += (files[i].Name.Length + 1) * 2;                    if (files.Any(file => file.Size == 0))                  {                      limit += kBlockTypeLen; // BlockType.EmptyStream                      limit += kMaxNumberLen; // (files.Length + 7) / 8                      limit += (files.Length + 7) / 8; // bit vector                      limit += kBlockTypeLen; // BlockType.EmptyFile                      limit += kMaxNumberLen; // (files.Length + 7) / 8 -- this is an upper bound' for an exact size we need to count the number of empty streams                      limit += (files.Length + 7) / 8; // bit vector                  }                    limit += kBlockTypeLen; // BlockType.CTime                  limit += kMaxNumberLen; // (ctimeCount + 7) / 8 + 2 + ctimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.ATime                  limit += kMaxNumberLen; // (atimeCount + 7) / 8 + 2 + atimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.MTime                  limit += kMaxNumberLen; // (mtimeCount + 7) / 8 + 2 + mtimeCount * 8;                  limit += (files.Length + 7) / 8 + 2 + files.Length * 8;                    limit += kBlockTypeLen; // BlockType.End              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,AESEncryptionProvider,The following statement contains a magic number: mNumCyclesPower = 19;
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,AESEncryptionProvider,The following statement contains a magic number: mSeed = new byte[8];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,AESEncryptionProvider,The following statement contains a magic number: mSeed16 = new byte[16];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,GetCoderInfo,The following statement contains a magic number: writer.Write((byte)(mNumCyclesPower | ((mSalt.Length == 0 ? 0 : 1) << 7) | ((mSeed.Length == 0 ? 0 : 1) << 6)));
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,GetCoderInfo,The following statement contains a magic number: writer.Write((byte)(mNumCyclesPower | ((mSalt.Length == 0 ? 0 : 1) << 7) | ((mSeed.Length == 0 ? 0 : 1) << 6)));
Magic Number,ManagedLzma.LZMA.Master.SevenZip,AESEncryptionProvider,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,GetCoderInfo,The following statement contains a magic number: if (mSalt.Length > 0 || mSeed.Length > 0)              {                  var saltSize = mSalt.Length == 0 ? 0 : mSalt.Length - 1;                  var seedSize = mSeed.Length == 0 ? 0 : mSeed.Length - 1;                  writer.Write((byte)((saltSize << 4) | seedSize));              }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,EncryptBlock,The following statement contains a magic number: while (length > 0)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          mOutput.Write(mBuffer2' 0' 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      offset += copy;                      length -= copy;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,EncryptBlock,The following statement contains a magic number: while (length > 0)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          mOutput.Write(mBuffer2' 0' 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      offset += copy;                      length -= copy;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,EncryptBlock,The following statement contains a magic number: while (length > 0)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          mOutput.Write(mBuffer2' 0' 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      offset += copy;                      length -= copy;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,EncryptBlock,The following statement contains a magic number: while (length > 0)                  {                      if (mOffset == 16)                      {                          mEncoder.TransformBlock(mBuffer1' 0' 16' mBuffer2' 0);                          mOutput.Write(mBuffer2' 0' 16);                          mOffset = 0;                      }                        int copy = Math.Min(16 - mOffset' length);                      Buffer.BlockCopy(buffer' offset' mBuffer1' mOffset' copy);                      mOffset += copy;                      offset += copy;                      length -= copy;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishEncryption,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      mOutput.Write(mBuffer2' 0' 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishEncryption,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      mOutput.Write(mBuffer2' 0' 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishEncryption,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      mOutput.Write(mBuffer2' 0' 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,EncryptedStream,C:\repos\weltkante_managed-lzma\master\7zip\ArchiveWriter.cs,FinishEncryption,The following statement contains a magic number: if (mOffset != 0)                  {                      while (mOffset < 16)                          mBuffer1[mOffset++] = 0;                        Debug.Assert(mOffset == 16);                      mBuffer2 = mEncoder.TransformFinalBlock(mBuffer1' 0' 16);                      mOutput.Write(mBuffer2' 0' 16);                      mOffset = 0;                  }
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,BitVector,The following statement contains a magic number: mBits = new uint[(length + 31) >> 5];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,BitVector,The following statement contains a magic number: mBits = new uint[(length + 31) >> 5];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,BitVector,The following statement contains a magic number: mBits = new uint[(length + 31) >> 5];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,BitVector,The following statement contains a magic number: mBits = new uint[(length + 31) >> 5];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,SetBit,The following statement contains a magic number: mBits[index >> 5] |= 1u << (index & 31);
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,SetBit,The following statement contains a magic number: mBits[index >> 5] |= 1u << (index & 31);
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,GetAndSet,The following statement contains a magic number: uint bits = mBits[index >> 5];
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,GetAndSet,The following statement contains a magic number: uint mask = 1u << (index & 31);
Magic Number,ManagedLzma.LZMA.Master.SevenZip,BitVector,C:\repos\weltkante_managed-lzma\master\7zip\BitVector.cs,GetAndSet,The following statement contains a magic number: mBits[index >> 5] |= mask;
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,AesDecoderStream,The following statement contains a magic number: if (((uint)input.Length & 15) != 0)                  throw new NotSupportedException("7z requires AES streams to be properly padded.");
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,AesDecoderStream,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,AesDecoderStream,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Read,The following statement contains a magic number: if (mEnding - mOffset < 16)              {                  Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                  mEnding -= mOffset;                  mOffset = 0;                    do                  {                      int read = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                      if (read == 0)                      {                          // We are not done decoding and have less than 16 bytes.                          throw new EndOfStreamException();                      }                        mEnding += read;                  }                  while (mEnding - mOffset < 16);              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Read,The following statement contains a magic number: if (mEnding - mOffset < 16)              {                  Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                  mEnding -= mOffset;                  mOffset = 0;                    do                  {                      int read = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                      if (read == 0)                      {                          // We are not done decoding and have less than 16 bytes.                          throw new EndOfStreamException();                      }                        mEnding += read;                  }                  while (mEnding - mOffset < 16);              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Read,The following statement contains a magic number: if (count < 16)                  return HandleUnderflow(buffer' offset' count);
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Read,The following statement contains a magic number: int processed = mDecoder.TransformBlock(mBuffer' mOffset' count & ~15' buffer' offset);
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: int saltSize = (bt >> 7) & 1;
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: int ivSize = (bt >> 6) & 1;
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: saltSize += (bt2 >> 4);
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: ivSize += (bt2 & 15);
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: if (info.Length < 2 + saltSize + ivSize)                  throw new InvalidDataException();
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: for (int i = 0; i < saltSize; i++)                  salt[i] = info[i + 2];
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: iv = new byte[16];
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: for (int i = 0; i < ivSize; i++)                  iv[i] = info[i + saltSize + 2];
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,Init,The following statement contains a magic number: if (numCyclesPower > 24)                  throw new NotSupportedException();
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,InitKey,The following statement contains a magic number: if (mNumCyclesPower == 0x3F)              {                  var key = new byte[32];                    int pos;                  for (pos = 0; pos < salt.Length; pos++)                      key[pos] = salt[pos];                  for (int i = 0; i < pass.Length && pos < 32; i++)                      key[pos++] = pass[i];                    return key;              }              else              {                  using (var sha = System.Security.Cryptography.SHA256.Create())                  {                      byte[] counter = new byte[8];                      long numRounds = 1L << mNumCyclesPower;                      for (long round = 0; round < numRounds; round++)                      {                          sha.TransformBlock(salt' 0' salt.Length' null' 0);                          sha.TransformBlock(pass' 0' pass.Length' null' 0);                          sha.TransformBlock(counter' 0' 8' null' 0);                            // This mirrors the counter so we don't have to convert long to byte[] each round.                          // (It also ensures the counter is little endian' which BitConverter does not.)                          for (int i = 0; i < 8; i++)                              if (++counter[i] != 0)                                  break;                      }                        sha.TransformFinalBlock(counter' 0' 0);                      return sha.Hash;                  }              }
Magic Number,master._7zip.Legacy,AesDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\AesDecoderStream.cs,HandleUnderflow,The following statement contains a magic number: if (mUnderflow == 0)              {                  int blockSize = (mEnding - mOffset) & ~15;                  mUnderflow = mDecoder.TransformBlock(mBuffer' mOffset' blockSize' mBuffer' mOffset);              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Bcj2DecoderStream,The following statement contains a magic number: if (streams.Length != 4)                  throw new NotSupportedException();
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Bcj2DecoderStream,The following statement contains a magic number: mJumpStream = streams[2];
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Bcj2DecoderStream,The following statement contains a magic number: mRangeDecoder = new RangeDecoder(streams[3]);
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Bcj2DecoderStream,The following statement contains a magic number: mStatusDecoder = new StatusDecoder[256 + 2];
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Bcj2DecoderStream,The following statement contains a magic number: mStatusDecoder = new StatusDecoder[256 + 2];
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,GetIndex,The following statement contains a magic number: if (b1 == 0xE8)                  return b0;              else if (b1 == 0xE9)                  return 256;              else                  return 257;
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,GetIndex,The following statement contains a magic number: if (b1 == 0xE8)                  return b0;              else if (b1 == 0xE9)                  return 256;              else                  return 257;
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: const uint kBurstSize = (1u << 18);
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,Bcj2DecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Run,The following statement contains a magic number: for (;;)              {                  byte b = 0;                  uint i;                  for (i = 0; i < kBurstSize; i++)                  {                      int tmp = mMainStream.ReadByte();                      if (tmp < 0)                          yield break;                        b = (byte)tmp;                      mWritten++; yield return b;                      if (IsJ(prevByte' b))                          break;                        prevByte = b;                  }                    processedBytes += i;                  if (i == kBurstSize)                      continue;                    if (mStatusDecoder[GetIndex(prevByte' b)].Decode(mRangeDecoder) == 1)                  {                      Stream s = (b == 0xE8) ? mCallStream : mJumpStream;                        uint src = 0;                      for (i = 0; i < 4; i++)                      {                          int b0 = s.ReadByte();                          if (b0 < 0)                              throw new EndOfStreamException();                            src <<= 8;                          src |= (uint)b0;                      }                        uint dest = src - (uint)(mWritten + 4);                      mWritten++; yield return (byte)dest;                      mWritten++; yield return (byte)(dest >> 8);                      mWritten++; yield return (byte)(dest >> 16);                      mWritten++; yield return (byte)(dest >> 24);                      prevByte = (byte)(dest >> 24);                      processedBytes += 4;                  }                  else                  {                      prevByte = b;                  }              }
Magic Number,master._7zip.Legacy,RangeDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,RangeDecoder,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | ReadByte();
Magic Number,master._7zip.Legacy,RangeDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,RangeDecoder,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | ReadByte();
Magic Number,master._7zip.Legacy,StatusDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,StatusDecoder,The following statement contains a magic number: Prob = kBitModelTotal / 2;
Magic Number,master._7zip.Legacy,StatusDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,master._7zip.Legacy,StatusDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,master._7zip.Legacy,StatusDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,master._7zip.Legacy,StatusDecoder,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\Bcj2DecoderStream.cs,Decode,The following statement contains a magic number: if (decoder.Code < newBound)                  {                      decoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      decoder.Range -= newBound;                      decoder.Code -= newBound;                      Prob -= Prob >> numMoveBits;                      if (decoder.Range < kTopValue)                      {                          decoder.Code = (decoder.Code << 8) | decoder.ReadByte();                          decoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,Read,The following statement contains a magic number: while (mEnding - mOffset < 5)              {                  if (mInputEnd)                  {                      // if less than 5 bytes are left they are copied                      int n = 0;                      while (mOffset < mEnding && count > 0)                      {                          buffer[offset++] = mBuffer[mOffset++];                          count--;                          n++;                      }                      return n;                  }                    if (mBuffer.Length - mOffset < 5)                  {                      Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                      mEnding -= mOffset;                      mOffset = 0;                  }                    int delta = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                  if (delta == 0)                      mInputEnd = true;                  else                      mEnding += delta;              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,Read,The following statement contains a magic number: while (mEnding - mOffset < 5)              {                  if (mInputEnd)                  {                      // if less than 5 bytes are left they are copied                      int n = 0;                      while (mOffset < mEnding && count > 0)                      {                          buffer[offset++] = mBuffer[mOffset++];                          count--;                          n++;                      }                      return n;                  }                    if (mBuffer.Length - mOffset < 5)                  {                      Buffer.BlockCopy(mBuffer' mOffset' mBuffer' 0' mEnding - mOffset);                      mEnding -= mOffset;                      mOffset = 0;                  }                    int delta = mStream.Read(mBuffer' mEnding' mBuffer.Length - mEnding);                  if (delta == 0)                      mInputEnd = true;                  else                      mEnding += delta;              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: if (size < 5)                  return 0;
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: ip += 5;
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: for (;;)              {                  byte* p = data + bufferPos;                  byte* limit = data + size - 4;                    while (p < limit && (*p & 0xFE) != 0xE8)                      p++;                    bufferPos = (int)(p - data);                  if (p >= limit)                      break;                    prevPosT = bufferPos - prevPosT;                    if (prevPosT > 3)                  {                      prevMask = 0;                  }                  else                  {                      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;                      if (prevMask != 0)                      {                          byte b = p[4 - kMaskToBitNumber[prevMask]];                          if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))                          {                              prevPosT = bufferPos;                              prevMask = ((prevMask << 1) & 0x7) | 1;                              bufferPos++;                              continue;                          }                      }                  }                    prevPosT = bufferPos;                    if (Test86MSByte(p[4]))                  {                      uint src = ((uint)p[4] << 24) | ((uint)p[3] << 16) | ((uint)p[2] << 8) | ((uint)p[1]);                      uint dest;                      for (;;)                      {                          dest = src - (ip + (uint)bufferPos);                            if (prevMask == 0)                              break;                            int index = kMaskToBitNumber[prevMask] * 8;                          byte b = (byte)(dest >> (24 - index));                          if (!Test86MSByte(b))                              break;                            src = dest ^ ((1u << (32 - index)) - 1);                      }                        p[4] = (byte)(~(((dest >> 24) & 1) - 1));                      p[3] = (byte)(dest >> 16);                      p[2] = (byte)(dest >> 8);                      p[1] = (byte)dest;                      bufferPos += 5;                  }                  else                  {                      prevMask = ((prevMask << 1) & 0x7) | 1;                      bufferPos++;                  }              }
Magic Number,master._7zip.Legacy,BcjDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\BcjDecoderStream.cs,x86_Convert,The following statement contains a magic number: mState = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
Magic Number,master._7zip.Legacy,LzmaDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\LzmaDecoderStream.cs,LzmaDecoderStream,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,master._7zip.Legacy,LzmaDecoderStream,C:\repos\weltkante_managed-lzma\master\7zip\Decoder\LzmaDecoderStream.cs,LzmaDecoderStream,The following statement contains a magic number: mBuffer = new byte[4 << 10];
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get32,The following statement contains a magic number: return (uint)buffer[offset]                  + ((uint)buffer[offset + 1] << 8)                  + ((uint)buffer[offset + 2] << 16)                  + ((uint)buffer[offset + 3] << 24);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get32,The following statement contains a magic number: return (uint)buffer[offset]                  + ((uint)buffer[offset + 1] << 8)                  + ((uint)buffer[offset + 2] << 16)                  + ((uint)buffer[offset + 3] << 24);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get32,The following statement contains a magic number: return (uint)buffer[offset]                  + ((uint)buffer[offset + 1] << 8)                  + ((uint)buffer[offset + 2] << 16)                  + ((uint)buffer[offset + 3] << 24);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get32,The following statement contains a magic number: return (uint)buffer[offset]                  + ((uint)buffer[offset + 1] << 8)                  + ((uint)buffer[offset + 2] << 16)                  + ((uint)buffer[offset + 3] << 24);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get32,The following statement contains a magic number: return (uint)buffer[offset]                  + ((uint)buffer[offset + 1] << 8)                  + ((uint)buffer[offset + 2] << 16)                  + ((uint)buffer[offset + 3] << 24);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Get64,The following statement contains a magic number: return (ulong)buffer[offset]                  + ((ulong)buffer[offset + 1] << 8)                  + ((ulong)buffer[offset + 2] << 16)                  + ((ulong)buffer[offset + 3] << 24)                  + ((ulong)buffer[offset + 4] << 32)                  + ((ulong)buffer[offset + 5] << 40)                  + ((ulong)buffer[offset + 6] << 48)                  + ((ulong)buffer[offset + 7] << 56);
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  if ((firstByte & mask) == 0)                  {                      ulong highPart = firstByte & (mask - 1u);                      value += highPart << (i * 8);                      return value;                  }                    if (_offset >= _ending)                      throw new EndOfStreamException();                    value |= (ulong)_buffer[_offset++] << (8 * i);                  mask >>= 1;              }
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  if ((firstByte & mask) == 0)                  {                      ulong highPart = firstByte & (mask - 1u);                      value += highPart << (i * 8);                      return value;                  }                    if (_offset >= _ending)                      throw new EndOfStreamException();                    value |= (ulong)_buffer[_offset++] << (8 * i);                  mask >>= 1;              }
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadNumber,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  if ((firstByte & mask) == 0)                  {                      ulong highPart = firstByte & (mask - 1u);                      value += highPart << (i * 8);                      return value;                  }                    if (_offset >= _ending)                      throw new EndOfStreamException();                    value |= (ulong)_buffer[_offset++] << (8 * i);                  mask >>= 1;              }
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadUInt32,The following statement contains a magic number: if (_offset + 4 > _ending)                  throw new EndOfStreamException();
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadUInt32,The following statement contains a magic number: _offset += 4;
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadUInt64,The following statement contains a magic number: if (_offset + 8 > _ending)                  throw new EndOfStreamException();
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadUInt64,The following statement contains a magic number: _offset += 8;
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadString,The following statement contains a magic number: for (;;)              {                  if (ending + 2 > _ending)                      throw new EndOfStreamException();                    if (_buffer[ending] == 0 && _buffer[ending + 1] == 0)                      break;                    ending += 2;              }
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadString,The following statement contains a magic number: for (;;)              {                  if (ending + 2 > _ending)                      throw new EndOfStreamException();                    if (_buffer[ending] == 0 && _buffer[ending + 1] == 0)                      break;                    ending += 2;              }
Magic Number,master._7zip.Legacy,DataReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadString,The following statement contains a magic number: _offset = ending + 2;
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadId,The following statement contains a magic number: if (id > 25)                  return null;
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,GetNextFolderItem,The following statement contains a magic number: try              {                  int numCoders = ReadNum();                  Log.WriteLine("NumCoders: " + numCoders);                    folder.Coders = new List<CCoderInfo>(numCoders);                  int numInStreams = 0;                  int numOutStreams = 0;                  for (int i = 0; i < numCoders; i++)                  {                      Log.WriteLine("-- Coder --");                      Log.PushIndent();                      try                      {                          CCoderInfo coder = new CCoderInfo();                          folder.Coders.Add(coder);                            byte mainByte = ReadByte();                          int idSize = (mainByte & 0xF);                          byte[] longID = new byte[idSize];                          ReadBytes(longID' 0' idSize);                          Log.WriteLine("MethodId: " + String.Join(""' Enumerable.Range(0' idSize).Select(x => longID[x].ToString("x2"))));                          if (idSize > 8)                              throw new NotSupportedException();                          ulong id = 0;                          for (int j = 0; j < idSize; j++)                              id |= (ulong)longID[idSize - 1 - j] << (8 * j);                          coder.MethodId = new CMethodId(id);                            if ((mainByte & 0x10) != 0)                          {                              coder.NumInStreams = ReadNum();                              coder.NumOutStreams = ReadNum();                              Log.WriteLine("Complex Stream (In: " + coder.NumInStreams + " - Out: " + coder.NumOutStreams + ")");                          }                          else                          {                              Log.WriteLine("Simple Stream (In: 1 - Out: 1)");                              coder.NumInStreams = 1;                              coder.NumOutStreams = 1;                          }                            if ((mainByte & 0x20) != 0)                          {                              int propsSize = ReadNum();                              coder.Props = new byte[propsSize];                              ReadBytes(coder.Props' 0' propsSize);                              Log.WriteLine("Settings: " + String.Join(""' coder.Props.Select(bt => bt.ToString("x2"))));                          }                            if ((mainByte & 0x80) != 0)                              throw new NotSupportedException();                            numInStreams += coder.NumInStreams;                          numOutStreams += coder.NumOutStreams;                      }                      finally { Log.PopIndent(); }                  }                    int numBindPairs = numOutStreams - 1;                  folder.BindPairs = new List<CBindPair>(numBindPairs);                  Log.WriteLine("BindPairs: " + numBindPairs);                  Log.PushIndent();                  for (int i = 0; i < numBindPairs; i++)                  {                      CBindPair bp = new CBindPair();                      bp.InIndex = ReadNum();                      bp.OutIndex = ReadNum();                      folder.BindPairs.Add(bp);                      Log.WriteLine("#" + i + " - In: " + bp.InIndex + " - Out: " + bp.OutIndex);                  }                  Log.PopIndent();                    if (numInStreams < numBindPairs)                      throw new NotSupportedException();                    int numPackStreams = numInStreams - numBindPairs;                  //folder.PackStreams.Reserve(numPackStreams);                  if (numPackStreams == 1)                  {                      for (int i = 0; i < numInStreams; i++)                      {                          if (folder.FindBindPairForInStream(i) < 0)                          {                              Log.WriteLine("Single PackStream: #" + i);                              folder.PackStreams.Add(i);                              break;                          }                      }                        if (folder.PackStreams.Count != 1)                          throw new NotSupportedException();                  }                  else                  {                      Log.WriteLine("Multiple PackStreams ...");                      Log.PushIndent();                      for (int i = 0; i < numPackStreams; i++)                      {                          var num = ReadNum();                          Log.WriteLine("#" + i + " - " + num);                          folder.PackStreams.Add(num);                      }                      Log.PopIndent();                  }              }              finally              {                  Log.PopIndent();              }
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,GetNextFolderItem,The following statement contains a magic number: try              {                  int numCoders = ReadNum();                  Log.WriteLine("NumCoders: " + numCoders);                    folder.Coders = new List<CCoderInfo>(numCoders);                  int numInStreams = 0;                  int numOutStreams = 0;                  for (int i = 0; i < numCoders; i++)                  {                      Log.WriteLine("-- Coder --");                      Log.PushIndent();                      try                      {                          CCoderInfo coder = new CCoderInfo();                          folder.Coders.Add(coder);                            byte mainByte = ReadByte();                          int idSize = (mainByte & 0xF);                          byte[] longID = new byte[idSize];                          ReadBytes(longID' 0' idSize);                          Log.WriteLine("MethodId: " + String.Join(""' Enumerable.Range(0' idSize).Select(x => longID[x].ToString("x2"))));                          if (idSize > 8)                              throw new NotSupportedException();                          ulong id = 0;                          for (int j = 0; j < idSize; j++)                              id |= (ulong)longID[idSize - 1 - j] << (8 * j);                          coder.MethodId = new CMethodId(id);                            if ((mainByte & 0x10) != 0)                          {                              coder.NumInStreams = ReadNum();                              coder.NumOutStreams = ReadNum();                              Log.WriteLine("Complex Stream (In: " + coder.NumInStreams + " - Out: " + coder.NumOutStreams + ")");                          }                          else                          {                              Log.WriteLine("Simple Stream (In: 1 - Out: 1)");                              coder.NumInStreams = 1;                              coder.NumOutStreams = 1;                          }                            if ((mainByte & 0x20) != 0)                          {                              int propsSize = ReadNum();                              coder.Props = new byte[propsSize];                              ReadBytes(coder.Props' 0' propsSize);                              Log.WriteLine("Settings: " + String.Join(""' coder.Props.Select(bt => bt.ToString("x2"))));                          }                            if ((mainByte & 0x80) != 0)                              throw new NotSupportedException();                            numInStreams += coder.NumInStreams;                          numOutStreams += coder.NumOutStreams;                      }                      finally { Log.PopIndent(); }                  }                    int numBindPairs = numOutStreams - 1;                  folder.BindPairs = new List<CBindPair>(numBindPairs);                  Log.WriteLine("BindPairs: " + numBindPairs);                  Log.PushIndent();                  for (int i = 0; i < numBindPairs; i++)                  {                      CBindPair bp = new CBindPair();                      bp.InIndex = ReadNum();                      bp.OutIndex = ReadNum();                      folder.BindPairs.Add(bp);                      Log.WriteLine("#" + i + " - In: " + bp.InIndex + " - Out: " + bp.OutIndex);                  }                  Log.PopIndent();                    if (numInStreams < numBindPairs)                      throw new NotSupportedException();                    int numPackStreams = numInStreams - numBindPairs;                  //folder.PackStreams.Reserve(numPackStreams);                  if (numPackStreams == 1)                  {                      for (int i = 0; i < numInStreams; i++)                      {                          if (folder.FindBindPairForInStream(i) < 0)                          {                              Log.WriteLine("Single PackStream: #" + i);                              folder.PackStreams.Add(i);                              break;                          }                      }                        if (folder.PackStreams.Count != 1)                          throw new NotSupportedException();                  }                  else                  {                      Log.WriteLine("Multiple PackStreams ...");                      Log.PushIndent();                      for (int i = 0; i < numPackStreams; i++)                      {                          var num = ReadNum();                          Log.WriteLine("#" + i + " - " + num);                          folder.PackStreams.Add(num);                      }                      Log.PopIndent();                  }              }              finally              {                  Log.PopIndent();              }
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadHeader,The following statement contains a magic number: try              {                  BlockType? type = ReadId();                    if (type == BlockType.ArchiveProperties)                  {                      ReadArchiveProperties();                      type = ReadId();                  }                    List<byte[]> dataVector = null;                  if (type == BlockType.AdditionalStreamsInfo)                  {                      dataVector = ReadAndDecodePackedStreams(db.StartPositionAfterHeader' getTextPassword);                      type = ReadId();                  }                    List<long> unpackSizes;                  List<uint?> digests;                    if (type == BlockType.MainStreamsInfo)                  {                      ReadStreamsInfo(dataVector'                          out db.DataStartPosition'                          out db.PackSizes'                          out db.PackCRCs'                          out db.Folders'                          out db.NumUnpackStreamsVector'                          out unpackSizes'                          out digests);                        db.DataStartPosition += db.StartPositionAfterHeader;                      type = ReadId();                  }                  else                  {                      unpackSizes = new List<long>(db.Folders.Count);                      digests = new List<uint?>(db.Folders.Count);                      db.NumUnpackStreamsVector = new List<int>(db.Folders.Count);                      for (int i = 0; i < db.Folders.Count; i++)                      {                          var folder = db.Folders[i];                          unpackSizes.Add(folder.GetUnpackSize());                          digests.Add(folder.UnpackCRC);                          db.NumUnpackStreamsVector.Add(1);                      }                  }                    db.Files.Clear();                    if (type == BlockType.End)                      return;                    if (type != BlockType.FilesInfo)                      throw new InvalidDataException();                    int numFiles = ReadNum();                  Log.WriteLine("NumFiles: " + numFiles);                  db.Files = new List<CFileItem>(numFiles);                  for (int i = 0; i < numFiles; i++)                      db.Files.Add(new CFileItem());                    BitVector emptyStreamVector = new BitVector(numFiles);                  BitVector emptyFileVector = null;                  BitVector antiFileVector = null;                  int numEmptyStreams = 0;                    for (;;)                  {                      type = ReadId();                      if (type == BlockType.End)                          break;                        long size = checked((long)ReadNumber()); // TODO: throw invalid data on negative                      int oldPos = _currentReader.Offset;                      switch (type)                      {                          case BlockType.Name:                              using (var streamSwitch = new CStreamSwitch())                              {                                  streamSwitch.Set(this' dataVector);                                  Log.Write("FileNames:");                                  for (int i = 0; i < db.Files.Count; i++)                                  {                                      db.Files[i].Name = _currentReader.ReadString();                                      Log.Write("  " + db.Files[i].Name);                                  }                                  Log.WriteLine();                              }                              break;                          case BlockType.WinAttributes:                              Log.Write("WinAttributes:");                              ReadAttributeVector(dataVector' numFiles' delegate (int i' uint? attr)                              {                                  db.Files[i].Attrib = attr;                                  Log.Write("  " + (attr.HasValue ? attr.Value.ToString("x8") : "n/a"));                              });                              Log.WriteLine();                              break;                          case BlockType.EmptyStream:                              emptyStreamVector = ReadBitVector(numFiles);                                Log.Write("EmptyStream: ");                              for (int i = 0; i < emptyStreamVector.Length; i++)                              {                                  if (emptyStreamVector[i])                                  {                                      Log.Write("x");                                      numEmptyStreams++;                                  }                                  else                                  {                                      Log.Write(".");                                  }                              }                              Log.WriteLine();                                emptyFileVector = new BitVector(numEmptyStreams);                              antiFileVector = new BitVector(numEmptyStreams);                              break;                          case BlockType.EmptyFile:                              emptyFileVector = ReadBitVector(numEmptyStreams);                              Log.Write("EmptyFile: ");                              for (int i = 0; i < numEmptyStreams; i++)                                  Log.Write(emptyFileVector[i] ? "x" : ".");                              Log.WriteLine();                              break;                          case BlockType.Anti:                              antiFileVector = ReadBitVector(numEmptyStreams);                              Log.Write("Anti: ");                              for (int i = 0; i < numEmptyStreams; i++)                                  Log.Write(antiFileVector[i] ? "x" : ".");                              Log.WriteLine();                              break;                          case BlockType.StartPos:                              Log.Write("StartPos:");                              ReadNumberVector(dataVector' numFiles' delegate (int i' long? startPos)                              {                                  db.Files[i].StartPos = startPos;                                  Log.Write("  " + (startPos.HasValue ? startPos.Value.ToString() : "n/a"));                              });                              Log.WriteLine();                              break;                          case BlockType.CTime:                              Log.Write("CTime:");                              ReadDateTimeVector(dataVector' numFiles' delegate (int i' DateTime? time)                              {                                  db.Files[i].CTime = time;                                  Log.Write("  " + (time.HasValue ? time.Value.ToString() : "n/a"));                              });                              Log.WriteLine();                              break;                          case BlockType.ATime:                              Log.Write("ATime:");                              ReadDateTimeVector(dataVector' numFiles' delegate (int i' DateTime? time)                              {                                  db.Files[i].ATime = time;                                  Log.Write("  " + (time.HasValue ? time.Value.ToString() : "n/a"));                              });                              Log.WriteLine();                              break;                          case BlockType.MTime:                              Log.Write("MTime:");                              ReadDateTimeVector(dataVector' numFiles' delegate (int i' DateTime? time)                              {                                  db.Files[i].MTime = time;                                  Log.Write("  " + (time.HasValue ? time.Value.ToString() : "n/a"));                              });                              Log.WriteLine();                              break;                          case BlockType.Dummy:                              Log.Write("Dummy: " + size);                              for (long j = 0; j < size; j++)                                  if (ReadByte() != 0)                                      throw new InvalidDataException();                              break;                          default:                              SkipData(size);                              break;                      }                        // since 0.3 record sizes must be correct                      bool checkRecordsSize = (db.MajorVersion > 0 || db.MinorVersion > 2);                      if (checkRecordsSize && _currentReader.Offset - oldPos != size)                          throw new InvalidDataException();                  }                    int emptyFileIndex = 0;                  int sizeIndex = 0;                  for (int i = 0; i < numFiles; i++)                  {                      CFileItem file = db.Files[i];                      file.HasStream = !emptyStreamVector[i];                      if (file.HasStream)                      {                          file.IsDir = false;                          file.IsAnti = false;                          file.Size = unpackSizes[sizeIndex];                          file.Crc = digests[sizeIndex];                          sizeIndex++;                      }                      else                      {                          file.IsDir = !emptyFileVector[emptyFileIndex];                          file.IsAnti = antiFileVector[emptyFileIndex];                          emptyFileIndex++;                          file.Size = 0;                          file.Crc = null;                      }                  }              }              finally { Log.PopIndent(); }
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadDatabase,The following statement contains a magic number: db.MajorVersion = _header[6];
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadDatabase,The following statement contains a magic number: db.MinorVersion = _header[7];
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,ReadDatabase,The following statement contains a magic number: uint crcFromArchive = DataReader.Get32(_header' 8);
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Extract,The following statement contains a magic number: foreach (CExtractFolderInfo efi in extractFolderInfoVector)              {                  int startIndex;                  if (efi.FileIndex != -1)                      startIndex = efi.FileIndex;                  else                      startIndex = _db.FolderStartFileIndex[efi.FolderIndex];                    var outStream = new FolderUnpackStream(_db' 0' startIndex' efi.ExtractStatuses);                    if (efi.FileIndex != -1)                      continue;                    int folderIndex = efi.FolderIndex;                  CFolder folderInfo = _db.Folders[folderIndex];                    int packStreamIndex = _db.Folders[folderIndex].FirstPackStreamId;                  long folderStartPackPos = _db.GetFolderStreamPos(folderIndex' 0);                    List<long> packSizes = new List<long>();                  for (int j = 0; j < folderInfo.PackStreams.Count; j++)                      packSizes.Add(_db.PackSizes[packStreamIndex + j]);                    // TODO: If the decoding fails the last file may be extracted incompletely. Delete it?                    Stream s = DecoderStreamHelper.CreateDecoderStream(_stream' folderStartPackPos' packSizes.ToArray()' folderInfo' pw);                  byte[] buffer = new byte[4 << 10];                  for (;;)                  {                      int processed = s.Read(buffer' 0' buffer.Length);                      if (processed == 0) break;                      outStream.Write(buffer' 0' processed);                  }              }
Magic Number,master._7zip.Legacy,ArchiveReader,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Archive.cs,Extract,The following statement contains a magic number: foreach (CExtractFolderInfo efi in extractFolderInfoVector)              {                  int startIndex;                  if (efi.FileIndex != -1)                      startIndex = efi.FileIndex;                  else                      startIndex = _db.FolderStartFileIndex[efi.FolderIndex];                    var outStream = new FolderUnpackStream(_db' 0' startIndex' efi.ExtractStatuses);                    if (efi.FileIndex != -1)                      continue;                    int folderIndex = efi.FolderIndex;                  CFolder folderInfo = _db.Folders[folderIndex];                    int packStreamIndex = _db.Folders[folderIndex].FirstPackStreamId;                  long folderStartPackPos = _db.GetFolderStreamPos(folderIndex' 0);                    List<long> packSizes = new List<long>();                  for (int j = 0; j < folderInfo.PackStreams.Count; j++)                      packSizes.Add(_db.PackSizes[packStreamIndex + j]);                    // TODO: If the decoding fails the last file may be extracted incompletely. Delete it?                    Stream s = DecoderStreamHelper.CreateDecoderStream(_stream' folderStartPackPos' packSizes.ToArray()' folderInfo' pw);                  byte[] buffer = new byte[4 << 10];                  for (;;)                  {                      int processed = s.Read(buffer' 0' buffer.Length);                      if (processed == 0) break;                      outStream.Write(buffer' 0' processed);                  }              }
Magic Number,master._7zip.Legacy,CMethodId,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Item.cs,GetLength,The following statement contains a magic number: for (ulong value = Id; value != 0; value >>= 8)                  bytes++;
Magic Number,master._7zip.Legacy,CFolder,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Item.cs,CheckStructure,The following statement contains a magic number: const int kNumCodersMax = 32;
Magic Number,master._7zip.Legacy,CFolder,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Item.cs,CheckStructure,The following statement contains a magic number: const int kMaskSize = 32;
Magic Number,master._7zip.Legacy,CFolder,C:\repos\weltkante_managed-lzma\master\7zip\Legacy\Item.cs,CheckStructure,The following statement contains a magic number: const int kNumBindsMax = 32;
Magic Number,master._7zip.Legacy,CrcCheckStream,C:\repos\weltkante_managed-lzma\master\7zip\Utilities\CrcCheckStream.cs,Dispose,The following statement contains a magic number: try              {                  if (disposing && !mClosed)                  {                      mClosed = true;                      mCurrentCRC = CRC.Finish(mCurrentCRC);  #if DEBUG                      if (mCurrentCRC == mExpectedCRC)                          System.Diagnostics.Debug.WriteLine("CRC ok: " + mExpectedCRC.ToString("x8"));                      else                      {                          System.Diagnostics.Debugger.Break();                          System.Diagnostics.Debug.WriteLine("bad CRC");                      }                        double lengthInv = 1.0 / mLength;                      double entropy = 0;                      for (int i = 0; i < 256; i++)                      {                          if (mBytes[i] != 0)                          {                              double p = lengthInv * mBytes[i];                              entropy -= p * Math.Log(p' 256);                          }                      }                      System.Diagnostics.Debug.WriteLine("entropy: " + (int)(entropy * 100) + "%");  #endif                  }              }              finally              {                  base.Dispose(disposing);              }
Magic Number,master._7zip.Legacy,CrcCheckStream,C:\repos\weltkante_managed-lzma\master\7zip\Utilities\CrcCheckStream.cs,Dispose,The following statement contains a magic number: try              {                  if (disposing && !mClosed)                  {                      mClosed = true;                      mCurrentCRC = CRC.Finish(mCurrentCRC);  #if DEBUG                      if (mCurrentCRC == mExpectedCRC)                          System.Diagnostics.Debug.WriteLine("CRC ok: " + mExpectedCRC.ToString("x8"));                      else                      {                          System.Diagnostics.Debugger.Break();                          System.Diagnostics.Debug.WriteLine("bad CRC");                      }                        double lengthInv = 1.0 / mLength;                      double entropy = 0;                      for (int i = 0; i < 256; i++)                      {                          if (mBytes[i] != 0)                          {                              double p = lengthInv * mBytes[i];                              entropy -= p * Math.Log(p' 256);                          }                      }                      System.Diagnostics.Debug.WriteLine("entropy: " + (int)(entropy * 100) + "%");  #endif                  }              }              finally              {                  base.Dispose(disposing);              }
Magic Number,master._7zip.Legacy,CrcCheckStream,C:\repos\weltkante_managed-lzma\master\7zip\Utilities\CrcCheckStream.cs,Dispose,The following statement contains a magic number: try              {                  if (disposing && !mClosed)                  {                      mClosed = true;                      mCurrentCRC = CRC.Finish(mCurrentCRC);  #if DEBUG                      if (mCurrentCRC == mExpectedCRC)                          System.Diagnostics.Debug.WriteLine("CRC ok: " + mExpectedCRC.ToString("x8"));                      else                      {                          System.Diagnostics.Debugger.Break();                          System.Diagnostics.Debug.WriteLine("bad CRC");                      }                        double lengthInv = 1.0 / mLength;                      double entropy = 0;                      for (int i = 0; i < 256; i++)                      {                          if (mBytes[i] != 0)                          {                              double p = lengthInv * mBytes[i];                              entropy -= p * Math.Log(p' 256);                          }                      }                      System.Diagnostics.Debug.WriteLine("entropy: " + (int)(entropy * 100) + "%");  #endif                  }              }              finally              {                  base.Dispose(disposing);              }
