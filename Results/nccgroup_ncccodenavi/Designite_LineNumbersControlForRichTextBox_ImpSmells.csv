Implementation smell,Namespace,Class,File,Method,Description
Long Method,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The method has 207 lines of code.
Long Method,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The method has 108 lines of code.
Complex Method,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,Cyclomatic complexity of the method is 10
Long Identifier,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,,The length of the parameter pLineNumbersClipByItemRectangle is 31.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The length of the statement  "							// The GraphicsPath for the LineNumber is just a rectangle behind the text' to keep the paintingspeed high and avoid ugly artifacts. " is 132.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The length of the statement  "					// Grid lines thickness and linestyle in SeeThroughMode. All GraphicsPath lines are drawn as solid to keep the paintingspeed high. " is 130.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The length of the statement  "					startIndex = Math.Max(0' Math.Min(RTParent.Text.Length - 1' RTParent.Text.Substring(0' startIndex).LastIndexOf('\n') + 1)); " is 123.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The length of the statement  "						pLineNumberItems[a].Rectangle.Height = Math.Max(1' pLineNumberItems[a + 1].Rectangle.Y - pLineNumberItems[a].Rectangle.Y); " is 122.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The length of the statement  "					pLineNumbersFormat = string.Empty.PadRight(pLineNumbersShowAsHexadecimal ? split.Length.ToString("X").Length : split.Length.ToString().Length' '0'); " is 148.
Long Statement,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,CalculateAutoSizing,The length of the statement  "				// To measure the LineNumber's width' its Format 0 is replaced by w as that is likely to be one of the widest characters in non-monospace fonts. " is 144.
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,LineNumbersForRichText,The following statement contains a magic number: Padding = new Padding(0' 0' 2' 0);
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,LineNumbersForRichText,The following statement contains a magic number: Timer = new Timer { Enabled = false' Interval = 200 };
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,FindStartIndex,The following statement contains a magic number: if(max != (min + 1) && min != (max + min) / 2)  			{  				int pos = RTParent.GetPositionFromCharIndex((max + min) / 2).Y;  				if(pos == target)  				{  					// BestStartIndex found  					min = (max + min) / 2;  				}  				else if(pos > target)  				{  					// Look again' in lower half  					max = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  				else if(pos < 0)  				{  					// Look again' in top half  					min = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,FindStartIndex,The following statement contains a magic number: if(max != (min + 1) && min != (max + min) / 2)  			{  				int pos = RTParent.GetPositionFromCharIndex((max + min) / 2).Y;  				if(pos == target)  				{  					// BestStartIndex found  					min = (max + min) / 2;  				}  				else if(pos > target)  				{  					// Look again' in lower half  					max = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  				else if(pos < 0)  				{  					// Look again' in top half  					min = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,FindStartIndex,The following statement contains a magic number: if(max != (min + 1) && min != (max + min) / 2)  			{  				int pos = RTParent.GetPositionFromCharIndex((max + min) / 2).Y;  				if(pos == target)  				{  					// BestStartIndex found  					min = (max + min) / 2;  				}  				else if(pos > target)  				{  					// Look again' in lower half  					max = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  				else if(pos < 0)  				{  					// Look again' in top half  					min = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,FindStartIndex,The following statement contains a magic number: if(max != (min + 1) && min != (max + min) / 2)  			{  				int pos = RTParent.GetPositionFromCharIndex((max + min) / 2).Y;  				if(pos == target)  				{  					// BestStartIndex found  					min = (max + min) / 2;  				}  				else if(pos > target)  				{  					// Look again' in lower half  					max = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  				else if(pos < 0)  				{  					// Look again' in top half  					min = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,FindStartIndex,The following statement contains a magic number: if(max != (min + 1) && min != (max + min) / 2)  			{  				int pos = RTParent.GetPositionFromCharIndex((max + min) / 2).Y;  				if(pos == target)  				{  					// BestStartIndex found  					min = (max + min) / 2;  				}  				else if(pos > target)  				{  					// Look again' in lower half  					max = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  				else if(pos < 0)  				{  					// Look again' in top half  					min = (max + min) / 2;  					FindStartIndex(ref min' ref max' ref target);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(DesignMode)  			{  				string reminderToShow = string.Empty;  				if(RTParent == null)  				{  					reminderToShow = "-!- Set ParentRichTextBox -!-";  				}  				else if(pLineNumberItems.Count == 0)  				{  					reminderToShow = "LineNumbers (  " + RTParent.Name + "  )";  				}  				if(reminderToShow.Length > 0)  				{  					e.Graphics.TranslateTransform(Width / 2f' Height / 2f);  					e.Graphics.RotateTransform(-90f);  					StringFormat format = new StringFormat { Alignment = StringAlignment.Center' LineAlignment = StringAlignment.Center };  					SizeF textSize = e.Graphics.MeasureString(reminderToShow' Font' new Point(0' 0)' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.WhiteSmoke' 1f' 1f' format);  					e.Graphics.DrawString(reminderToShow' Font' Brushes.Firebrick' 0f' 0f' format);  					e.Graphics.ResetTransform();  					Rectangle reminderRectangle = new Rectangle((int)Math.Round((Width / 2.0) - (textSize.Height / 2.0))'  																 (int)Math.Round((Height / 2.0) - (textSize.Width / 2.0))'  																 (int)Math.Round(textSize.Height)' (int)Math.Round(textSize.Width));  					gpLineNumbers.AddRectangle(reminderRectangle);  					gpLineNumbers.CloseFigure();  					if(pAutoSizing)  					{  						reminderRectangle.Inflate((int)Math.Round(textSize.Height * 0.2)' (int)Math.Round(textSize.Width * 0.1));  						pAutoSizingSize = new Size(reminderRectangle.Width' reminderRectangle.Height);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pLineNumberItems.Count > 0)  			{  				// The visible LineNumberItems with their BackgroundGradient and GridLines  				// Loop through every visible LineNumberItem  				using(Pen pen = new Pen(pGridLinesColor' pGridLinesThickness) { DashStyle = pGridLinesStyle })  				{  					StringFormat format = new StringFormat  					{  						Alignment = StringAlignment.Near'  						LineAlignment = StringAlignment.Near'  						FormatFlags =  							StringFormatFlags.NoClip | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox  					};  					for(int i = 0; i <= pLineNumberItems.Count - 1; i++)  					{  						// Background gradient  						if(pGradientShow)  						{  							using(LinearGradientBrush brush = new LinearGradientBrush(pLineNumberItems[i].Rectangle'  								pGradientStartColor' pGradientEndColor' pGradientDirection))  							{  								e.Graphics.FillRectangle(brush' pLineNumberItems[i].Rectangle);  							}  						}  						// Grid lines  						if(pGridLinesShow)  						{  							e.Graphics.DrawLine(pen' new Point(0' pLineNumberItems[i].Rectangle.Y)'  								new Point(Width' pLineNumberItems[i].Rectangle.Y));  							Rectangle rect = new Rectangle((int)Math.Round(-pGridLinesThickness)' pLineNumberItems[i].Rectangle.Y'  								(int)Math.Round(Width + (pGridLinesThickness * 2.0))'  								(int)Math.Round((Height - pLineNumberItems[0].Rectangle.Y) + pGridLinesThickness));  							gpGridLines.AddRectangle(rect);  							gpGridLines.CloseFigure();  						}  						// Line numbers  						if(pLineNumbersShow)  						{  							string textToShow;  							if(pLineNumbersShowLeadingZeroes)  							{  								textToShow = pLineNumbersShowAsHexadecimal  												? pLineNumberItems[i].LineNumber.ToString("X")  												: pLineNumberItems[i].LineNumber.ToString(pLineNumbersFormat);  							}  							else  							{  								textToShow = pLineNumbersShowAsHexadecimal  												? pLineNumberItems[i].LineNumber.ToString("X")  												: pLineNumberItems[i].LineNumber.ToString();  							}  							Point point = new Point(0' 0);  							SizeF textSize = e.Graphics.MeasureString(textToShow' Font' point' format);  							// Text alignment  							point = GetAlignmentPoint(textSize' pLineNumberItems[i]);  							// Text clipping  							Rectangle itemClipRectangle = new Rectangle(point' textSize.ToSize());  							if(pLineNumbersClipByItemRectangle)  							{  								// If selected' the text will be clipped so that it doesn't spill out of its own  								// LineNumberItem-area. Only the part of the text inside the LineNumberItem.  								// Rectangle should be visible' so intersect with the ItemRectangle.  								// The SetClip method temporary restricts the drawing area of the control for whatever  								// is drawn next.  								itemClipRectangle.Intersect(pLineNumberItems[i].Rectangle);  								e.Graphics.SetClip(itemClipRectangle);  							}  							// Text drawing  							using(SolidBrush brush = new SolidBrush(ForeColor))  							{  								e.Graphics.DrawString(textToShow' Font' brush' point' format);  								e.Graphics.ResetClip();  							}  							// The GraphicsPath for the LineNumber is just a rectangle behind the text' to keep the paintingspeed high and avoid ugly artifacts.  							gpLineNumbers.AddRectangle(itemClipRectangle);  							gpLineNumbers.CloseFigure();  						}  					}  					// Grid lines thickness and linestyle in SeeThroughMode. All GraphicsPath lines are drawn as solid to keep the paintingspeed high.  					if(pGridLinesShow)  					{  						pen.DashStyle = DashStyle.Solid;  						gpGridLines.Widen(pen);  					}  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: Point left = new Point((int)Math.Round(Math.Floor(pBorderLinesThickness / 2.0))'  									 (int)Math.Round(Math.Floor(pBorderLinesThickness / 2.0)));
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: Point left = new Point((int)Math.Round(Math.Floor(pBorderLinesThickness / 2.0))'  									 (int)Math.Round(Math.Floor(pBorderLinesThickness / 2.0)));
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: Point right = new Point((int)Math.Round(Width - Math.Ceiling(pBorderLinesThickness / 2.0))'  									  (int)Math.Round(Height - Math.Ceiling(pBorderLinesThickness / 2.0)));
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: Point right = new Point((int)Math.Round(Width - Math.Ceiling(pBorderLinesThickness / 2.0))'  									  (int)Math.Round(Height - Math.Ceiling(pBorderLinesThickness / 2.0)));
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: Point[] borderLinesPoints = new Point[5];
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: borderLinesPoints[2] = new Point(right.X' right.Y);
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: borderLinesPoints[3] = new Point(left.X' right.Y);
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: borderLinesPoints[4] = new Point(left.X' left.Y);
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,OnPaint,The following statement contains a magic number: if(pMarginLinesShow && (pMarginLinesSide > LineNumberDockSide.None))  			{  				left = new Point((int)Math.Round(-pMarginLinesThickness)' (int)Math.Round(-pMarginLinesThickness));  				right = new Point((int)Math.Round(Width + pMarginLinesThickness)'  									(int)Math.Round(Height + pMarginLinesThickness));  				using(Pen pen = new Pen(pMarginLinesColor' pMarginLinesThickness) { DashStyle = pMarginLinesStyle })  				{  					if((pMarginLinesSide == LineNumberDockSide.Left) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Math.Floor(pMarginLinesThickness / 2.0))' Height - 1));  						left = new Point((int)Math.Round(Math.Ceiling(pMarginLinesThickness / 2.0))'  										   (int)Math.Round(-pMarginLinesThickness));  					}  					if((pMarginLinesSide == LineNumberDockSide.Right) | (pMarginLinesSide == LineNumberDockSide.Height))  					{  						e.Graphics.DrawLine(pen' new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' 0)'  											new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))' Height - 1));  						right = new Point((int)Math.Round(Width - Math.Ceiling(pMarginLinesThickness / 2.0))'  											(int)Math.Round(Height + pMarginLinesThickness));  					}  					// GraphicsPath for the MarginLines(s): MarginLines(s) are drawn as a rectangle connecting the left  					// and right points' which are either inside or outside of sight' depending on whether the MarginLines  					// at that side is visible. "left": TopLeft and "right": BottomRight  					gpMarginLines.AddRectangle(new Rectangle(left' new Size(right.X - left.X' right.Y - left.Y)));  					pen.DashStyle = DashStyle.Solid;  					gpMarginLines.Widen(pen);  				}  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,GetAlignmentPoint,The following statement contains a magic number: switch(pLineNumbersAlignment)  			{  				case ContentAlignment.TopLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  									  (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round(((item.Rectangle.Top +  											   (item.Rectangle.Height / 2.0)) + pLineNumbersOffset.Height) -  											 (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomLeft:  				point = new Point((item.Rectangle.Left + Padding.Left) + pLineNumbersOffset.Width'  								  (int)  								  Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) +  											  pLineNumbersOffset.Height) - textSize.Height));  				break;    				case ContentAlignment.TopCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomCenter:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Width / 2.0) + pLineNumbersOffset.Width) - (textSize.Width / 2.0))'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;    				case ContentAlignment.TopRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)' (item.Rectangle.Top + Padding.Top) + pLineNumbersOffset.Height);  				break;    				case ContentAlignment.MiddleRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round(((item.Rectangle.Top + (item.Rectangle.Height / 2.0)) +  									pLineNumbersOffset.Height) - (textSize.Height / 2.0)));  				break;    				case ContentAlignment.BottomRight:  				point =  					new Point(  						(int)  						Math.Round(((item.Rectangle.Right - Padding.Right) + pLineNumbersOffset.Width) -  								   textSize.Width)'  						(int)  						Math.Round((((item.Rectangle.Bottom - Padding.Bottom) + 1) + pLineNumbersOffset.Height) -  								   textSize.Height));  				break;  				default:  				point = new Point(0' 0);  				break;  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The following statement contains a magic number: if((RTParent != null) && (RTParent.Text != ""))  			{  				// Make sure the LineNumbers are aligning to the same height as the pRTParent textlines by converting to  				// screencoordinates and using that as an offset that gets added to the points for the LineNumberItems  				pPointInParent = RTParent.PointToScreen(RTParent.ClientRectangle.Location);  				pPointInMe = PointToScreen(new Point(0' 0));  				// pParentInMe is the vertical offset to make the LineNumberItems line up with the textlines in pRTParent.  				pParentInMe = (pPointInParent.Y - pPointInMe.Y) + 1;  				// The first visible LineNumber may not be the first visible line of text in the RTB if the  				// LineNumbercontrol's .Top is lower on the form than the .Top of the parent RichTextBox.  				// Therefor' pPointInParent will now be used to find pPointInMe's equivalent height in pRTParent'  				// which is needed to find the best StartIndex later on.  				pPointInParent = RTParent.PointToClient(pPointInMe);  				// Additional complication is the fact that when wordwrap is enabled on the RTB' the wordwrapped text  				// spills into the RTB.Lines collection' so we need to split the text into lines ourselves' and use  				// the Index of each split-line's first character instead of the RTB's.  				string[] split = RTParent.Text.Split(LineBreakCharacters);  				if(split.Length < 2)  				{  					// Just one line in the text = one line number  					// NOTE:  pContentRectangle is built by the pRTParent.ContentsResized event.  					Point point = RTParent.GetPositionFromCharIndex(0);  					pLineNumberItems.Add(new LineNumberItem(1'  						new Rectangle(new Point(0' (point.Y - 1) + pParentInMe)'  							new Size(Width' pContentRectangle.Height - point.Y))));  				}  				else  				{  					// Multiple lines' but store only those LineNumberItems for lines that are visible.  					TimeSpan timeSpan = new TimeSpan(DateTime.Now.Ticks);  					int startIndex = 0;  					int a = RTParent.Text.Length - 1;  					int y = pPointInParent.Y;  					FindStartIndex(ref startIndex' ref a' ref y);  					pPointInParent.Y = y;  					// startIndex now holds the index of a character in the first visible line from zParent.Text  					// Now it will be pointed at the first character of that line  					startIndex = Math.Max(0' Math.Min(RTParent.Text.Length - 1' RTParent.Text.Substring(0' startIndex).LastIndexOf('\n') + 1));  					// We now need to find out which split-line that character is in' by counting the LineBreakCharacters  					// appearances that come before it.  					a = Math.Max(0' RTParent.Text.Substring(0' startIndex).Split(LineBreakCharacters).Length - 1);  					// startIndex starts off pointing at the first character of the first visible line' and will be then  					// be pointed to the index of the first character on the next line.  					while(a <= split.Length - 1)  					{  						Point point = RTParent.GetPositionFromCharIndex(startIndex);  						startIndex += Math.Max(1' split[a].Length + 1);  						if((point.Y + pParentInMe) > Height)  						{  							break;  						}  						// For performance reasons' the list of LineNumberItems (pLineNumberItems) is first built with  						// only the location of its itemrectangle being used. The height of those rectangles will be  						// computed afterwards by comparing the items' Y coordinates.  						pLineNumberItems.Add(new LineNumberItem(a + 1' new Rectangle(0' (point.Y - 1) + pParentInMe' Width' 1)));  						if(pParentIsScrolling && (DateTime.Now.Ticks > (timeSpan.Ticks + ScrollTimeoutTicks)))  						{  							// The more lines there are in the RTB' the slower the RTB's .GetPositionFromCharIndex()  							// method becomes. To avoid those delays from interfering with the scrollingspeed'  							// this speedbased exit for is applied (0.05 sec). pLineNumberItems will have at least 1 item'  							// and if that's the only one' then change its location to 0'0 to make it readable  							if(pLineNumberItems.Count == 1)  							{  								pLineNumberItems[0].Rectangle.Y = 0;  							}  							pParentIsScrolling = false;  							Timer.Start();  							break;  						}  						a++;  					}  					if(pLineNumberItems.Count == 0)  					{  						return;  					}  					// Add an extra placeholder item to the end' to make the heightcomputation easier  					if(a < split.Length)  					{  						// Getting here means the while loop was exited before reaching the last split textline  						// startIndex will still be pointing to the startcharacter of the next line' so we can use that:  						Point point = RTParent.GetPositionFromCharIndex(Math.Min(startIndex' RTParent.Text.Length - 1));  						pLineNumberItems.Add(new LineNumberItem(-1' new Rectangle(0' (point.Y - 1) + pParentInMe' 0' 0)));  					}  					else  					{  						// Getting here means the while loop ran to the end ("a" is now split.Length).   						pLineNumberItems.Add(new LineNumberItem(-1' new Rectangle(0' pContentRectangle.Bottom' 0' 0)));  					}  					// And now we can easily compute the height of the LineNumberItems by comparing each item's Y  					// coordinate with that of the next line. There's at least two items in the list' and the last  					// item is a "nextline-placeholder" that will be removed.  					for(a = 0; a <= pLineNumberItems.Count - 2; a++)  					{  						pLineNumberItems[a].Rectangle.Height = Math.Max(1' pLineNumberItems[a + 1].Rectangle.Y - pLineNumberItems[a].Rectangle.Y);  					}  					// Removing the placeholder item  					pLineNumberItems.RemoveAt(pLineNumberItems.Count - 1);  					// Set the Format to the width of the highest possible number so that LeadingZeroes shows the  					// correct amount of zeroes.  					pLineNumbersFormat = string.Empty.PadRight(pLineNumbersShowAsHexadecimal ? split.Length.ToString("X").Length : split.Length.ToString().Length' '0');  				}  				CalculateAutoSizing();  			}
Magic Number,LineNumbersControlForRichTextBox,LineNumbersForRichText,C:\repos\nccgroup_ncccodenavi\Win.CodeNavi\3rd-Party\LineNumbers\Src\LineNumbersControlForRichTextBox\LineNumbersForRichText.cs,UpdateVisibleLineNumberItems,The following statement contains a magic number: if((RTParent != null) && (RTParent.Text != ""))  			{  				// Make sure the LineNumbers are aligning to the same height as the pRTParent textlines by converting to  				// screencoordinates and using that as an offset that gets added to the points for the LineNumberItems  				pPointInParent = RTParent.PointToScreen(RTParent.ClientRectangle.Location);  				pPointInMe = PointToScreen(new Point(0' 0));  				// pParentInMe is the vertical offset to make the LineNumberItems line up with the textlines in pRTParent.  				pParentInMe = (pPointInParent.Y - pPointInMe.Y) + 1;  				// The first visible LineNumber may not be the first visible line of text in the RTB if the  				// LineNumbercontrol's .Top is lower on the form than the .Top of the parent RichTextBox.  				// Therefor' pPointInParent will now be used to find pPointInMe's equivalent height in pRTParent'  				// which is needed to find the best StartIndex later on.  				pPointInParent = RTParent.PointToClient(pPointInMe);  				// Additional complication is the fact that when wordwrap is enabled on the RTB' the wordwrapped text  				// spills into the RTB.Lines collection' so we need to split the text into lines ourselves' and use  				// the Index of each split-line's first character instead of the RTB's.  				string[] split = RTParent.Text.Split(LineBreakCharacters);  				if(split.Length < 2)  				{  					// Just one line in the text = one line number  					// NOTE:  pContentRectangle is built by the pRTParent.ContentsResized event.  					Point point = RTParent.GetPositionFromCharIndex(0);  					pLineNumberItems.Add(new LineNumberItem(1'  						new Rectangle(new Point(0' (point.Y - 1) + pParentInMe)'  							new Size(Width' pContentRectangle.Height - point.Y))));  				}  				else  				{  					// Multiple lines' but store only those LineNumberItems for lines that are visible.  					TimeSpan timeSpan = new TimeSpan(DateTime.Now.Ticks);  					int startIndex = 0;  					int a = RTParent.Text.Length - 1;  					int y = pPointInParent.Y;  					FindStartIndex(ref startIndex' ref a' ref y);  					pPointInParent.Y = y;  					// startIndex now holds the index of a character in the first visible line from zParent.Text  					// Now it will be pointed at the first character of that line  					startIndex = Math.Max(0' Math.Min(RTParent.Text.Length - 1' RTParent.Text.Substring(0' startIndex).LastIndexOf('\n') + 1));  					// We now need to find out which split-line that character is in' by counting the LineBreakCharacters  					// appearances that come before it.  					a = Math.Max(0' RTParent.Text.Substring(0' startIndex).Split(LineBreakCharacters).Length - 1);  					// startIndex starts off pointing at the first character of the first visible line' and will be then  					// be pointed to the index of the first character on the next line.  					while(a <= split.Length - 1)  					{  						Point point = RTParent.GetPositionFromCharIndex(startIndex);  						startIndex += Math.Max(1' split[a].Length + 1);  						if((point.Y + pParentInMe) > Height)  						{  							break;  						}  						// For performance reasons' the list of LineNumberItems (pLineNumberItems) is first built with  						// only the location of its itemrectangle being used. The height of those rectangles will be  						// computed afterwards by comparing the items' Y coordinates.  						pLineNumberItems.Add(new LineNumberItem(a + 1' new Rectangle(0' (point.Y - 1) + pParentInMe' Width' 1)));  						if(pParentIsScrolling && (DateTime.Now.Ticks > (timeSpan.Ticks + ScrollTimeoutTicks)))  						{  							// The more lines there are in the RTB' the slower the RTB's .GetPositionFromCharIndex()  							// method becomes. To avoid those delays from interfering with the scrollingspeed'  							// this speedbased exit for is applied (0.05 sec). pLineNumberItems will have at least 1 item'  							// and if that's the only one' then change its location to 0'0 to make it readable  							if(pLineNumberItems.Count == 1)  							{  								pLineNumberItems[0].Rectangle.Y = 0;  							}  							pParentIsScrolling = false;  							Timer.Start();  							break;  						}  						a++;  					}  					if(pLineNumberItems.Count == 0)  					{  						return;  					}  					// Add an extra placeholder item to the end' to make the heightcomputation easier  					if(a < split.Length)  					{  						// Getting here means the while loop was exited before reaching the last split textline  						// startIndex will still be pointing to the startcharacter of the next line' so we can use that:  						Point point = RTParent.GetPositionFromCharIndex(Math.Min(startIndex' RTParent.Text.Length - 1));  						pLineNumberItems.Add(new LineNumberItem(-1' new Rectangle(0' (point.Y - 1) + pParentInMe' 0' 0)));  					}  					else  					{  						// Getting here means the while loop ran to the end ("a" is now split.Length).   						pLineNumberItems.Add(new LineNumberItem(-1' new Rectangle(0' pContentRectangle.Bottom' 0' 0)));  					}  					// And now we can easily compute the height of the LineNumberItems by comparing each item's Y  					// coordinate with that of the next line. There's at least two items in the list' and the last  					// item is a "nextline-placeholder" that will be removed.  					for(a = 0; a <= pLineNumberItems.Count - 2; a++)  					{  						pLineNumberItems[a].Rectangle.Height = Math.Max(1' pLineNumberItems[a + 1].Rectangle.Y - pLineNumberItems[a].Rectangle.Y);  					}  					// Removing the placeholder item  					pLineNumberItems.RemoveAt(pLineNumberItems.Count - 1);  					// Set the Format to the width of the highest possible number so that LeadingZeroes shows the  					// correct amount of zeroes.  					pLineNumbersFormat = string.Empty.PadRight(pLineNumbersShowAsHexadecimal ? split.Length.ToString("X").Length : split.Length.ToString().Length' '0');  				}  				CalculateAutoSizing();  			}
