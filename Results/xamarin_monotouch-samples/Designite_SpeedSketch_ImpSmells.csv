Implementation smell,Namespace,Class,File,Method,Description
Long Method,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The method has 208 lines of code.
Complex Method,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,DirtyRects,Cyclomatic complexity of the method is 8
Complex Method,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,SpeedSketch,StrokeGestureRecognizer,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeGestureRecognizer.cs,Append,Cyclomatic complexity of the method is 8
Complex Method,SpeedSketch,StrokeGestureRecognizer,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeGestureRecognizer.cs,Collect,Cyclomatic complexity of the method is 12
Long Parameter List,SpeedSketch,StrokeGestureRecognizer,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeGestureRecognizer.cs,Collect,The method has 5 parameters. Parameters: stroke' touch' view' coalesced' predicted
Long Identifier,SpeedSketch,Stroke,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\Stroke.cs,,The length of the parameter CalligraphyFallbackAzimuthUnitVector is 36.
Long Statement,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The length of the statement  "						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample)); " is 158.
Long Statement,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The length of the statement  "					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) { " is 153.
Long Statement,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The length of the statement  "						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value))); " is 146.
Long Statement,SpeedSketch,StrokeGestureRecognizer,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeGestureRecognizer.cs,Collect,The length of the statement  "			bool collectForce = touch.Type == UITouchType.Stylus || view.TraitCollection.ForceTouchCapability == UIForceTouchCapability.Available; " is 134.
Long Statement,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,SetupPencilUI,The length of the statement  "				    && (!LastSeenPencilInteraction.HasValue || (DateTime.Now.Ticks - LastSeenPencilInteraction.Value) > pencilResetInterval)) " is 121.
Complex Conditional,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The conditional expression  "fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug"  is complex.
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var borderColorSelected = UIColor.FromHSBA (0.07f' 0.81f' 0.98f' 1).CGColor;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var borderColorSelected = UIColor.FromHSBA (0.07f' 0.81f' 0.98f' 1).CGColor;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var borderColorSelected = UIColor.FromHSBA (0.07f' 0.81f' 0.98f' 1).CGColor;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var fillColorSelected = UIColor.FromHSBA (0.07f' 0.21f' 0.98f' 1);
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var fillColorSelected = UIColor.FromHSBA (0.07f' 0.21f' 0.98f' 1);
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var fillColorSelected = UIColor.FromHSBA (0.07f' 0.21f' 0.98f' 1);
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var tau = NMath.PI * 2;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var absoluteRingSegment = tau / 4;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var requiredLengthPerRing = RingRadius * 2 + 5;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,SetupRings,The following statement contains a magic number: var requiredLengthPerRing = RingRadius * 2 + 5;
Magic Number,SpeedSketch,RingControl,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingControl.cs,UpdateViews,The following statement contains a magic number: Animate (0.25' transition);
Magic Number,SpeedSketch,RingView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingView.cs,RingView,The following statement contains a magic number: layer.CornerRadius = frame.Width / 2;
Magic Number,SpeedSketch,RingView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingView.cs,RingView,The following statement contains a magic number: layer.BorderWidth = 2;
Magic Number,SpeedSketch,RingView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingView.cs,PointInside,The following statement contains a magic number: var maxQuadrance = NMath.Pow (Bounds.Width / 2' 2);
Magic Number,SpeedSketch,RingView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Controls\RingView.cs,PointInside,The following statement contains a magic number: var maxQuadrance = NMath.Pow (Bounds.Width / 2' 2);
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,StrokeCGView,The following statement contains a magic number: Func<UIView> dirtyRectView = () => {  				var view = new UIView (new CGRect (-10' -10' 0' 0));  				view.Layer.BorderColor = UIColor.Red.CGColor;  				view.Layer.BorderWidth = 0.5f;  				view.UserInteractionEnabled = false;  				view.Hidden = true;  				AddSubview (view);  				return view;  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,StrokeCGView,The following statement contains a magic number: Func<UIView> dirtyRectView = () => {  				var view = new UIView (new CGRect (-10' -10' 0' 0));  				view.Layer.BorderColor = UIColor.Red.CGColor;  				view.Layer.BorderWidth = 0.5f;  				view.UserInteractionEnabled = false;  				view.Hidden = true;  				AddSubview (view);  				return view;  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,StrokeCGView,The following statement contains a magic number: Func<UIView> dirtyRectView = () => {  				var view = new UIView (new CGRect (-10' -10' 0' 0));  				view.Layer.BorderColor = UIColor.Red.CGColor;  				view.Layer.BorderWidth = 0.5f;  				view.UserInteractionEnabled = false;  				view.Hidden = true;  				AddSubview (view);  				return view;  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,DirtyRectForSampleStride,The following statement contains a magic number: return sampleStride.Aggregate (rectNull' (acc' s) => acc.UnionWith (s.Location.ToRect ()))  							   .Inset (-20' -20);
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,DirtyRectForSampleStride,The following statement contains a magic number: return sampleStride.Aggregate (rectNull' (acc' s) => acc.UnionWith (s.Location.ToRect ()))  							   .Inset (-20' -20);
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: lineSettings = () => {  					context.SetLineWidth (0.5f);  					context.SetStrokeColor (UIColor.White.CGColor);  				};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: forceEstimatedLineSettings = () => {  					context.SetLineWidth (0.5f);  					context.SetStrokeColor (UIColor.Blue.CGColor);  				};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action azimuthSettings = () => {  				context.SetLineWidth (1.5f);  				context.SetStrokeColor (UIColor.Orange.CGColor);  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action altitudeSettings = () => {  				context.SetLineWidth (0.5f);  				context.SetStrokeColor (strokeColor.CGColor);  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var forceMultiplier = 2f;
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var forceOffset = 0.1f;
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var azimuthLockAltitudeThreshold = NMath.PI / 2 * 0.8f;
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var azimuthLockAltitudeThreshold = NMath.PI / 2 * 0.8f;
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: forceOffset = 10;
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action<StrokeSegment> draw = segment => {  				var toSample = segment.ToSample;  				if (toSample != null) {  					StrokeSample fromSample = heldFromSample ?? segment.FromSample;    					// Skip line segments that are too short.  					var dist = Vector (fromSample.Location' toSample.Location).Quadrance ();  					if (dist < 0.003f) {  						if (heldFromSample == null) {  							heldFromSample = fromSample;  							heldFromSampleUnitVector = segment.FromSampleUnitNormal;  						}  						return;  					}    					if (toSample.Predicted) {  						if (displayOptions == StrokeViewDisplayOptions.Debug)  							context.SetFillColor (fillColorPredicted);  					} else {  						bool coalesced = displayOptions == StrokeViewDisplayOptions.Debug && fromSample.Coalesced;  						context.SetFillColor (coalesced ? fillColorCoalesced : fillColorRegular);  					}    					if (displayOptions == StrokeViewDisplayOptions.Calligraphy) {  						var fromAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;  						var toAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;    						if (fromSample.Azimuth.HasValue) {  							if (!lockedAzimuthUnitVector.HasValue)  								lockedAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							fromAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							toAzimuthUnitVector = toSample.GetAzimuthUnitVector ();    							if (fromSample.Altitude.Value > azimuthLockAltitudeThreshold)  								fromAzimuthUnitVector = lockedAzimuthUnitVector.Value;    							if (toSample.Altitude.Value > azimuthLockAltitudeThreshold)  								toAzimuthUnitVector = lockedAzimuthUnitVector.Value;  							else  								lockedAzimuthUnitVector = toAzimuthUnitVector;  						}    						// Rotate 90 degrees  						var calligraphyTransform = CGAffineTransform.MakeRotation (NMath.PI / 2);  						fromAzimuthUnitVector = fromAzimuthUnitVector.Apply (calligraphyTransform);  						toAzimuthUnitVector = toAzimuthUnitVector.Apply (calligraphyTransform);    						var fromUnitVector = fromAzimuthUnitVector.Mult (forceAccessBlock (fromSample));  						var toUnitVector = toAzimuthUnitVector.Mult (forceAccessBlock (toSample));    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();    						context.DrawPath (CGPathDrawingMode.FillStroke);  					} else {  						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample));    						var toUnitVector = segment.ToSampleUnitNormal.Mult (forceAccessBlock (toSample));  						var isForceEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Force)  						                                 || toSample.EstimatedProperties.HasFlag (UITouchProperties.Force);    						if (isForceEstimated) {  							if (lastEstimatedSample == null)  								lastEstimatedSample = new EstimatedSample { Index = segment.FromSampleIndex + 1' Sample = toSample };  							forceEstimatedLineSettings ();  						} else {  							lineSettings ();  						}    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();  						context.DrawPath (CGPathDrawingMode.FillStroke);  					}    					var isEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Azimuth);  					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) {  						var length = 20f;  						var azimuthUnitVector = fromSample.GetAzimuthUnitVector ();  						var azimuthTarget = fromSample.Location.Add (azimuthUnitVector.Mult (length));    						var altitudeStart = azimuthTarget.Add (azimuthUnitVector.Mult (length / -2));  						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value)));    						// Draw altitude as black line coming from the center of the azimuth.  						altitudeSettings ();    						context.BeginPath ();  						context.Move (altitudeStart);  						context.AddLine (altitudeTarget);  						context.StrokePath ();    						// Draw azimuth as orange (or blue if estimated) line.  						azimuthSettings ();    						if (isEstimated)  							context.SetStrokeColor (UIColor.Blue.CGColor);  						context.BeginPath ();  						context.Move (fromSample.Location);  						context.AddLine (azimuthTarget);  						context.StrokePath ();  					}    					heldFromSample = null;  					heldFromSampleUnitVector = null;  				}  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action<StrokeSegment> draw = segment => {  				var toSample = segment.ToSample;  				if (toSample != null) {  					StrokeSample fromSample = heldFromSample ?? segment.FromSample;    					// Skip line segments that are too short.  					var dist = Vector (fromSample.Location' toSample.Location).Quadrance ();  					if (dist < 0.003f) {  						if (heldFromSample == null) {  							heldFromSample = fromSample;  							heldFromSampleUnitVector = segment.FromSampleUnitNormal;  						}  						return;  					}    					if (toSample.Predicted) {  						if (displayOptions == StrokeViewDisplayOptions.Debug)  							context.SetFillColor (fillColorPredicted);  					} else {  						bool coalesced = displayOptions == StrokeViewDisplayOptions.Debug && fromSample.Coalesced;  						context.SetFillColor (coalesced ? fillColorCoalesced : fillColorRegular);  					}    					if (displayOptions == StrokeViewDisplayOptions.Calligraphy) {  						var fromAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;  						var toAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;    						if (fromSample.Azimuth.HasValue) {  							if (!lockedAzimuthUnitVector.HasValue)  								lockedAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							fromAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							toAzimuthUnitVector = toSample.GetAzimuthUnitVector ();    							if (fromSample.Altitude.Value > azimuthLockAltitudeThreshold)  								fromAzimuthUnitVector = lockedAzimuthUnitVector.Value;    							if (toSample.Altitude.Value > azimuthLockAltitudeThreshold)  								toAzimuthUnitVector = lockedAzimuthUnitVector.Value;  							else  								lockedAzimuthUnitVector = toAzimuthUnitVector;  						}    						// Rotate 90 degrees  						var calligraphyTransform = CGAffineTransform.MakeRotation (NMath.PI / 2);  						fromAzimuthUnitVector = fromAzimuthUnitVector.Apply (calligraphyTransform);  						toAzimuthUnitVector = toAzimuthUnitVector.Apply (calligraphyTransform);    						var fromUnitVector = fromAzimuthUnitVector.Mult (forceAccessBlock (fromSample));  						var toUnitVector = toAzimuthUnitVector.Mult (forceAccessBlock (toSample));    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();    						context.DrawPath (CGPathDrawingMode.FillStroke);  					} else {  						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample));    						var toUnitVector = segment.ToSampleUnitNormal.Mult (forceAccessBlock (toSample));  						var isForceEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Force)  						                                 || toSample.EstimatedProperties.HasFlag (UITouchProperties.Force);    						if (isForceEstimated) {  							if (lastEstimatedSample == null)  								lastEstimatedSample = new EstimatedSample { Index = segment.FromSampleIndex + 1' Sample = toSample };  							forceEstimatedLineSettings ();  						} else {  							lineSettings ();  						}    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();  						context.DrawPath (CGPathDrawingMode.FillStroke);  					}    					var isEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Azimuth);  					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) {  						var length = 20f;  						var azimuthUnitVector = fromSample.GetAzimuthUnitVector ();  						var azimuthTarget = fromSample.Location.Add (azimuthUnitVector.Mult (length));    						var altitudeStart = azimuthTarget.Add (azimuthUnitVector.Mult (length / -2));  						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value)));    						// Draw altitude as black line coming from the center of the azimuth.  						altitudeSettings ();    						context.BeginPath ();  						context.Move (altitudeStart);  						context.AddLine (altitudeTarget);  						context.StrokePath ();    						// Draw azimuth as orange (or blue if estimated) line.  						azimuthSettings ();    						if (isEstimated)  							context.SetStrokeColor (UIColor.Blue.CGColor);  						context.BeginPath ();  						context.Move (fromSample.Location);  						context.AddLine (azimuthTarget);  						context.StrokePath ();  					}    					heldFromSample = null;  					heldFromSampleUnitVector = null;  				}  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action<StrokeSegment> draw = segment => {  				var toSample = segment.ToSample;  				if (toSample != null) {  					StrokeSample fromSample = heldFromSample ?? segment.FromSample;    					// Skip line segments that are too short.  					var dist = Vector (fromSample.Location' toSample.Location).Quadrance ();  					if (dist < 0.003f) {  						if (heldFromSample == null) {  							heldFromSample = fromSample;  							heldFromSampleUnitVector = segment.FromSampleUnitNormal;  						}  						return;  					}    					if (toSample.Predicted) {  						if (displayOptions == StrokeViewDisplayOptions.Debug)  							context.SetFillColor (fillColorPredicted);  					} else {  						bool coalesced = displayOptions == StrokeViewDisplayOptions.Debug && fromSample.Coalesced;  						context.SetFillColor (coalesced ? fillColorCoalesced : fillColorRegular);  					}    					if (displayOptions == StrokeViewDisplayOptions.Calligraphy) {  						var fromAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;  						var toAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;    						if (fromSample.Azimuth.HasValue) {  							if (!lockedAzimuthUnitVector.HasValue)  								lockedAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							fromAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							toAzimuthUnitVector = toSample.GetAzimuthUnitVector ();    							if (fromSample.Altitude.Value > azimuthLockAltitudeThreshold)  								fromAzimuthUnitVector = lockedAzimuthUnitVector.Value;    							if (toSample.Altitude.Value > azimuthLockAltitudeThreshold)  								toAzimuthUnitVector = lockedAzimuthUnitVector.Value;  							else  								lockedAzimuthUnitVector = toAzimuthUnitVector;  						}    						// Rotate 90 degrees  						var calligraphyTransform = CGAffineTransform.MakeRotation (NMath.PI / 2);  						fromAzimuthUnitVector = fromAzimuthUnitVector.Apply (calligraphyTransform);  						toAzimuthUnitVector = toAzimuthUnitVector.Apply (calligraphyTransform);    						var fromUnitVector = fromAzimuthUnitVector.Mult (forceAccessBlock (fromSample));  						var toUnitVector = toAzimuthUnitVector.Mult (forceAccessBlock (toSample));    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();    						context.DrawPath (CGPathDrawingMode.FillStroke);  					} else {  						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample));    						var toUnitVector = segment.ToSampleUnitNormal.Mult (forceAccessBlock (toSample));  						var isForceEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Force)  						                                 || toSample.EstimatedProperties.HasFlag (UITouchProperties.Force);    						if (isForceEstimated) {  							if (lastEstimatedSample == null)  								lastEstimatedSample = new EstimatedSample { Index = segment.FromSampleIndex + 1' Sample = toSample };  							forceEstimatedLineSettings ();  						} else {  							lineSettings ();  						}    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();  						context.DrawPath (CGPathDrawingMode.FillStroke);  					}    					var isEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Azimuth);  					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) {  						var length = 20f;  						var azimuthUnitVector = fromSample.GetAzimuthUnitVector ();  						var azimuthTarget = fromSample.Location.Add (azimuthUnitVector.Mult (length));    						var altitudeStart = azimuthTarget.Add (azimuthUnitVector.Mult (length / -2));  						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value)));    						// Draw altitude as black line coming from the center of the azimuth.  						altitudeSettings ();    						context.BeginPath ();  						context.Move (altitudeStart);  						context.AddLine (altitudeTarget);  						context.StrokePath ();    						// Draw azimuth as orange (or blue if estimated) line.  						azimuthSettings ();    						if (isEstimated)  							context.SetStrokeColor (UIColor.Blue.CGColor);  						context.BeginPath ();  						context.Move (fromSample.Location);  						context.AddLine (azimuthTarget);  						context.StrokePath ();  					}    					heldFromSample = null;  					heldFromSampleUnitVector = null;  				}  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action<StrokeSegment> draw = segment => {  				var toSample = segment.ToSample;  				if (toSample != null) {  					StrokeSample fromSample = heldFromSample ?? segment.FromSample;    					// Skip line segments that are too short.  					var dist = Vector (fromSample.Location' toSample.Location).Quadrance ();  					if (dist < 0.003f) {  						if (heldFromSample == null) {  							heldFromSample = fromSample;  							heldFromSampleUnitVector = segment.FromSampleUnitNormal;  						}  						return;  					}    					if (toSample.Predicted) {  						if (displayOptions == StrokeViewDisplayOptions.Debug)  							context.SetFillColor (fillColorPredicted);  					} else {  						bool coalesced = displayOptions == StrokeViewDisplayOptions.Debug && fromSample.Coalesced;  						context.SetFillColor (coalesced ? fillColorCoalesced : fillColorRegular);  					}    					if (displayOptions == StrokeViewDisplayOptions.Calligraphy) {  						var fromAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;  						var toAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;    						if (fromSample.Azimuth.HasValue) {  							if (!lockedAzimuthUnitVector.HasValue)  								lockedAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							fromAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							toAzimuthUnitVector = toSample.GetAzimuthUnitVector ();    							if (fromSample.Altitude.Value > azimuthLockAltitudeThreshold)  								fromAzimuthUnitVector = lockedAzimuthUnitVector.Value;    							if (toSample.Altitude.Value > azimuthLockAltitudeThreshold)  								toAzimuthUnitVector = lockedAzimuthUnitVector.Value;  							else  								lockedAzimuthUnitVector = toAzimuthUnitVector;  						}    						// Rotate 90 degrees  						var calligraphyTransform = CGAffineTransform.MakeRotation (NMath.PI / 2);  						fromAzimuthUnitVector = fromAzimuthUnitVector.Apply (calligraphyTransform);  						toAzimuthUnitVector = toAzimuthUnitVector.Apply (calligraphyTransform);    						var fromUnitVector = fromAzimuthUnitVector.Mult (forceAccessBlock (fromSample));  						var toUnitVector = toAzimuthUnitVector.Mult (forceAccessBlock (toSample));    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();    						context.DrawPath (CGPathDrawingMode.FillStroke);  					} else {  						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample));    						var toUnitVector = segment.ToSampleUnitNormal.Mult (forceAccessBlock (toSample));  						var isForceEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Force)  						                                 || toSample.EstimatedProperties.HasFlag (UITouchProperties.Force);    						if (isForceEstimated) {  							if (lastEstimatedSample == null)  								lastEstimatedSample = new EstimatedSample { Index = segment.FromSampleIndex + 1' Sample = toSample };  							forceEstimatedLineSettings ();  						} else {  							lineSettings ();  						}    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();  						context.DrawPath (CGPathDrawingMode.FillStroke);  					}    					var isEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Azimuth);  					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) {  						var length = 20f;  						var azimuthUnitVector = fromSample.GetAzimuthUnitVector ();  						var azimuthTarget = fromSample.Location.Add (azimuthUnitVector.Mult (length));    						var altitudeStart = azimuthTarget.Add (azimuthUnitVector.Mult (length / -2));  						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value)));    						// Draw altitude as black line coming from the center of the azimuth.  						altitudeSettings ();    						context.BeginPath ();  						context.Move (altitudeStart);  						context.AddLine (altitudeTarget);  						context.StrokePath ();    						// Draw azimuth as orange (or blue if estimated) line.  						azimuthSettings ();    						if (isEstimated)  							context.SetStrokeColor (UIColor.Blue.CGColor);  						context.BeginPath ();  						context.Move (fromSample.Location);  						context.AddLine (azimuthTarget);  						context.StrokePath ();  					}    					heldFromSample = null;  					heldFromSampleUnitVector = null;  				}  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: Action<StrokeSegment> draw = segment => {  				var toSample = segment.ToSample;  				if (toSample != null) {  					StrokeSample fromSample = heldFromSample ?? segment.FromSample;    					// Skip line segments that are too short.  					var dist = Vector (fromSample.Location' toSample.Location).Quadrance ();  					if (dist < 0.003f) {  						if (heldFromSample == null) {  							heldFromSample = fromSample;  							heldFromSampleUnitVector = segment.FromSampleUnitNormal;  						}  						return;  					}    					if (toSample.Predicted) {  						if (displayOptions == StrokeViewDisplayOptions.Debug)  							context.SetFillColor (fillColorPredicted);  					} else {  						bool coalesced = displayOptions == StrokeViewDisplayOptions.Debug && fromSample.Coalesced;  						context.SetFillColor (coalesced ? fillColorCoalesced : fillColorRegular);  					}    					if (displayOptions == StrokeViewDisplayOptions.Calligraphy) {  						var fromAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;  						var toAzimuthUnitVector = Stroke.CalligraphyFallbackAzimuthUnitVector;    						if (fromSample.Azimuth.HasValue) {  							if (!lockedAzimuthUnitVector.HasValue)  								lockedAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							fromAzimuthUnitVector = fromSample.GetAzimuthUnitVector ();  							toAzimuthUnitVector = toSample.GetAzimuthUnitVector ();    							if (fromSample.Altitude.Value > azimuthLockAltitudeThreshold)  								fromAzimuthUnitVector = lockedAzimuthUnitVector.Value;    							if (toSample.Altitude.Value > azimuthLockAltitudeThreshold)  								toAzimuthUnitVector = lockedAzimuthUnitVector.Value;  							else  								lockedAzimuthUnitVector = toAzimuthUnitVector;  						}    						// Rotate 90 degrees  						var calligraphyTransform = CGAffineTransform.MakeRotation (NMath.PI / 2);  						fromAzimuthUnitVector = fromAzimuthUnitVector.Apply (calligraphyTransform);  						toAzimuthUnitVector = toAzimuthUnitVector.Apply (calligraphyTransform);    						var fromUnitVector = fromAzimuthUnitVector.Mult (forceAccessBlock (fromSample));  						var toUnitVector = toAzimuthUnitVector.Mult (forceAccessBlock (toSample));    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();    						context.DrawPath (CGPathDrawingMode.FillStroke);  					} else {  						var fromUnitVector = (heldFromSampleUnitVector.HasValue ? heldFromSampleUnitVector.Value : segment.FromSampleUnitNormal).Mult (forceAccessBlock (fromSample));    						var toUnitVector = segment.ToSampleUnitNormal.Mult (forceAccessBlock (toSample));  						var isForceEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Force)  						                                 || toSample.EstimatedProperties.HasFlag (UITouchProperties.Force);    						if (isForceEstimated) {  							if (lastEstimatedSample == null)  								lastEstimatedSample = new EstimatedSample { Index = segment.FromSampleIndex + 1' Sample = toSample };  							forceEstimatedLineSettings ();  						} else {  							lineSettings ();  						}    						context.BeginPath ();  						context.Move (fromSample.Location.Add (fromUnitVector));  						context.AddLine (toSample.Location.Add (toUnitVector));  						context.AddLine (toSample.Location.Sub (toUnitVector));  						context.AddLine (fromSample.Location.Sub (fromUnitVector));  						context.ClosePath ();  						context.DrawPath (CGPathDrawingMode.FillStroke);  					}    					var isEstimated = fromSample.EstimatedProperties.HasFlag (UITouchProperties.Azimuth);  					if (fromSample.Azimuth.HasValue && (!fromSample.Coalesced || isEstimated) && !fromSample.Predicted && displayOptions == StrokeViewDisplayOptions.Debug) {  						var length = 20f;  						var azimuthUnitVector = fromSample.GetAzimuthUnitVector ();  						var azimuthTarget = fromSample.Location.Add (azimuthUnitVector.Mult (length));    						var altitudeStart = azimuthTarget.Add (azimuthUnitVector.Mult (length / -2));  						var altitudeTarget = altitudeStart.Add ((azimuthUnitVector.Mult (length / 2)).Apply (CGAffineTransform.MakeRotation (fromSample.Altitude.Value)));    						// Draw altitude as black line coming from the center of the azimuth.  						altitudeSettings ();    						context.BeginPath ();  						context.Move (altitudeStart);  						context.AddLine (altitudeTarget);  						context.StrokePath ();    						// Draw azimuth as orange (or blue if estimated) line.  						azimuthSettings ();    						if (isEstimated)  							context.SetStrokeColor (UIColor.Blue.CGColor);  						context.BeginPath ();  						context.Move (fromSample.Location);  						context.AddLine (azimuthTarget);  						context.StrokePath ();  					}    					heldFromSample = null;  					heldFromSampleUnitVector = null;  				}  			};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var tempSampleFrom = new StrokeSample {  					Timestamp = sample.Timestamp'  					Location = sample.Location.Add (new CGVector (-0.5f' 0))'  					Coalesced = false'  					Predicted = false'  					Force = sample.Force'  					Azimuth = sample.Azimuth'  					Altitude = sample.Altitude'  					EstimatedProperties = sample.EstimatedProperties  				};
Magic Number,SpeedSketch,StrokeCGView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\DrawingEngine\CGDrawingEngine.cs,Draw,The following statement contains a magic number: var tempSampleTo = new StrokeSample {  					Timestamp = sample.Timestamp'  					Location = sample.Location.Add (new CGVector (0.5f' 0))'  					Coalesced = false'  					Predicted = false'  					Force = sample.Force'  					Azimuth = sample.Azimuth'  					Altitude = sample.Altitude'  					EstimatedProperties = sample.EstimatedProperties  				};
Magic Number,SpeedSketch,StrokeGestureRecognizer,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeGestureRecognizer.cs,Collect,The following statement contains a magic number: Distance (previousSample?.Location' location) < 0.003
Magic Number,SpeedSketch,StrokeSegment,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\StrokeModel\StrokeSegment.cs,StrokeSegment,The following statement contains a magic number: FromSampleIndex = -2;
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: var baseInset = 44f;
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: var size = canvasSize.Add (baseInset * 2);
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: var canvasOrigin = new CGPoint ((frame.Width - canvasSize.Width) / 2' (frame.Height - canvasSize.Height) / 2);
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: var canvasOrigin = new CGPoint ((frame.Width - canvasSize.Width) / 2' (frame.Height - canvasSize.Height) / 2);
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: canvasView.Layer.ShadowOffset = new CGSize (0' 3);
Magic Number,SpeedSketch,CanvasContainerView,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasContainerView.cs,FromCanvasSize,The following statement contains a magic number: canvasView.Layer.ShadowRadius = 4;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: scrollView.ContentOffset = new CGPoint ((canvasContainerView.Frame.Width - scrollView.Bounds.Width) / 2'  													(canvasContainerView.Frame.Height - scrollView.Bounds.Height) / 2);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: scrollView.ContentOffset = new CGPoint ((canvasContainerView.Frame.Width - scrollView.Bounds.Width) / 2'  													(canvasContainerView.Frame.Height - scrollView.Bounds.Height) / 2);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: scrollView.MaximumZoomScale = 3;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: scrollView.MinimumZoomScale = 0.5f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringDiameter = onPhone ? 66f : 74f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringDiameter = onPhone ? 66f : 74f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringImageInset = onPhone ? 12f : 14f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringImageInset = onPhone ? 12f : 14f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringOutset = ringDiameter / 2 - (NMath.Floor (NMath.Sqrt ((ringDiameter * ringDiameter) / 8) - borderWidth));
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ViewDidLoad,The following statement contains a magic number: var ringOutset = ringDiameter / 2 - (NMath.Floor (NMath.Sqrt ((ringDiameter * ringDiameter) / 8) - borderWidth));
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: var frame = button.Frame.Inset (-20' -4);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: var frame = button.Frame.Inset (-20' -4);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: frame.Location = new CGPoint (maxX - frame.Width - 5' bounds.GetMinY () - 5);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: frame.Location = new CGPoint (maxX - frame.Width - 5' bounds.GetMinY () - 5);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: buttonLayer.CornerRadius = 5;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,AddButton,The following statement contains a magic number: button.BackgroundColor = UIColor.FromWhiteAlpha (1' 0.4f);
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,SetupPencilUI,The following statement contains a magic number: var dimension = bounds.Height - 16;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,SetupPencilUI,The following statement contains a magic number: var x = bounds.GetMinX () + 3;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,SetupPencilUI,The following statement contains a magic number: var y = bounds.GetMinY () + (bounds.Height - dimension) - 7;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,SetupPencilUI,The following statement contains a magic number: imageView.Alpha = 0.7f;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ZoomingEnded,The following statement contains a magic number: desiredScale *= 2;
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ZoomingEnded,The following statement contains a magic number: scale >= 2
Magic Number,SpeedSketch,CanvasMainViewController,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\UI\CanvasMainViewController.cs,ZoomingEnded,The following statement contains a magic number: NMath.Abs (desiredScale - existingScale) > 0.00001
Magic Number,SpeedSketch,CGMathExtensions,D:\research\architectureSmells\repos\xamarin_monotouch-samples\ios10\SpeedSketch\SpeedSketch\Helpers\CGMathExtensions.cs,GetCenter,The following statement contains a magic number: return Add (rect.Location' new CGVector (rect.Width' rect.Height).Divide (2));
