Implementation smell,Namespace,Class,File,Method,Description
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The method has 102 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The method has 122 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The method has 120 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The method has 119 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The method has 360 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The method has 247 lines of code.
Long Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The method has 234 lines of code.
Long Method,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The method has 404 lines of code.
Complex Method,CSLE,CLS_Environment,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\CLS_Environment.cs,GetTypeByKeyword,Cyclomatic complexity of the method is 13
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,Cyclomatic complexity of the method is 50
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,Cyclomatic complexity of the method is 31
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,Cyclomatic complexity of the method is 30
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,Cyclomatic complexity of the method is 31
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,Cyclomatic complexity of the method is 17
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,Cyclomatic complexity of the method is 12
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,Cyclomatic complexity of the method is 67
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Block,Cyclomatic complexity of the method is 15
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,Cyclomatic complexity of the method is 73
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Value,Cyclomatic complexity of the method is 10
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,Cyclomatic complexity of the method is 36
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_ForEach,Cyclomatic complexity of the method is 9
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_If,Cyclomatic complexity of the method is 10
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_Try,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,Cyclomatic complexity of the method is 20
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,Cyclomatic complexity of the method is 39
Complex Method,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindBlock,Cyclomatic complexity of the method is 10
Complex Method,CSLE,DeleFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Delegate\Delegate.cs,cacheFunction,Cyclomatic complexity of the method is 8
Complex Method,CSLE,CLS_Expression_SetValue,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\CLS_Expression_SetValue.cs,ComputeValue,Cyclomatic complexity of the method is 8
Complex Method,CSLE,CLS_Expression_Function,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Function\CLS_Expression_Function.cs,ComputeValue,Cyclomatic complexity of the method is 10
Complex Method,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,Cyclomatic complexity of the method is 14
Complex Method,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,Cyclomatic complexity of the method is 12
Complex Method,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_Expression_Math2ValueAndOr,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Math\CLS_Expression_Math2ValueAndOR.cs,ComputeValue,Cyclomatic complexity of the method is 9
Complex Method,CSLE,CLS_Expression_Math2ValueLogic,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Math\CLS_Expression_Math2ValueLogic.cs,ComputeValue,Cyclomatic complexity of the method is 8
Complex Method,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,StaticCall,Cyclomatic complexity of the method is 15
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,FindTMethod,Cyclomatic complexity of the method is 14
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCall,Cyclomatic complexity of the method is 18
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,GetMethodSlow,Cyclomatic complexity of the method is 17
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCallCache,Cyclomatic complexity of the method is 8
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,Cyclomatic complexity of the method is 16
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,Cyclomatic complexity of the method is 9
Complex Method,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,IndexSet,Cyclomatic complexity of the method is 8
Complex Method,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,Cyclomatic complexity of the method is 11
Complex Method,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MathLogic,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,Cyclomatic complexity of the method is 85
Complex Method,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,SaveTokenList,Cyclomatic complexity of the method is 9
Complex Method,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,Cyclomatic complexity of the method is 10
Complex Method,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,StaticCall,Cyclomatic complexity of the method is 12
Complex Method,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,MemberCall,Cyclomatic complexity of the method is 13
Complex Method,CSLE,NumericTypeUtils,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\utils\NumericTypeUtils.cs,Math2Value,Cyclomatic complexity of the method is 18
Complex Method,CSLE,NumericTypeUtils,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\utils\NumericTypeUtils.cs,MathLogic,Cyclomatic complexity of the method is 9
Complex Method,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,Cyclomatic complexity of the method is 10
Long Parameter List,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Block,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The method has 11 parameters.
Long Parameter List,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCall,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,GetMethodSlow,The method has 5 parameters.
Long Parameter List,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Bool,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Bool.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,MemberCall,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Class,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Delegate,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Delegate.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Double,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Double.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Float,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Float.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Lambda,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Lambda.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_NULL,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Null.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_String,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_String.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Var,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Var.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Byte,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Byte.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Char,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Char.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Int,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Int.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Long,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Long.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Sbyte,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Sbyte.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_Short,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Short.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_UInt,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_UInt.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_ULong,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_ULong.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,CLS_Type_UShort,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\ints\CLS_Type_Ushort.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,NumericTypeUtils,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\utils\NumericTypeUtils.cs,Math2Value,The method has 5 parameters.
Long Parameter List,CSLE,ICLS_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Type.cs,MemberCall,The method has 5 parameters.
Long Parameter List,CSLE,ICLS_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Type.cs,Math2Value,The method has 5 parameters.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,OptimizeSingle,The length of the statement  "	if (expr is CLS_Expression_Math2Value || expr is CLS_Expression_Math2ValueAndOr || expr is CLS_Expression_Math2ValueLogic) { " is 124.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The length of the statement  "		if (tokens [i].type == TokenType.PUNCTUATION || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "as") || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "is")) { " is 185.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The length of the statement  "				if (dep == 0 && (i == pos || tokens [i - 1].type == TokenType.PUNCTUATION) && i + 1 <= posend && tokens [i + 1].type == TokenType.TYPE) { " is 137.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The length of the statement  "			if (tokens [i].type == TokenType.PUNCTUATION || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "as") || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "is")) { " is 185.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The length of the statement  "					} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") { " is 125.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The length of the statement  "				} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式 " is 150.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The length of the statement  "					} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") { " is 125.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The length of the statement  "			if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) { " is 153.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_NegativeValue,The length of the statement  "			CLS_Expression_NegativeValue v = new CLS_Expression_NegativeValue (pos' expend2' tlist [pos].line' tlist [expend2].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_NegativeLogic,The length of the statement  "			if (subvalue is CLS_Expression_Math2Value || subvalue is CLS_Expression_Math2ValueAndOr || subvalue is CLS_Expression_Math2ValueLogic) { " is 136.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_NegativeLogic,The length of the statement  "				CLS_Expression_NegativeLogic v = new CLS_Expression_NegativeLogic (pp.tokenBegin' pp.tokenEnd' pp.lineBegin' pp.lineEnd); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_NegativeLogic,The length of the statement  "				CLS_Expression_NegativeLogic v = new CLS_Expression_NegativeLogic (pos' expend2' tlist [pos].line' tlist [expend2].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "		//if (posend >= pos + 3 && tlist[pos].text == "(" && tlist[pos].type == TokenType.PUNCTUATION && tlist[pos + 2].text == ")" && tlist[pos + 2].type == TokenType.PUNCTUATION " is 171.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				CLS_Expression_StaticFind value = new CLS_Expression_StaticFind (pos' rightend' tlist [pos].line' tlist [rightend].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				CLS_Expression_StaticFunction value = new CLS_Expression_StaticFunction (pos' rightend' tlist [pos].line' tlist [rightend].line); " is 129.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				CLS_Expression_StaticMath value = new CLS_Expression_StaticMath (pos' rightend' tlist [pos].line' tlist [rightend].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (pos' posend' tlist [pos].line' tlist [posend].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			CLS_Expression_IndexFind value = new CLS_Expression_IndexFind (left' rightend' tlist [left].line' tlist [rightend].line); " is 121.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line); " is 129.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			CLS_Expression_TypeCheck check = new CLS_Expression_TypeCheck (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line); " is 123.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_MemberSetValue value = new CLS_Expression_MemberSetValue (left' rightend' tlist [left].line' tlist [rightend].line); " is 131.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_StaticSetValue value = new CLS_Expression_StaticSetValue (left' rightend' tlist [left].line' tlist [rightend].line); " is 131.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_IndexSetValue value = new CLS_Expression_IndexSetValue (left' rightend' tlist [left].line' tlist [rightend].line); " is 129.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_MemberFind value = new CLS_Expression_MemberFind (left' rightend' tlist [left].line' tlist [rightend].line); " is 123.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_MemberFunction value = new CLS_Expression_MemberFunction (left' rightend' tlist [left].line' tlist [rightend].line); " is 131.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_MemberMath value = new CLS_Expression_MemberMath (left' rightend' tlist [left].line' tlist [rightend].line); " is 123.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			} else if (tkCur.text == "+=" || tkCur.text == "-=" || tkCur.text == "*=" || tkCur.text == "/=" || tkCur.text == "%=") { " is 120.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				//    CLS_Expression_MemberMath value = new CLS_Expression_MemberMath(left' rightend' tlist[left].line' tlist[rightend].line); " is 126.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				//    CLS_Expression_StaticMath value = new CLS_Expression_StaticMath(left' rightend' tlist[left].line' tlist[rightend].line); " is 126.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_SelfOpWithValue value = new CLS_Expression_SelfOpWithValue (left' rightend' tlist [left].line' tlist [rightend].line); " is 133.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				CLS_Expression_Math2ValueAndOr value = new CLS_Expression_Math2ValueAndOr (left' rightend' tlist [left].line' tlist [rightend].line); " is 133.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "			} else if (tkCur.text == ">" || tkCur.text == ">=" || tkCur.text == "<" || tkCur.text == "<=" || tkCur.text == "==" || tkCur.text == "!=") { " is 140.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "				CLS_Expression_Math2ValueLogic value = new CLS_Expression_Math2ValueLogic (left' rightend' tlist [left].line' tlist [rightend].line); " is 133.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_Math3Value value = new CLS_Expression_Math3Value (left' rightend' tlist [left].line' tlist [rightend].line); " is 123.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The length of the statement  "					CLS_Expression_Math2Value value = new CLS_Expression_Math2Value (left' rightend' tlist [left].line' tlist [rightend].line); " is 123.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The length of the statement  "		CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line); " is 128.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The length of the statement  "				//ICLS_Type type = Compiler_Class(env' name' (tokens[i].text == "interface")' filename' tokens' ibegin' iend' embDeubgToken' true); " is 131.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The length of the statement  "				ICLS_Type type = Compiler_Class (env' name' (tokens [i].text == "interface")' typebase' filename' tokens' ibegin' iend' embDeubgToken' onlyGotType' usingList); " is 159.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The length of the statement  "	//                if ((startpos + 2) <= iend && tokens[startpos + 1].text == "." && tokens[startpos + 2].type == TokenType.IDENTIFIER) " is 134.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The length of the statement  "		} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型 " is 128.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The length of the statement  "									throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ()); " is 125.
Long Statement,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The length of the statement  "				} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义 " is 131.
Long Statement,CSLE,CLS_Expression_Math2Value,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Math\CLS_Expression_Math2Value.cs,ComputeValue,The length of the statement  "		result.value = content.environment.GetType (left.type).Math2Value (content' mathop' left.value' right' out result.type); " is 120.
Long Statement,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCall,The length of the statement  "					_oparams [i] = environment.environment.GetType (_params [i].type).ConvertTo (environment' _oparams [i]' ps [i].ParameterType); " is 126.
Long Statement,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,IndexGet,The length of the statement  "			key = environment.environment.GetType (key.GetType ()).ConvertTo (environment' key' (CSLE.CLType)indexGetCachetypeindex); " is 121.
Long Statement,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,IndexSet,The length of the statement  "			value = environment.environment.GetType (value.GetType ()).ConvertTo (environment' value' (CSLE.CLType)indexSetCachetype2); " is 123.
Long Statement,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,IndexSet,The length of the statement  "			value = environment.environment.GetType (value.GetType ()).ConvertTo (environment' value' (CSLE.CLType)indexSetCachetype1); " is 123.
Long Statement,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The length of the statement  "		while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') { " is 128.
Long Statement,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The length of the statement  "			if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) { " is 131.
Long Statement,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The length of the statement  "			if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) { " is 250.
Long Statement,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The length of the statement  "			if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) { " is 177.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,New,The length of the statement  "					sv.value_value.member [i.Key].value = content.environment.GetType (value.type).ConvertTo (content' value.value' i.Value.type.type); " is 131.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,NewStatic,The length of the statement  "						staticMemberInstance [i.Key].value = env.GetType (value.type).ConvertTo (contentMemberCalc' value.value' i.Value.type.type); " is 124.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,StaticCall,The length of the statement  "				content.DefineAndSet (functions [function]._paramnames [i]' functions [function]._paramtypes [i].type' _params [i].value); " is 122.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,StaticValueSet,The length of the statement  "					value = content.environment.GetType ((value as SInstance).type).ConvertTo (content' value' this.members [valuename].type.type); " is 127.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,MemberCall,The length of the statement  "				content.DefineAndSet (this.functions [func]._paramnames [i]' this.functions [func]._paramtypes [i].type' _params [i].value); " is 124.
Long Statement,CSLE,SType,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\CLS_Type_Class.cs,MemberValueSet,The length of the statement  "					value = content.environment.GetType ((value as SInstance).type).ConvertTo (content' value' this.members [valuename].type.type); " is 127.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The conditional expression  "tokens [i].type == TokenType.PUNCTUATION || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "as") || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "is")"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The conditional expression  "dep == 0 && (i == pos || tokens [i - 1].type == TokenType.PUNCTUATION) && i + 1 <= posend && tokens [i + 1].type == TokenType.TYPE"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The conditional expression  "dep == 0 && i > pos && i < posend && i != skip"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,SplitExpressionWithOp,The conditional expression  "tokens [i].type == TokenType.PUNCTUATION || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "as") || (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "is")"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The conditional expression  "!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The conditional expression  "succ1 && succ2 && valueright != null && valueleft != null"  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The conditional expression  "tkCur.text == "+=" || tkCur.text == "-=" || tkCur.text == "*=" || tkCur.text == "/=" || tkCur.text == "%=""  is complex.
Complex Conditional,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The conditional expression  "tkCur.text == ">" || tkCur.text == ">=" || tkCur.text == "<" || tkCur.text == "<=" || tkCur.text == "==" || tkCur.text == "!=""  is complex.
Complex Conditional,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,FindStart,The conditional expression  "!char.IsSeparator (lines' i) && lines [i] != '\n' && lines [i] != '\r' && lines [i] != '\t'"  is complex.
Complex Conditional,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The conditional expression  "ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE"  is complex.
Complex Conditional,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The conditional expression  "ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER"  is complex.
Complex Conditional,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The conditional expression  "ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)"  is complex.
Complex Conditional,CSLE,NumericTypeUtils,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\utils\NumericTypeUtils.cs,GetReturnType_Math2Value,The conditional expression  "(ltIndex == T_Int && rtIndex == T_UInt) || (ltIndex == T_UInt && rtIndex == T_Int)"  is complex.
Complex Conditional,CSLE,NumericTypeUtils,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Type\utils\NumericTypeUtils.cs,GetReturnType_Math2Value,The conditional expression  "(ltIndex == T_UInt && rtIndex != T_Int) || (rtIndex == T_UInt && ltIndex != T_Int)"  is complex.
Empty Catch Block,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,StaticCall,The method has an empty catch block.
Magic Number,CSLE,CLS_Environment,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\CLS_Environment.cs,Project_PacketToStream,The following statement contains a magic number: outstream.Write (FileHead' 0' 8);  
Magic Number,CSLE,CLS_Environment,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\CLS_Environment.cs,Project_PacketToStream,The following statement contains a magic number: outstream.Write (BitConverter.GetBytes (count)' 0' 2);  
Magic Number,CSLE,CLS_Environment,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\CLS_Environment.cs,Project_FromPacketStream,The following statement contains a magic number: instream.Read (buf' 0' 8);  
Magic Number,CSLE,CLS_Environment,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\CLS_Environment.cs,Project_FromPacketStream,The following statement contains a magic number: instream.Read (buf' 0' 2);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,OptimizeSingle,The following statement contains a magic number: if (expr is CLS_Expression_Math3Value) {  	CLS_Content.Value result = expr.listParam [0].ComputeValue (content);  	if ((Type)result.type == typeof(bool)) {  		bool bv = (bool)result.value;  		if (bv)  			return expr.listParam [1];  		else  			return expr.listParam [2];  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,OptimizeSingle,The following statement contains a magic number: if ((Type)result.type == typeof(bool)) {  	bool bv = (bool)result.value;  	if (bv)  		return expr.listParam [1];  	else  		return expr.listParam [2];  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,OptimizeSingle,The following statement contains a magic number: if (bv)  	return expr.listParam [1];  else  	return expr.listParam [2];  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,OptimizeSingle,The following statement contains a magic number: return expr.listParam [2];  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLongType,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i += 2) {  	if (tokens [i].type == TokenType.TYPE && i + 1 < tokens.Count) {  		if (tokens [i + 1].type == TokenType.PUNCTUATION && tokens [i + 1].text == ".") {  		} else {  			npos = i + 1;  		}  	} else {  		break;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLongType,The following statement contains a magic number: i += 2
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLongName,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i += 2) {  	if (nstate == 0 && tokens [i].type == TokenType.TYPE && i + 1 < tokens.Count) {  		if (tokens [i + 1].type == TokenType.PUNCTUATION && tokens [i + 1].text == ".") {  		} else {  			npos = i;  		}  	} else if (tokens [i].type == TokenType.IDENTIFIER && i + 1 < tokens.Count) {  		if (tokens [i + 1].type == TokenType.PUNCTUATION && tokens [i + 1].text == ".") {  		} else {  			npos = i;  		}  	} else {  		break;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLongName,The following statement contains a magic number: i += 2
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: for (int i = posend; i >= pos;) {  	if (state == 0) {  		if (tokens [i].type == TokenType.PUNCTUATION) {  			if (tokens [i].text == ")" && i > pos) {  				int dep = 0;  				for (int j = i - 1; j >= pos; j--) {  					if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  						dep++;  					} else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  						dep--;  						if (dep < 0) {  							if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  								i = j - 2;  								//函数  							} else {  								i = j - 1;  							}  							break;  						}  					}  				}  			} else {  				return -1;  			}  		} else if (tokens [i].type == TokenType.VALUE) {  			i--;  			//需要考虑负号的问题  			if (i == pos || tokens [i - 1].type == TokenType.PUNCTUATION) {  				i--;  			}  		} else if (tokens [i].type == TokenType.STRING || tokens [i].type == TokenType.IDENTIFIER) {  			i--;  		} else {  			return -1;  		}  		state = 1;  	} else {  		if (tokens [i].type != TokenType.PUNCTUATION)  			return -1;  		oppos.Add (i);  		state = 0;  		i--;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (state == 0) {  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == ")" && i > pos) {  			int dep = 0;  			for (int j = i - 1; j >= pos; j--) {  				if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  					dep++;  				} else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  					dep--;  					if (dep < 0) {  						if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  							i = j - 2;  							//函数  						} else {  							i = j - 1;  						}  						break;  					}  				}  			}  		} else {  			return -1;  		}  	} else if (tokens [i].type == TokenType.VALUE) {  		i--;  		//需要考虑负号的问题  		if (i == pos || tokens [i - 1].type == TokenType.PUNCTUATION) {  			i--;  		}  	} else if (tokens [i].type == TokenType.STRING || tokens [i].type == TokenType.IDENTIFIER) {  		i--;  	} else {  		return -1;  	}  	state = 1;  } else {  	if (tokens [i].type != TokenType.PUNCTUATION)  		return -1;  	oppos.Add (i);  	state = 0;  	i--;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION) {  	if (tokens [i].text == ")" && i > pos) {  		int dep = 0;  		for (int j = i - 1; j >= pos; j--) {  			if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  				dep++;  			} else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  				dep--;  				if (dep < 0) {  					if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  						i = j - 2;  						//函数  					} else {  						i = j - 1;  					}  					break;  				}  			}  		}  	} else {  		return -1;  	}  } else if (tokens [i].type == TokenType.VALUE) {  	i--;  	//需要考虑负号的问题  	if (i == pos || tokens [i - 1].type == TokenType.PUNCTUATION) {  		i--;  	}  } else if (tokens [i].type == TokenType.STRING || tokens [i].type == TokenType.IDENTIFIER) {  	i--;  } else {  	return -1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (tokens [i].text == ")" && i > pos) {  	int dep = 0;  	for (int j = i - 1; j >= pos; j--) {  		if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  			dep++;  		} else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  			dep--;  			if (dep < 0) {  				if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  					i = j - 2;  					//函数  				} else {  					i = j - 1;  				}  				break;  			}  		}  	}  } else {  	return -1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: for (int j = i - 1; j >= pos; j--) {  	if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  		dep++;  	} else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  		dep--;  		if (dep < 0) {  			if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  				i = j - 2;  				//函数  			} else {  				i = j - 1;  			}  			break;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == ")") {  	dep++;  } else if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  	dep--;  	if (dep < 0) {  		if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  			i = j - 2;  			//函数  		} else {  			i = j - 1;  		}  		break;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (tokens [j].type == TokenType.PUNCTUATION && tokens [j].text == "(") {  	dep--;  	if (dep < 0) {  		if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  			i = j - 2;  			//函数  		} else {  			i = j - 1;  		}  		break;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (dep < 0) {  	if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  		i = j - 2;  		//函数  	} else {  		i = j - 1;  	}  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: if (j - 1 > pos && (tokens [j - 1].type == TokenType.IDENTIFIER || tokens [j - 1].type == TokenType.TYPE)) {  	i = j - 2;  	//函数  } else {  	i = j - 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: i = j - 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: foreach (int i in oppos) {  	int max = 0;  	switch (tokens [i].text) {  	case "<":  		max = 6;  		break;  	case ">":  		max = 6;  		break;  	case "<=":  		max = 6;  		break;  	case ">=":  		max = 6;  		break;  	case "&&":  		max = 5;  		break;  	case "||":  		max = 5;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 3;  		break;  	case "/":  		max = 3;  		break;  	case "+":  		max = 2;  		break;  	case "-":  		max = 2;  		break;  	}  	if (max > nmax) {  		nmax = max;  		npos = i;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 4;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 4;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 3;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 3;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following statement contains a magic number: max = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "new") {  				return FindCodeKeyWord_New (tokens' i);  			}  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					//{  					//    depstyle = 0;  					//}  					//else  					{  						return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "new") {  				return FindCodeKeyWord_New (tokens' i);  			}  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					//{  					//    depstyle = 0;  					//}  					//else  					{  						return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (start == null) {  	start = tokens [i];  	pos = i;  	if (start.Value.type == TokenType.PUNCTUATION) {  		if (start.Value.text == "{")  			depstyle = 2;  		if (start.Value.text == "(")  			depstyle = 1;  		if (start.Value.text == "[")  			depstyle = 1;  		//bdepstart = true;  	}  	if (start.Value.type == TokenType.KEYWORD) {  		if (start.Value.text == "new") {  			return FindCodeKeyWord_New (tokens' i);  		}  		if (start.Value.text == "for") {  			return FindCodeKeyWord_For (tokens' i);  		}  		if (start.Value.text == "foreach") {  			return FindCodeKeyWord_ForEach (tokens' i);  		}  		if (start.Value.text == "while") {  			return FindCodeKeyWord_While (tokens' i);  		}  		if (start.Value.text == "do") {  			return FindCodeKeyWord_Dowhile (tokens' i);  		}  		if (start.Value.text == "if") {  			return FindCodeKeyWord_If (tokens' i);  		}  		if (start.Value.text == "return") {  			return FindCodeKeyWord_Return (tokens' i);  		}  	}  	//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  	//{  	//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  	//    {  	//        //staticcall = true;  	//        i++;  	//        continue;  	//    }  	//}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (start.Value.type == TokenType.PUNCTUATION) {  	if (start.Value.text == "{")  		depstyle = 2;  	if (start.Value.text == "(")  		depstyle = 1;  	if (start.Value.text == "[")  		depstyle = 1;  	//bdepstart = true;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (start.Value.text == "{")  	depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION) {  	if (tokens [i].text == "{") {  		dep++;  	}  	if (tokens [i].text == "}") {  		dep--;  		if (depstyle == 2 && dep == 0) {  			return i;  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "(") {  		dep++;  	}  	if (tokens [i].text == ")") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "(" && dep == 0) {  				//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  				//{  				//    depstyle = 0;  				//}  				//else  				{  					return i;  				}  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "[") {  		dep++;  	}  	if (tokens [i].text == "]") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "[" && dep == 0) {  				return i;  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (depstyle == 0) {  		//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  		//{  		//    if (dep == 0)  		//        return i - 1;  		//}  		if (tokens [i].text == "'")//，结束的表达式  		 {  			if (dep == 0)  				return i - 1;  		}  		if (tokens [i].text == ";") {  			if (dep == 0)  				return i - 1;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (tokens [i].text == "}") {  	dep--;  	if (depstyle == 2 && dep == 0) {  		return i;  	}  	if (dep < 0)  		return i - 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAny,The following statement contains a magic number: if (depstyle == 2 && dep == 0) {  	return i;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					if (i < tokens.Count && tokens [i + 1].text == ".") {  						depstyle = 0;  					} //if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					//{  					//    depstyle = 0;  					//}  					else {  						return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					if (i < tokens.Count && tokens [i + 1].text == ".") {  						depstyle = 0;  					} //if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					//{  					//    depstyle = 0;  					//}  					else {  						return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (start == null) {  	start = tokens [i];  	pos = i;  	if (start.Value.type == TokenType.PUNCTUATION) {  		if (start.Value.text == "{")  			depstyle = 2;  		if (start.Value.text == "(")  			depstyle = 1;  		if (start.Value.text == "[")  			depstyle = 1;  		//bdepstart = true;  	}  	if (start.Value.type == TokenType.KEYWORD) {  		if (start.Value.text == "for") {  			return FindCodeKeyWord_For (tokens' i);  		}  		if (start.Value.text == "foreach") {  			return FindCodeKeyWord_ForEach (tokens' i);  		}  		if (start.Value.text == "while") {  			return FindCodeKeyWord_While (tokens' i);  		}  		if (start.Value.text == "do") {  			return FindCodeKeyWord_Dowhile (tokens' i);  		}  		if (start.Value.text == "if") {  			return FindCodeKeyWord_If (tokens' i);  		}  		if (start.Value.text == "return") {  			return FindCodeKeyWord_Return (tokens' i);  		}  	}  	//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  	//{  	//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  	//    {  	//        //staticcall = true;  	//        i++;  	//        continue;  	//    }  	//}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (start.Value.type == TokenType.PUNCTUATION) {  	if (start.Value.text == "{")  		depstyle = 2;  	if (start.Value.text == "(")  		depstyle = 1;  	if (start.Value.text == "[")  		depstyle = 1;  	//bdepstart = true;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (start.Value.text == "{")  	depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION) {  	if (tokens [i].text == "{") {  		dep++;  	}  	if (tokens [i].text == "}") {  		dep--;  		if (depstyle == 2 && dep == 0) {  			return i;  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "(") {  		dep++;  	}  	if (tokens [i].text == ")") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "(" && dep == 0) {  				if (i < tokens.Count && tokens [i + 1].text == ".") {  					depstyle = 0;  				} //if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  				//{  				//    depstyle = 0;  				//}  				else {  					return i;  				}  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "[") {  		dep++;  	}  	if (tokens [i].text == "]") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "[" && dep == 0) {  				return i;  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (depstyle == 0) {  		//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  		//{  		//    if (dep == 0)  		//        return i - 1;  		//}  		if (tokens [i].text == "'")//，结束的表达式  		 {  			if (dep == 0)  				return i - 1;  		}  		if (tokens [i].text == ";") {  			if (dep == 0)  				return i - 1;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (tokens [i].text == "}") {  	dep--;  	if (depstyle == 2 && dep == 0) {  		return i;  	}  	if (dep < 0)  		return i - 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeInBlock,The following statement contains a magic number: if (depstyle == 2 && dep == 0) {  	return i;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					{  						depstyle = 0;  					//else  					}  					{  						//return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			if (start.Value.text == "[")  				depstyle = 1;  			//bdepstart = true;  		}  		if (start.Value.type == TokenType.KEYWORD) {  			if (start.Value.text == "for") {  				return FindCodeKeyWord_For (tokens' i);  			}  			if (start.Value.text == "foreach") {  				return FindCodeKeyWord_ForEach (tokens' i);  			}  			if (start.Value.text == "while") {  				return FindCodeKeyWord_While (tokens' i);  			}  			if (start.Value.text == "do") {  				return FindCodeKeyWord_Dowhile (tokens' i);  			}  			if (start.Value.text == "if") {  				return FindCodeKeyWord_If (tokens' i);  			}  			if (start.Value.text == "return") {  				return FindCodeKeyWord_Return (tokens' i);  			}  		}  		//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  		//{  		//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  		//    {  		//        //staticcall = true;  		//        i++;  		//        continue;  		//    }  		//}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  					{  						depstyle = 0;  					//else  					}  					{  						//return i;  					}  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "[") {  			dep++;  		}  		if (tokens [i].text == "]") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "[" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  			//{  			//    if (dep == 0)  			//        return i - 1;  			//}  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (start == null) {  	start = tokens [i];  	pos = i;  	if (start.Value.type == TokenType.PUNCTUATION) {  		if (start.Value.text == "{")  			depstyle = 2;  		if (start.Value.text == "(")  			depstyle = 1;  		if (start.Value.text == "[")  			depstyle = 1;  		//bdepstart = true;  	}  	if (start.Value.type == TokenType.KEYWORD) {  		if (start.Value.text == "for") {  			return FindCodeKeyWord_For (tokens' i);  		}  		if (start.Value.text == "foreach") {  			return FindCodeKeyWord_ForEach (tokens' i);  		}  		if (start.Value.text == "while") {  			return FindCodeKeyWord_While (tokens' i);  		}  		if (start.Value.text == "do") {  			return FindCodeKeyWord_Dowhile (tokens' i);  		}  		if (start.Value.text == "if") {  			return FindCodeKeyWord_If (tokens' i);  		}  		if (start.Value.text == "return") {  			return FindCodeKeyWord_Return (tokens' i);  		}  	}  	//if (start.Value.type == TokenType.TYPE && i < tokens.Count-1)  	//{  	//    if(tokens[i+1].type== TokenType.PUNCTUATION&&tokens[i+1].text==".")  	//    {  	//        //staticcall = true;  	//        i++;  	//        continue;  	//    }  	//}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (start.Value.type == TokenType.PUNCTUATION) {  	if (start.Value.text == "{")  		depstyle = 2;  	if (start.Value.text == "(")  		depstyle = 1;  	if (start.Value.text == "[")  		depstyle = 1;  	//bdepstart = true;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (start.Value.text == "{")  	depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION) {  	if (tokens [i].text == "{") {  		dep++;  	}  	if (tokens [i].text == "}") {  		dep--;  		if (depstyle == 2 && dep == 0) {  			return i;  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "(") {  		dep++;  	}  	if (tokens [i].text == ")") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "(" && dep == 0) {  				//if (i == (pos + 2) && tokens[i - 1].type == TokenType.TYPE)  				{  					depstyle = 0;  				//else  				}  				{  					//return i;  				}  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "[") {  		dep++;  	}  	if (tokens [i].text == "]") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "[" && dep == 0) {  				return i;  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (depstyle == 0) {  		//if (tokens[i].text =="."&& start.Value.type == TokenType.TYPE)  		//{  		//    if (dep == 0)  		//        return i - 1;  		//}  		if (tokens [i].text == "'")//，结束的表达式  		 {  			if (dep == 0)  				return i - 1;  		}  		if (tokens [i].text == ";") {  			if (dep == 0)  				return i - 1;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (tokens [i].text == "}") {  	dep--;  	if (depstyle == 2 && dep == 0) {  		return i;  	}  	if (dep < 0)  		return i - 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyInFunc,The following statement contains a magic number: if (depstyle == 2 && dep == 0) {  	return i;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			//bdepstart = true;  		}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: for (int i = pos; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.COMMENT)//注释忽略  	 {  		continue;  	}  	if (start == null) {  		start = tokens [i];  		pos = i;  		if (start.Value.type == TokenType.PUNCTUATION) {  			if (start.Value.text == "{")  				depstyle = 2;  			if (start.Value.text == "(")  				depstyle = 1;  			//bdepstart = true;  		}  	}  	if (tokens [i].type == TokenType.PUNCTUATION) {  		if (tokens [i].text == "{") {  			dep++;  		}  		if (tokens [i].text == "}") {  			dep--;  			if (depstyle == 2 && dep == 0) {  				return i;  			}  			if (dep < 0)  				return i - 1;  		}  		if (tokens [i].text == "(") {  			dep++;  		}  		if (tokens [i].text == ")") {  			dep--;  			if (depstyle == 1 && dep == 0) {  				if (start.Value.text == "(" && dep == 0) {  					return i;  				}  			}  			if (dep < 0)  				return i - 1;  		}  		if (depstyle == 0) {  			if (tokens [i].text == "'")//，结束的表达式  			 {  				if (dep == 0)  					return i - 1;  			}  			if (tokens [i].text == ";") {  				if (dep == 0)  					return i - 1;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (start == null) {  	start = tokens [i];  	pos = i;  	if (start.Value.type == TokenType.PUNCTUATION) {  		if (start.Value.text == "{")  			depstyle = 2;  		if (start.Value.text == "(")  			depstyle = 1;  		//bdepstart = true;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (start.Value.type == TokenType.PUNCTUATION) {  	if (start.Value.text == "{")  		depstyle = 2;  	if (start.Value.text == "(")  		depstyle = 1;  	//bdepstart = true;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (start.Value.text == "{")  	depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: depstyle = 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION) {  	if (tokens [i].text == "{") {  		dep++;  	}  	if (tokens [i].text == "}") {  		dep--;  		if (depstyle == 2 && dep == 0) {  			return i;  		}  		if (dep < 0)  			return i - 1;  	}  	if (tokens [i].text == "(") {  		dep++;  	}  	if (tokens [i].text == ")") {  		dep--;  		if (depstyle == 1 && dep == 0) {  			if (start.Value.text == "(" && dep == 0) {  				return i;  			}  		}  		if (dep < 0)  			return i - 1;  	}  	if (depstyle == 0) {  		if (tokens [i].text == "'")//，结束的表达式  		 {  			if (dep == 0)  				return i - 1;  		}  		if (tokens [i].text == ";") {  			if (dep == 0)  				return i - 1;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (tokens [i].text == "}") {  	dep--;  	if (depstyle == 2 && dep == 0) {  		return i;  	}  	if (dep < 0)  		return i - 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,FindCodeAnyWithoutKeyword,The following statement contains a magic number: if (depstyle == 2 && dep == 0) {  	return i;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: foreach (int i in list) {  	int max = 0;  	switch (tokens [i].text) {  	case "?":  		max = -1;  		break;  	case ":":  		max = 0;  		break;  	case "<":  		max = 5;  		break;  	case ">":  		max = 5;  		break;  	case "<=":  		max = 5;  		break;  	case ">=":  		max = 5;  		break;  	case "&&":  		max = 3;  		break;  	case "||":  		max = 3;  		break;  	case "==":  		max = 4;  		break;  	case "!=":  		max = 4;  		break;  	case "*":  		max = 7;  		break;  	case "/":  		max = 7;  		break;  	case "%":  		max = 7;  		break;  	case "+":  		max = 6;  		break;  	case "-":  		max = 6;  		break;  	case ".":  		max = 10;  		break;  	case "=>":  		max = 8;  		break;  	case "[":  		max = 10;  		break;  	case "(":  		max = 9;  		//提高括弧的处理顺序到11，已回滚此修改  		//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  		break;  	case "as":  		max = 9;  		break;  	case "is":  		max = 9;  		break;  	}  	if (tokens [i].text == "(")//(int)(xxx) //这种表达式要优先处理前一个  	 {  		if (max < nmax) {  			nmax = max;  			npos = i;  		}  	} else {  		if (max <= nmax) {  			nmax = max;  			npos = i;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 5;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 3;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 3;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 4;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 4;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 7;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 7;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 7;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 6;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 10;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 8;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 10;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 9;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 9;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following statement contains a magic number: max = 9;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Block,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	end = FindCodeInBlock (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend) {  		//LogError(tlist' "括号块识别失败"' expbegin' expend);  		return true;  	}  	if (bdep == 2)//编译块表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression_Block (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else {  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Block,The following statement contains a magic number: if (bdep == 2)//编译块表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression_Block (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else {  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: do {  	if (tlist [begin].type == TokenType.COMMENT) {  		begin++;  		continue;  	}  	if (tlist [begin].type == TokenType.PUNCTUATION && tlist [begin].text == ";") {  		begin++;  		continue;  	}  	int bdep;  	//脱一次壳  	int end = FindCodeAny (tlist' ref begin' out bdep);  	if (end > posend) {  		end = posend;  	} else if (end < posend) {  		bool bMath = false;  		for (int i = end + 1; i <= posend; i++) {  			if (tlist [i].type == TokenType.COMMENT)  				continue;  			if (tlist [i].type == TokenType.PUNCTUATION && tlist [i].text == ";")  				continue;  			bMath = true;  			break;  		}  		if (bMath) {  			end = posend;  			//如果表达式一次搞不完，那肯定是优先级问题  			value = Compiler_Expression_Math (tlist' content' begin' posend);  			return true;  		}  	}  	//else  	//{  	//    IList<int> i = SplitExpressionWithOp(tlist' begin' end);  	//    if (i != null && i.Count > 0)  	//    {  	//        value = Compiler_Expression_Math(tlist' begin' posend);  	//        return true;  	//    }  	//}  	int expend = end;  	int expbegin = begin;  	if (expbegin > expend)  		return true;  	if (expend == expbegin) {  		//simple  		if (tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "break") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  				if (null == subvalue) {  					//LogError(tlist' "表达式编译失败"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "continue") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  			} else if (tlist [expbegin].text == "true") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = true;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "false") {  				CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  				subvalue.value_value = false;  				values.Add (subvalue);  			} else if (tlist [expbegin].text == "null") {  				CLS_Value_Null subvalue = new CLS_Value_Null ();  				values.Add (subvalue);  			}  		} else {  			ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		}  	} else if (bdep == 1)//深层表达式  	 {  		expbegin++;  		expend--;  		ICLS_Expression subvalue;  		bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  		if (bsucc) {  			if (subvalue != null)  				values.Add (subvalue);  		} else {  			LogError (tlist' "表达式编译失败"' expbegin' expend);  			return false;  		}  	} else//尝试各种表达式  	 {  		bool bTest = false;  		//取反表达式  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  			if (tlist [expend].type == TokenType.VALUE) {  				//负数  				if (expend == expbegin + 1) {  					ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  					if (null == subvalue) {  						return false;  					} else  						values.Add (subvalue);  				} else {  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  					if (null == subvalue) {  						LogError (tlist' "表达式编译失败"' begin' posend);  						return false;  					} else  						values.Add (subvalue);  				}  			} else {  				//负数表达式  				ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  					return false;  				} else  					values.Add (subvalue);  			}  			bTest = true;  		}  		if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  			//逻辑反表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  			if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 1)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  					if (null == subvalue)  						return false;  					else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  			 {  				if (expend == expbegin + 3)//定义表达式  				 {  					ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  					//定义并赋值表达式  					ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  					if (null == subvalue) {  						LogError (tlist' "无法识别的数组:"' expbegin' expend);  						return false;  					} else  						values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  				//静态调用表达式  				//if (expend - expbegin > 2)  				{  					ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  					if (subvalue != null) {  						//subvalue.listParam.Add(subparam);  						values.Add (subvalue);  						bTest = true;  					} else {  						LogError (tlist' "无法识别的表达式:"' expbegin' expend);  						return false;  					}  				}  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  			if (expend == expbegin + 1)//一元表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  			//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  			//{  			//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  			//    if (null == subvalue) return false;  			//    else  			//        values.Add(subvalue);  			//    bTest = true;  			//}  		}  		if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		}  		if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  			if (tlist [expbegin].text == "for") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的For头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "foreach") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "while") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的while头:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "do") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "if") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的if判断:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "try") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "return") {  				ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "不可识别的return:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "trace") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "throw") {  				ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  				//算数表达式  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (null != subvalue) {  					values.Add (subvalue);  					bTest = true;  				}  			} else if (tlist [expbegin].text == "new") {  				//new 表达式  				if (tlist [expbegin + 1].type == TokenType.TYPE) {  					ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  					values.Add (subvalue);  					bTest = true;  				}  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  		if (!bTest) {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	begin = end + 1;  } while (begin <= posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin) {  	//simple  	if (tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "break") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Break (tlist' expbegin);  			if (null == subvalue) {  				//LogError(tlist' "表达式编译失败"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "continue") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Continue (tlist' expbegin);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  		} else if (tlist [expbegin].text == "true") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = true;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "false") {  			CLS_Value_Value<bool> subvalue = new CLS_Value_Value<bool> ();  			subvalue.value_value = false;  			values.Add (subvalue);  		} else if (tlist [expbegin].text == "null") {  			CLS_Value_Null subvalue = new CLS_Value_Null ();  			values.Add (subvalue);  		}  	} else {  		ICLS_Expression subvalue = Compiler_Expression_Value (tlist [expbegin]' expbegin);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  	}  } else if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (bdep == 1)//深层表达式   {  	expbegin++;  	expend--;  	ICLS_Expression subvalue;  	bool bsucc = Compiler_Expression (tlist' content' expbegin' expend' out subvalue);  	if (bsucc) {  		if (subvalue != null)  			values.Add (subvalue);  	} else {  		LogError (tlist' "表达式编译失败"' expbegin' expend);  		return false;  	}  } else//尝试各种表达式   {  	bool bTest = false;  	//取反表达式  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "-") {  		if (tlist [expend].type == TokenType.VALUE) {  			//负数  			if (expend == expbegin + 1) {  				ICLS_Expression subvalue = Compiler_Expression_SubValue (tlist [expend]);  				if (null == subvalue) {  					return false;  				} else  					values.Add (subvalue);  			} else {  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' begin' posend);  				if (null == subvalue) {  					LogError (tlist' "表达式编译失败"' begin' posend);  					return false;  				} else  					values.Add (subvalue);  			}  		} else {  			//负数表达式  			ICLS_Expression subvalue = Compiler_Expression_NegativeValue (tlist' content' expbegin + 1' expend);  			if (null == subvalue) {  				LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  				return false;  			} else  				values.Add (subvalue);  		}  		bTest = true;  	}  	if (tlist [expbegin].type == TokenType.PUNCTUATION && tlist [expbegin].text == "!") {  		//逻辑反表达式  		ICLS_Expression subvalue = Compiler_Expression_NegativeLogic (tlist' content' expbegin + 1' expend);  		if (null == subvalue) {  			LogError (tlist' "表达式编译失败"' expbegin + 1' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	}  	if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  		if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 1)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  				if (null == subvalue)  					return false;  				else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  		 {  			if (expend == expbegin + 3)//定义表达式  			 {  				ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  				//定义并赋值表达式  				ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  				if (null == subvalue) {  					LogError (tlist' "无法识别的数组:"' expbegin' expend);  					return false;  				} else  					values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  			//静态调用表达式  			//if (expend - expbegin > 2)  			{  				ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  				if (subvalue != null) {  					//subvalue.listParam.Add(subparam);  					values.Add (subvalue);  					bTest = true;  				} else {  					LogError (tlist' "无法识别的表达式:"' expbegin' expend);  					return false;  				}  			}  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.IDENTIFIER) {  		if (expend == expbegin + 1)//一元表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_MathSelf (tlist' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		if (!bTest && tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == "=")//赋值表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Set (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "(")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_Function(tlist'content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  		//if (!bTest && tlist[expbegin + 1].type == TokenType.PUNCTUATION && tlist[expbegin + 1].text == "[")//函数表达式  		//{  		//    ICLS_Expression subvalue = Compiler_Expression_IndexFind(tlist' content' expbegin' expend);  		//    if (null == subvalue) return false;  		//    else  		//        values.Add(subvalue);  		//    bTest = true;  		//}  	}  	if (!bTest && (tlist [expbegin].type == TokenType.IDENTIFIER || tlist [expbegin].type == TokenType.VALUE || tlist [expbegin].type == TokenType.STRING)) {  		//算数表达式  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (null != subvalue) {  			values.Add (subvalue);  			bTest = true;  		}  	}  	if (!bTest && tlist [expbegin].type == TokenType.KEYWORD) {  		if (tlist [expbegin].text == "for") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_For (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的For头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "foreach") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_ForEach (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的ForEach头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "while") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_While (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的while头:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "do") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Dowhile (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "if") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_If (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的if判断:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "try") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Try (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "return") {  			ICLS_Expression subvalue = Compiler_Expression_Loop_Return (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "不可识别的return:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "trace") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionTrace (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "throw") {  			ICLS_Expression subvalue = Compiler_Expression_FunctionThrow (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (tlist [expbegin].text == "true" || tlist [expbegin].text == "false" || tlist [expbegin].text == "null") {  			//算数表达式  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (null != subvalue) {  				values.Add (subvalue);  				bTest = true;  			}  		} else if (tlist [expbegin].text == "new") {  			//new 表达式  			if (tlist [expbegin + 1].type == TokenType.TYPE) {  				ICLS_Expression subvalue = Compiler_Expression_FunctionNew (tlist' content' pos' posend);  				values.Add (subvalue);  				bTest = true;  			}  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  	if (!bTest) {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (!bTest && tlist [expbegin].type == TokenType.TYPE) {  	if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 1)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  			if (null == subvalue)  				return false;  			else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式  	 {  		if (expend == expbegin + 3)//定义表达式  		 {  			ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  			//定义并赋值表达式  			ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  			if (null == subvalue) {  				LogError (tlist' "无法识别的数组:"' expbegin' expend);  				return false;  			} else  				values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	} else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  		//静态调用表达式  		//if (expend - expbegin > 2)  		{  			ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  			if (subvalue != null) {  				//subvalue.listParam.Add(subparam);  				values.Add (subvalue);  				bTest = true;  			} else {  				LogError (tlist' "无法识别的表达式:"' expbegin' expend);  				return false;  			}  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 1)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  		if (null == subvalue)  			return false;  		else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 1)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 1)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 1)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_Define (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 2 && tlist [expbegin + 2].type == TokenType.PUNCTUATION && tlist [expbegin + 2].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSet (tlist' content' expbegin' expend);  	if (null == subvalue)  		return false;  	else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (tlist [expbegin + 1].text == "[" && tlist [expbegin + 2].text == "]" && tlist [expbegin + 3].type == TokenType.IDENTIFIER)//定义表达式或者定义并赋值表达式   {  	if (expend == expbegin + 3)//定义表达式  	 {  		ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  		//定义并赋值表达式  		ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  		if (null == subvalue) {  			LogError (tlist' "无法识别的数组:"' expbegin' expend);  			return false;  		} else  			values.Add (subvalue);  		bTest = true;  	} else {  		LogError (tlist' "无法识别的表达式:"' expbegin' expend);  		return false;  	}  } else if (tlist [expbegin + 1].type == TokenType.PUNCTUATION && tlist [expbegin + 1].text == ".") {  	//静态调用表达式  	//if (expend - expbegin > 2)  	{  		ICLS_Expression subvalue = Compiler_Expression_Math (tlist' content' expbegin' expend);  		if (subvalue != null) {  			//subvalue.listParam.Add(subparam);  			values.Add (subvalue);  			bTest = true;  		} else {  			LogError (tlist' "无法识别的表达式:"' expbegin' expend);  			return false;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 3)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 3)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 3)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend == expbegin + 3)//定义表达式   {  	ICLS_Expression subvalue = Compiler_Expression_DefineArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression,The following statement contains a magic number: if (expend > expbegin + 4 && tlist [expbegin + 4].type == TokenType.PUNCTUATION && tlist [expbegin + 4].text == "=") {  	//定义并赋值表达式  	ICLS_Expression subvalue = Compiler_Expression_DefineAndSetArray (tlist' content' expbegin' expend);  	if (null == subvalue) {  		LogError (tlist' "无法识别的数组:"' expbegin' expend);  		return false;  	} else  		values.Add (subvalue);  	bTest = true;  } else {  	LogError (tlist' "无法识别的表达式:"' expbegin' expend);  	return false;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Value,The following statement contains a magic number: if (value.type == TokenType.VALUE) {  	if (value.text [value.text.Length - 1] == 'f') {  		CLS_Value_Value<float> number = new CLS_Value_Value<float> ();  		number.value_value = float.Parse (value.text.Substring (0' value.text.Length - 1));  		return number;  	} else if (value.text.Contains (".")) {  		CLS_Value_Value<double> number = new CLS_Value_Value<double> ();  		number.value_value = double.Parse (value.text);  		return number;  	} else {  		if (value.text.Contains ("'")) {  			CLS_Value_Value<char> number = new CLS_Value_Value<char> ();  			number.value_value = (char)value.text [1];  			return number;  		} else {  			ulong lv = ulong.Parse (value.text);  			if (lv > uint.MaxValue) {  				CLS_Value_Value<long> number = new CLS_Value_Value<long> ();  				number.value_value = (long)lv;  				return number;  			} else {  				CLS_Value_Value<int> number = new CLS_Value_Value<int> ();  				number.value_value = (int)lv;  				return number;  			}  		}  	}  } else if (value.type == TokenType.STRING) {  	CLS_Value_Value<string> str = new CLS_Value_Value<string> ();  	str.value_value = value.text.Substring (1' value.text.Length - 2);  	return str;  } else if (value.type == TokenType.IDENTIFIER) {  	CLS_Expression_GetValue getvalue = new CLS_Expression_GetValue (pos' pos' value.line' value.line);  	getvalue.value_name = value.text;  	return getvalue;  } else if (value.type == TokenType.TYPE) {  	CLS_Expression_GetValue getvalue = new CLS_Expression_GetValue (pos' pos' value.line' value.line);  	int l = value.text.LastIndexOf ('.');  	if (l >= 0) {  		getvalue.value_name = value.text.Substring (l + 1);  	} else  		getvalue.value_name = value.text;  	return getvalue;  } else {  	logger.Log_Error ("无法识别的简单表达式" + value);  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Value,The following statement contains a magic number: if (value.type == TokenType.STRING) {  	CLS_Value_Value<string> str = new CLS_Value_Value<string> ();  	str.value_value = value.text.Substring (1' value.text.Length - 2);  	return str;  } else if (value.type == TokenType.IDENTIFIER) {  	CLS_Expression_GetValue getvalue = new CLS_Expression_GetValue (pos' pos' value.line' value.line);  	getvalue.value_name = value.text;  	return getvalue;  } else if (value.type == TokenType.TYPE) {  	CLS_Expression_GetValue getvalue = new CLS_Expression_GetValue (pos' pos' value.line' value.line);  	int l = value.text.LastIndexOf ('.');  	if (l >= 0) {  		getvalue.value_name = value.text.Substring (l + 1);  	} else  		getvalue.value_name = value.text;  	return getvalue;  } else {  	logger.Log_Error ("无法识别的简单表达式" + value);  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Value,The following statement contains a magic number: str.value_value = value.text.Substring (1' value.text.Length - 2);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_DefineArray,The following statement contains a magic number: define.value_name = tlist [pos + 3].text;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: do {  	int fe2 = FindCodeAny (tlist' ref testbegin' out b1);  	ICLS_Expression subvalue;  	bool succ = Compiler_Expression (tlist' content' testbegin' fe2' out subvalue);  	if (!succ)  		break;  	if (subvalue != null) {  		block.listParam.Add (subvalue);  		testbegin = fe2 + 2;  	} else {  		block.listParam.Add (null);  		testbegin = fe2 + 2;  	}  } while (testbegin <= fe1);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: do {  	int fe2 = FindCodeAny (tlist' ref testbegin' out b1);  	ICLS_Expression subvalue;  	bool succ = Compiler_Expression (tlist' content' testbegin' fe2' out subvalue);  	if (!succ)  		break;  	if (subvalue != null) {  		block.listParam.Add (subvalue);  		testbegin = fe2 + 2;  	} else {  		block.listParam.Add (null);  		testbegin = fe2 + 2;  	}  } while (testbegin <= fe1);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: if (subvalue != null) {  	block.listParam.Add (subvalue);  	testbegin = fe2 + 2;  } else {  	block.listParam.Add (null);  	testbegin = fe2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: if (subvalue != null) {  	block.listParam.Add (subvalue);  	testbegin = fe2 + 2;  } else {  	block.listParam.Add (null);  	testbegin = fe2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: testbegin = fe2 + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Lambda,The following statement contains a magic number: testbegin = fe2 + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_DefineAndSetArray,The following statement contains a magic number: if (succ && v != null) {  	CLS_Expression_Define define = new CLS_Expression_Define (pos' posend' tlist [pos].line' tlist [posend].line);  	{  		ICLS_Type type = content.GetTypeByKeyword (tlist [pos].text + "[]");  		define.value_type = type.type;  	}  	define.value_name = tlist [pos + 3].text;  	define.listParam.Add (v);  	return define;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_DefineAndSetArray,The following statement contains a magic number: define.value_name = tlist [pos + 3].text;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The following statement contains a magic number: if (tkCur.text == "=>") {  	//lambda  	return Compiler_Expression_Lambda (tlist' content' pos' posend);  } else if (tkCur.text == "." && pos == oppos - 1 && tlist [pos].type == TokenType.TYPE) {  	int right = oppos + 1;  	int rightend = posend;  	ICLS_Expression valueright;  	bool succ2 = Compiler_Expression (tlist' content' right' rightend' out valueright);  	if (succ2) {  		CLS_Expression_GetValue vg = valueright as CLS_Expression_GetValue;  		CLS_Expression_Function vf = valueright as CLS_Expression_Function;  		if (vg != null) {  			CLS_Expression_StaticFind value = new CLS_Expression_StaticFind (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.staticmembername = vg.value_name;  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			return value;  		} else if (vf != null) {  			CLS_Expression_StaticFunction value = new CLS_Expression_StaticFunction (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.functionName = vf.funcname;  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			//value.listParam.Add(valueleft);  			value.listParam.AddRange (vf.listParam.ToArray ());  			return value;  		} else if (valueright is CLS_Expression_SelfOp) {  			CLS_Expression_SelfOp vr = valueright as CLS_Expression_SelfOp;  			CLS_Expression_StaticMath value = new CLS_Expression_StaticMath (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			value.staticmembername = vr.value_name;  			value.mathop = vr.mathop;  			return value;  		} else {  			throw new Exception ("不可识别的表达式:" + tkCur.ToString () + tkCur.SourcePos ());  		}  	} else {  		throw new Exception ("不可识别的表达式:" + tkCur.ToString () + tkCur.SourcePos ());  	}  } else {  	int left = pos;  	int leftend = oppos - 1;  	int right = oppos + 1;  	int rightend = posend;  	if (tkCur.text == "(") {  		ICLS_Expression v;  		if (!Compiler_Expression (tlist' content' oppos + 3' posend' out v)) {  			LogError (tlist' "编译表达式失败"' right' rightend);  			return null;  		}  		CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (pos' posend' tlist [pos].line' tlist [posend].line);  		convert.listParam.Add (v);  		convert.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return convert;  	}  	ICLS_Expression valueleft;  	bool succ1 = Compiler_Expression (tlist' content' left' leftend' out valueleft);  	ICLS_Expression valueright;  	if (tkCur.text == "[") {  		rightend--;  		if (!Compiler_Expression (tlist' content' right' rightend' out valueright)) {  			LogError (tlist' "编译表达式失败"' right' rightend);  			return null;  		}  		CLS_Expression_IndexFind value = new CLS_Expression_IndexFind (left' rightend' tlist [left].line' tlist [rightend].line);  		value.listParam.Add (valueleft);  		value.listParam.Add (valueright);  		return value;  	} else if (tkCur.text == "as") {  		CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line);  		convert.listParam.Add (valueleft);  		convert.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return convert;  	} else if (tkCur.text == "is") {  		CLS_Expression_TypeCheck check = new CLS_Expression_TypeCheck (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line);  		check.listParam.Add (valueleft);  		check.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return check;  	}  	bool succ2 = Compiler_Expression (tlist' content' right' rightend' out valueright);  	if (succ1 && succ2 && valueright != null && valueleft != null) {  		if (tkCur.text == "=") {  			//member set  			CLS_Expression_MemberFind mfinde = valueleft as CLS_Expression_MemberFind;  			CLS_Expression_StaticFind sfinde = valueleft as CLS_Expression_StaticFind;  			CLS_Expression_IndexFind ifinde = valueleft as CLS_Expression_IndexFind;  			if (mfinde != null) {  				CLS_Expression_MemberSetValue value = new CLS_Expression_MemberSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.membername = mfinde.membername;  				value.listParam.Add (mfinde.listParam [0]);  				value.listParam.Add (valueright);  				return value;  			} else if (sfinde != null) {  				CLS_Expression_StaticSetValue value = new CLS_Expression_StaticSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.staticmembername = sfinde.staticmembername;  				value.type = sfinde.type;  				//value.listParam.Add(mfinde.listParam[0]);  				value.listParam.Add (valueright);  				return value;  			} else if (ifinde != null) {  				CLS_Expression_IndexSetValue value = new CLS_Expression_IndexSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (ifinde.listParam [0]);  				value.listParam.Add (ifinde.listParam [1]);  				value.listParam.Add (valueright);  				return value;  			} else {  				throw new Exception ("非法的Member Set表达式" + valueleft);  			}  		} else if (tkCur.text == ".") {  			//FindMember  			CLS_Expression_GetValue vg = valueright as CLS_Expression_GetValue;  			CLS_Expression_Function vf = valueright as CLS_Expression_Function;  			if (vg != null) {  				CLS_Expression_MemberFind value = new CLS_Expression_MemberFind (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.membername = vg.value_name;  				return value;  			} else if (vf != null) {  				CLS_Expression_MemberFunction value = new CLS_Expression_MemberFunction (left' rightend' tlist [left].line' tlist [rightend].line);  				value.functionName = vf.funcname;  				value.listParam.Add (valueleft);  				value.listParam.AddRange (vf.listParam.ToArray ());  				return value;  			} else if (valueright is CLS_Expression_SelfOp) {  				CLS_Expression_SelfOp vr = valueright as CLS_Expression_SelfOp;  				CLS_Expression_MemberMath value = new CLS_Expression_MemberMath (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.membername = vr.value_name;  				value.mathop = vr.mathop;  				return value;  			}  			throw new Exception ("不可识别的表达式" + valueleft + "." + valueright);  			//value.listParam.Add(valueright);  		} else if (tkCur.text == "+=" || tkCur.text == "-=" || tkCur.text == "*=" || tkCur.text == "/=" || tkCur.text == "%=") {  			//if (valueleft is CLS_Expression_MemberFind)  			//{  			//    CLS_Expression_MemberFind vf = valueleft as CLS_Expression_MemberFind;  			//    CLS_Expression_MemberMath value = new CLS_Expression_MemberMath(left' rightend' tlist[left].line' tlist[rightend].line);  			//    value.listParam.Add(vf.listParam[0]);  			//    value.membername = vf.membername;  			//    value.mathop = tlist[oppos].text[0];  			//    value.listParam.Add(valueright);  			//    return value;  			//}  			//if ((valueright is CLS_Expression_Lambda ==false) && valueleft is CLS_Expression_StaticFind)  			//{  			//    CLS_Expression_StaticFind vf = valueleft as CLS_Expression_StaticFind;  			//    CLS_Expression_StaticMath value = new CLS_Expression_StaticMath(left' rightend' tlist[left].line' tlist[rightend].line);  			//    value.type = vf.type;  			//    value.staticmembername = vf.staticmembername;  			//    value.mathop = tlist[oppos].text[0];  			//    value.listParam.Add(valueright);  			//    return value;  			//}  			//else  			{  				CLS_Expression_SelfOpWithValue value = new CLS_Expression_SelfOpWithValue (left' rightend' tlist [left].line' tlist [rightend].line);  				//value.value_name = ((CLS_Expression_GetValue)valueleft).value_name;  				value.listParam.Add (valueleft);  				value.listParam.Add (valueright);  				value.mathop = tkCur.text [0];  				return value;  			}  		} else if (tkCur.text == "&&" || tkCur.text == "||") {  			CLS_Expression_Math2ValueAndOr value = new CLS_Expression_Math2ValueAndOr (left' rightend' tlist [left].line' tlist [rightend].line);  			value.listParam.Add (valueleft);  			value.listParam.Add (valueright);  			value.mathop = tkCur.text [0];  			return value;  		} else if (tkCur.text == ">" || tkCur.text == ">=" || tkCur.text == "<" || tkCur.text == "<=" || tkCur.text == "==" || tkCur.text == "!=") {  			CLS_Expression_Math2ValueLogic value = new CLS_Expression_Math2ValueLogic (left' rightend' tlist [left].line' tlist [rightend].line);  			value.listParam.Add (valueleft);  			value.listParam.Add (valueright);  			logictoken token = logictoken.not_equal;  			if (tkCur.text == ">") {  				token = logictoken.more;  			} else if (tkCur.text == ">=") {  				token = logictoken.more_equal;  			} else if (tkCur.text == "<") {  				token = logictoken.less;  			} else if (tkCur.text == "<=") {  				token = logictoken.less_equal;  			} else if (tkCur.text == "==") {  				token = logictoken.equal;  			} else if (tkCur.text == "!=") {  				token = logictoken.not_equal;  			}  			value.mathop = token;  			return value;  		} else {  			char mathop = tkCur.text [0];  			if (mathop == '?') {  				CLS_Expression_Math3Value value = new CLS_Expression_Math3Value (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				CLS_Expression_Math2Value vvright = valueright as CLS_Expression_Math2Value;  				if (vvright.mathop != ':')  					throw new Exception ("三元表达式异常" + tkCur.ToString () + tkCur.SourcePos ());  				value.listParam.Add (vvright.listParam [0]);  				value.listParam.Add (vvright.listParam [1]);  				return value;  			} else {  				CLS_Expression_Math2Value value = new CLS_Expression_Math2Value (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.listParam.Add (valueright);  				value.mathop = mathop;  				return value;  			}  		}  	} else {  		LogError (tlist' "编译表达式失败"' right' rightend);  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The following statement contains a magic number: if (tkCur.text == "." && pos == oppos - 1 && tlist [pos].type == TokenType.TYPE) {  	int right = oppos + 1;  	int rightend = posend;  	ICLS_Expression valueright;  	bool succ2 = Compiler_Expression (tlist' content' right' rightend' out valueright);  	if (succ2) {  		CLS_Expression_GetValue vg = valueright as CLS_Expression_GetValue;  		CLS_Expression_Function vf = valueright as CLS_Expression_Function;  		if (vg != null) {  			CLS_Expression_StaticFind value = new CLS_Expression_StaticFind (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.staticmembername = vg.value_name;  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			return value;  		} else if (vf != null) {  			CLS_Expression_StaticFunction value = new CLS_Expression_StaticFunction (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.functionName = vf.funcname;  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			//value.listParam.Add(valueleft);  			value.listParam.AddRange (vf.listParam.ToArray ());  			return value;  		} else if (valueright is CLS_Expression_SelfOp) {  			CLS_Expression_SelfOp vr = valueright as CLS_Expression_SelfOp;  			CLS_Expression_StaticMath value = new CLS_Expression_StaticMath (pos' rightend' tlist [pos].line' tlist [rightend].line);  			value.type = content.GetTypeByKeyword (tlist [pos].text);  			value.staticmembername = vr.value_name;  			value.mathop = vr.mathop;  			return value;  		} else {  			throw new Exception ("不可识别的表达式:" + tkCur.ToString () + tkCur.SourcePos ());  		}  	} else {  		throw new Exception ("不可识别的表达式:" + tkCur.ToString () + tkCur.SourcePos ());  	}  } else {  	int left = pos;  	int leftend = oppos - 1;  	int right = oppos + 1;  	int rightend = posend;  	if (tkCur.text == "(") {  		ICLS_Expression v;  		if (!Compiler_Expression (tlist' content' oppos + 3' posend' out v)) {  			LogError (tlist' "编译表达式失败"' right' rightend);  			return null;  		}  		CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (pos' posend' tlist [pos].line' tlist [posend].line);  		convert.listParam.Add (v);  		convert.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return convert;  	}  	ICLS_Expression valueleft;  	bool succ1 = Compiler_Expression (tlist' content' left' leftend' out valueleft);  	ICLS_Expression valueright;  	if (tkCur.text == "[") {  		rightend--;  		if (!Compiler_Expression (tlist' content' right' rightend' out valueright)) {  			LogError (tlist' "编译表达式失败"' right' rightend);  			return null;  		}  		CLS_Expression_IndexFind value = new CLS_Expression_IndexFind (left' rightend' tlist [left].line' tlist [rightend].line);  		value.listParam.Add (valueleft);  		value.listParam.Add (valueright);  		return value;  	} else if (tkCur.text == "as") {  		CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line);  		convert.listParam.Add (valueleft);  		convert.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return convert;  	} else if (tkCur.text == "is") {  		CLS_Expression_TypeCheck check = new CLS_Expression_TypeCheck (left' oppos + 1' tlist [left].line' tlist [oppos + 1].line);  		check.listParam.Add (valueleft);  		check.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  		return check;  	}  	bool succ2 = Compiler_Expression (tlist' content' right' rightend' out valueright);  	if (succ1 && succ2 && valueright != null && valueleft != null) {  		if (tkCur.text == "=") {  			//member set  			CLS_Expression_MemberFind mfinde = valueleft as CLS_Expression_MemberFind;  			CLS_Expression_StaticFind sfinde = valueleft as CLS_Expression_StaticFind;  			CLS_Expression_IndexFind ifinde = valueleft as CLS_Expression_IndexFind;  			if (mfinde != null) {  				CLS_Expression_MemberSetValue value = new CLS_Expression_MemberSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.membername = mfinde.membername;  				value.listParam.Add (mfinde.listParam [0]);  				value.listParam.Add (valueright);  				return value;  			} else if (sfinde != null) {  				CLS_Expression_StaticSetValue value = new CLS_Expression_StaticSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.staticmembername = sfinde.staticmembername;  				value.type = sfinde.type;  				//value.listParam.Add(mfinde.listParam[0]);  				value.listParam.Add (valueright);  				return value;  			} else if (ifinde != null) {  				CLS_Expression_IndexSetValue value = new CLS_Expression_IndexSetValue (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (ifinde.listParam [0]);  				value.listParam.Add (ifinde.listParam [1]);  				value.listParam.Add (valueright);  				return value;  			} else {  				throw new Exception ("非法的Member Set表达式" + valueleft);  			}  		} else if (tkCur.text == ".") {  			//FindMember  			CLS_Expression_GetValue vg = valueright as CLS_Expression_GetValue;  			CLS_Expression_Function vf = valueright as CLS_Expression_Function;  			if (vg != null) {  				CLS_Expression_MemberFind value = new CLS_Expression_MemberFind (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.membername = vg.value_name;  				return value;  			} else if (vf != null) {  				CLS_Expression_MemberFunction value = new CLS_Expression_MemberFunction (left' rightend' tlist [left].line' tlist [rightend].line);  				value.functionName = vf.funcname;  				value.listParam.Add (valueleft);  				value.listParam.AddRange (vf.listParam.ToArray ());  				return value;  			} else if (valueright is CLS_Expression_SelfOp) {  				CLS_Expression_SelfOp vr = valueright as CLS_Expression_SelfOp;  				CLS_Expression_MemberMath value = new CLS_Expression_MemberMath (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.membername = vr.value_name;  				value.mathop = vr.mathop;  				return value;  			}  			throw new Exception ("不可识别的表达式" + valueleft + "." + valueright);  			//value.listParam.Add(valueright);  		} else if (tkCur.text == "+=" || tkCur.text == "-=" || tkCur.text == "*=" || tkCur.text == "/=" || tkCur.text == "%=") {  			//if (valueleft is CLS_Expression_MemberFind)  			//{  			//    CLS_Expression_MemberFind vf = valueleft as CLS_Expression_MemberFind;  			//    CLS_Expression_MemberMath value = new CLS_Expression_MemberMath(left' rightend' tlist[left].line' tlist[rightend].line);  			//    value.listParam.Add(vf.listParam[0]);  			//    value.membername = vf.membername;  			//    value.mathop = tlist[oppos].text[0];  			//    value.listParam.Add(valueright);  			//    return value;  			//}  			//if ((valueright is CLS_Expression_Lambda ==false) && valueleft is CLS_Expression_StaticFind)  			//{  			//    CLS_Expression_StaticFind vf = valueleft as CLS_Expression_StaticFind;  			//    CLS_Expression_StaticMath value = new CLS_Expression_StaticMath(left' rightend' tlist[left].line' tlist[rightend].line);  			//    value.type = vf.type;  			//    value.staticmembername = vf.staticmembername;  			//    value.mathop = tlist[oppos].text[0];  			//    value.listParam.Add(valueright);  			//    return value;  			//}  			//else  			{  				CLS_Expression_SelfOpWithValue value = new CLS_Expression_SelfOpWithValue (left' rightend' tlist [left].line' tlist [rightend].line);  				//value.value_name = ((CLS_Expression_GetValue)valueleft).value_name;  				value.listParam.Add (valueleft);  				value.listParam.Add (valueright);  				value.mathop = tkCur.text [0];  				return value;  			}  		} else if (tkCur.text == "&&" || tkCur.text == "||") {  			CLS_Expression_Math2ValueAndOr value = new CLS_Expression_Math2ValueAndOr (left' rightend' tlist [left].line' tlist [rightend].line);  			value.listParam.Add (valueleft);  			value.listParam.Add (valueright);  			value.mathop = tkCur.text [0];  			return value;  		} else if (tkCur.text == ">" || tkCur.text == ">=" || tkCur.text == "<" || tkCur.text == "<=" || tkCur.text == "==" || tkCur.text == "!=") {  			CLS_Expression_Math2ValueLogic value = new CLS_Expression_Math2ValueLogic (left' rightend' tlist [left].line' tlist [rightend].line);  			value.listParam.Add (valueleft);  			value.listParam.Add (valueright);  			logictoken token = logictoken.not_equal;  			if (tkCur.text == ">") {  				token = logictoken.more;  			} else if (tkCur.text == ">=") {  				token = logictoken.more_equal;  			} else if (tkCur.text == "<") {  				token = logictoken.less;  			} else if (tkCur.text == "<=") {  				token = logictoken.less_equal;  			} else if (tkCur.text == "==") {  				token = logictoken.equal;  			} else if (tkCur.text == "!=") {  				token = logictoken.not_equal;  			}  			value.mathop = token;  			return value;  		} else {  			char mathop = tkCur.text [0];  			if (mathop == '?') {  				CLS_Expression_Math3Value value = new CLS_Expression_Math3Value (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				CLS_Expression_Math2Value vvright = valueright as CLS_Expression_Math2Value;  				if (vvright.mathop != ':')  					throw new Exception ("三元表达式异常" + tkCur.ToString () + tkCur.SourcePos ());  				value.listParam.Add (vvright.listParam [0]);  				value.listParam.Add (vvright.listParam [1]);  				return value;  			} else {  				CLS_Expression_Math2Value value = new CLS_Expression_Math2Value (left' rightend' tlist [left].line' tlist [rightend].line);  				value.listParam.Add (valueleft);  				value.listParam.Add (valueright);  				value.mathop = mathop;  				return value;  			}  		}  	} else {  		LogError (tlist' "编译表达式失败"' right' rightend);  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The following statement contains a magic number: if (tkCur.text == "(") {  	ICLS_Expression v;  	if (!Compiler_Expression (tlist' content' oppos + 3' posend' out v)) {  		LogError (tlist' "编译表达式失败"' right' rightend);  		return null;  	}  	CLS_Expression_TypeConvert convert = new CLS_Expression_TypeConvert (pos' posend' tlist [pos].line' tlist [posend].line);  	convert.listParam.Add (v);  	convert.targettype = content.GetTypeByKeyword (tlist [oppos + 1].text).type;  	return convert;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Math,The following statement contains a magic number: if (!Compiler_Expression (tlist' content' oppos + 3' posend' out v)) {  	LogError (tlist' "编译表达式失败"' right' rightend);  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Function,The following statement contains a magic number: if (tlist [pos + 1].type == TokenType.PUNCTUATION && tlist [pos + 1].text == "(") {  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  			func.tokenEnd = end;  			func.lineEnd = tlist [end].line;  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Function,The following statement contains a magic number: do {  	ICLS_Expression param;  	bool succ = Compiler_Expression (tlist' content' begin' end' out param);  	if (succ && param != null) {  		func.listParam.Add (param);  		func.tokenEnd = end;  		func.lineEnd = tlist [end].line;  	}  	begin = end + 2;  	end = FindCodeAnyInFunc (tlist' ref begin' out dep);  } while (end < posend && begin <= end);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Function,The following statement contains a magic number: begin = end + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionTrace,The following statement contains a magic number: do {  	ICLS_Expression param;  	bool succ = Compiler_Expression (tlist' content' begin' end' out param);  	if (succ && param != null) {  		func.listParam.Add (param);  		func.tokenEnd = end;  		func.lineEnd = tlist [end].line;  	}  	begin = end + 2;  	end = FindCodeAnyInFunc (tlist' ref begin' out dep);  } while (end < posend && begin <= end);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionTrace,The following statement contains a magic number: begin = end + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "(") {  	//一般函数  	CLS_Expression_FunctionNew func = new CLS_Expression_FunctionNew (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text);  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  } else if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: do {  	ICLS_Expression param;  	bool succ = Compiler_Expression (tlist' content' begin' end' out param);  	if (succ && param != null) {  		func.listParam.Add (param);  	}  	begin = end + 2;  	end = FindCodeAnyInFunc (tlist' ref begin' out dep);  } while (end < posend && begin <= end);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: begin = end + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 2].type == TokenType.PUNCTUATION && tlist [pos + 2].text == "[")//数组实例化表达式   {  	CLS_Expression_FunctionNewArray func = new CLS_Expression_FunctionNewArray (pos' posend' tlist [pos].line' tlist [posend].line);  	func.type = content.GetTypeByKeyword (tlist [pos + 1].text + "[]");  	int valuebegin = 0;  	ICLS_Expression count = null;  	if (tlist [pos + 3].text == "]") {  		valuebegin = pos + 4;  	} else {  		int nbegin = pos + 3;  		int dep2;  		int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  		bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  		if (!succ) {  			throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  		}  		valuebegin = end2 + 2;  	}  	func.listParam.Add (count);  	if (tlist [valuebegin].text == "{")//InitValue  	 {  		int nbegin = valuebegin + 1;  		do {  			int dep2;  			int nend = FindCodeAny (tlist' ref nbegin' out dep2);  			ICLS_Expression valueI;  			bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  			if (!succ) {  				//throw new Exception("数组初始值无法识别");  			} else {  				func.listParam.Add (valueI);  			}  			if (tlist [nend + 1].text != "'")  				break;  			nbegin = nend + 2;  		} while (nbegin >= pos && nbegin < posend);  	}  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 3].text == "]") {  	valuebegin = pos + 4;  } else {  	int nbegin = pos + 3;  	int dep2;  	int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  	bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  	if (!succ) {  		throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  	}  	valuebegin = end2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 3].text == "]") {  	valuebegin = pos + 4;  } else {  	int nbegin = pos + 3;  	int dep2;  	int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  	bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  	if (!succ) {  		throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  	}  	valuebegin = end2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 3].text == "]") {  	valuebegin = pos + 4;  } else {  	int nbegin = pos + 3;  	int dep2;  	int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  	bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  	if (!succ) {  		throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  	}  	valuebegin = end2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [pos + 3].text == "]") {  	valuebegin = pos + 4;  } else {  	int nbegin = pos + 3;  	int dep2;  	int end2 = FindCodeAny (tlist' ref nbegin' out dep2);  	bool succ = Compiler_Expression (tlist' content' nbegin' end2' out count);  	if (!succ) {  		throw new Exception ("数组数量无法识别:" + tlist [pos].ToString () + tlist [pos].SourcePos ());  	}  	valuebegin = end2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: valuebegin = pos + 4;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: valuebegin = end2 + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: if (tlist [valuebegin].text == "{")//InitValue   {  	int nbegin = valuebegin + 1;  	do {  		int dep2;  		int nend = FindCodeAny (tlist' ref nbegin' out dep2);  		ICLS_Expression valueI;  		bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  		if (!succ) {  			//throw new Exception("数组初始值无法识别");  		} else {  			func.listParam.Add (valueI);  		}  		if (tlist [nend + 1].text != "'")  			break;  		nbegin = nend + 2;  	} while (nbegin >= pos && nbegin < posend);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: do {  	int dep2;  	int nend = FindCodeAny (tlist' ref nbegin' out dep2);  	ICLS_Expression valueI;  	bool succ = Compiler_Expression (tlist' content' nbegin' nend' out valueI);  	if (!succ) {  		//throw new Exception("数组初始值无法识别");  	} else {  		func.listParam.Add (valueI);  	}  	if (tlist [nend + 1].text != "'")  		break;  	nbegin = nend + 2;  } while (nbegin >= pos && nbegin < posend);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionNew,The following statement contains a magic number: nbegin = nend + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionStatic,The following statement contains a magic number: if (tlist [pos + 1].type == TokenType.PUNCTUATION && tlist [pos + 1].text == "(") {  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.listParam.Add (param);  			func.tokenEnd = end;  			func.lineEnd = tlist [end].line;  		}  		begin = end + 2;  		end = FindCodeAnyInFunc (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionStatic,The following statement contains a magic number: do {  	ICLS_Expression param;  	bool succ = Compiler_Expression (tlist' content' begin' end' out param);  	if (succ && param != null) {  		func.listParam.Add (param);  		func.tokenEnd = end;  		func.lineEnd = tlist [end].line;  	}  	begin = end + 2;  	end = FindCodeAnyInFunc (tlist' ref begin' out dep);  } while (end < posend && begin <= end);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_FunctionStatic,The following statement contains a magic number: begin = end + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_IndexFind,The following statement contains a magic number: if (tlist [pos + 1].type == TokenType.PUNCTUATION && tlist [pos + 1].text == "[") {  	do {  		ICLS_Expression param;  		bool succ = Compiler_Expression (tlist' content' begin' end' out param);  		if (succ && param != null) {  			func.tokenEnd = end;  			func.lineEnd = tlist [end].line;  			func.listParam.Add (param);  		}  		begin = end + 2;  		end = FindCodeAny (tlist' ref begin' out dep);  	} while (end < posend && begin <= end);  	return func;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_IndexFind,The following statement contains a magic number: do {  	ICLS_Expression param;  	bool succ = Compiler_Expression (tlist' content' begin' end' out param);  	if (succ && param != null) {  		func.tokenEnd = end;  		func.lineEnd = tlist [end].line;  		func.listParam.Add (param);  	}  	begin = end + 2;  	end = FindCodeAny (tlist' ref begin' out dep);  } while (end < posend && begin <= end);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_IndexFind,The following statement contains a magic number: begin = end + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: do {  	int fe2 = FindCodeAny (tlist' ref testbegin' out b1);  	ICLS_Expression subvalue;  	bool succ = Compiler_Expression (tlist' content' testbegin' fe2' out subvalue);  	//if (!succ) return null;  	if (subvalue != null) {  		value.listParam.Add (subvalue);  		testbegin = fe2 + 2;  	} else {  		value.listParam.Add (null);  		testbegin = fe2 + 2;  	}  } while (testbegin <= fe1);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: do {  	int fe2 = FindCodeAny (tlist' ref testbegin' out b1);  	ICLS_Expression subvalue;  	bool succ = Compiler_Expression (tlist' content' testbegin' fe2' out subvalue);  	//if (!succ) return null;  	if (subvalue != null) {  		value.listParam.Add (subvalue);  		testbegin = fe2 + 2;  	} else {  		value.listParam.Add (null);  		testbegin = fe2 + 2;  	}  } while (testbegin <= fe1);  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: if (subvalue != null) {  	value.listParam.Add (subvalue);  	testbegin = fe2 + 2;  } else {  	value.listParam.Add (null);  	testbegin = fe2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: if (subvalue != null) {  	value.listParam.Add (subvalue);  	testbegin = fe2 + 2;  } else {  	value.listParam.Add (null);  	testbegin = fe2 + 2;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: testbegin = fe2 + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: testbegin = fe2 + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_For,The following statement contains a magic number: if (value.listParam.Count != 3) {  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_Try,The following statement contains a magic number: if (b1 != 2) {  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_Try,The following statement contains a magic number: while (fe1 < posend && tlist [fe1 + 1].text == "catch") {  	//catch(...)  	int b2;  	int fs2 = fe1 + 2;  	int fe2 = FindCodeAny (tlist' ref fs2' out b2);  	{  		if (b2 != 1) {  			return null;  		}  		ICLS_Expression subvalue;  		bool succ = Compiler_Expression (tlist' content' fs2' fe2' out subvalue);  		if (succ) {  			value.tokenEnd = fe2;  			value.lineEnd = tlist [fe2].line;  			value.listParam.Add (subvalue);  		} else {  			return null;  		}  	//catch(){...}  	}  	{  		int b3;  		int fs3 = fe2 + 1;  		int fe3 = FindCodeAny (tlist' ref fs3' out b3);  		if (b3 != 2) {  			return null;  		}  		ICLS_Expression subvalue;  		bool succ = Compiler_Expression_Block (tlist' content' fs3' fe3' out subvalue);  		if (succ) {  			value.tokenEnd = fe3;  			value.lineEnd = tlist [fe3].line;  			value.listParam.Add (subvalue);  		} else {  			return null;  		}  		fe1 = fe3;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_Try,The following statement contains a magic number: while (fe1 < posend && tlist [fe1 + 1].text == "catch") {  	//catch(...)  	int b2;  	int fs2 = fe1 + 2;  	int fe2 = FindCodeAny (tlist' ref fs2' out b2);  	{  		if (b2 != 1) {  			return null;  		}  		ICLS_Expression subvalue;  		bool succ = Compiler_Expression (tlist' content' fs2' fe2' out subvalue);  		if (succ) {  			value.tokenEnd = fe2;  			value.lineEnd = tlist [fe2].line;  			value.listParam.Add (subvalue);  		} else {  			return null;  		}  	//catch(){...}  	}  	{  		int b3;  		int fs3 = fe2 + 1;  		int fe3 = FindCodeAny (tlist' ref fs3' out b3);  		if (b3 != 2) {  			return null;  		}  		ICLS_Expression subvalue;  		bool succ = Compiler_Expression_Block (tlist' content' fs3' fe3' out subvalue);  		if (succ) {  			value.tokenEnd = fe3;  			value.lineEnd = tlist [fe3].line;  			value.listParam.Add (subvalue);  		} else {  			return null;  		}  		fe1 = fe3;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Expression_Loop_Try,The following statement contains a magic number: if (b3 != 2) {  	return null;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == ";")  		continue;  	if (tokens [i].type == TokenType.COMMENT)  		continue;  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "using") {  		int dep;  		int pos = i;  		int iend = FindCodeAny (tokens' ref pos' out dep);  		List<string> list = Compiler_Using (tokens' env' pos' iend);  		string useText = "";  		for (int j = 0; j < list.Count; j++) {  			useText += list [j];  			if (j != list.Count - 1) {  				useText += ".";  			}  		}  		usingList.Add (useText);  		i = iend;  		continue;  	}  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == "[") {  		if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  			bJumpClass = true;  			i = i + 2;  			continue;  		}  	}  	if (tokens [i].type == TokenType.KEYWORD && (tokens [i].text == "class" || tokens [i].text == "interface")) {  		string name = tokens [i + 1].text;  		//在这里检查继承  		List<string> typebase = null;  		int ibegin = i + 2;  		if (onlyGotType) {  			while (tokens [ibegin].text != "{") {  				ibegin++;  			}  		} else {  			if (tokens [ibegin].text == ":") {  				typebase = new List<string> ();  				ibegin++;  			}  			while (tokens [ibegin].text != "{") {  				if (tokens [ibegin].type == TokenType.TYPE) {  					typebase.Add (tokens [ibegin].text);  				}  				ibegin++;  			}  		}  		int iend = FindBlock (env' tokens' ibegin);  		if (iend == -1) {  			env.logger.Log_Error ("查找文件尾失败。");  			return null;  		}  		if (bJumpClass) {  			env.logger.Log ("(NotScript)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else if (onlyGotType) {  			env.logger.Log ("(scriptPreParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else {  			env.logger.Log ("(scriptParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		}  		if (bJumpClass) {  			//忽略这个Class  			//ICLS_Type type = Compiler_Class(env' name' (tokens[i].text == "interface")' filename' tokens' ibegin' iend' embDeubgToken' true);  			//bJumpClass = false;  		} else {  			ICLS_Type type = Compiler_Class (env' name' (tokens [i].text == "interface")' typebase' filename' tokens' ibegin' iend' embDeubgToken' onlyGotType' usingList);  			if (type != null) {  				typelist.Add (type);  			}  		}  		i = iend;  		continue;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == ";")  		continue;  	if (tokens [i].type == TokenType.COMMENT)  		continue;  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "using") {  		int dep;  		int pos = i;  		int iend = FindCodeAny (tokens' ref pos' out dep);  		List<string> list = Compiler_Using (tokens' env' pos' iend);  		string useText = "";  		for (int j = 0; j < list.Count; j++) {  			useText += list [j];  			if (j != list.Count - 1) {  				useText += ".";  			}  		}  		usingList.Add (useText);  		i = iend;  		continue;  	}  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == "[") {  		if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  			bJumpClass = true;  			i = i + 2;  			continue;  		}  	}  	if (tokens [i].type == TokenType.KEYWORD && (tokens [i].text == "class" || tokens [i].text == "interface")) {  		string name = tokens [i + 1].text;  		//在这里检查继承  		List<string> typebase = null;  		int ibegin = i + 2;  		if (onlyGotType) {  			while (tokens [ibegin].text != "{") {  				ibegin++;  			}  		} else {  			if (tokens [ibegin].text == ":") {  				typebase = new List<string> ();  				ibegin++;  			}  			while (tokens [ibegin].text != "{") {  				if (tokens [ibegin].type == TokenType.TYPE) {  					typebase.Add (tokens [ibegin].text);  				}  				ibegin++;  			}  		}  		int iend = FindBlock (env' tokens' ibegin);  		if (iend == -1) {  			env.logger.Log_Error ("查找文件尾失败。");  			return null;  		}  		if (bJumpClass) {  			env.logger.Log ("(NotScript)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else if (onlyGotType) {  			env.logger.Log ("(scriptPreParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else {  			env.logger.Log ("(scriptParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		}  		if (bJumpClass) {  			//忽略这个Class  			//ICLS_Type type = Compiler_Class(env' name' (tokens[i].text == "interface")' filename' tokens' ibegin' iend' embDeubgToken' true);  			//bJumpClass = false;  		} else {  			ICLS_Type type = Compiler_Class (env' name' (tokens [i].text == "interface")' typebase' filename' tokens' ibegin' iend' embDeubgToken' onlyGotType' usingList);  			if (type != null) {  				typelist.Add (type);  			}  		}  		i = iend;  		continue;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++) {  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == ";")  		continue;  	if (tokens [i].type == TokenType.COMMENT)  		continue;  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "using") {  		int dep;  		int pos = i;  		int iend = FindCodeAny (tokens' ref pos' out dep);  		List<string> list = Compiler_Using (tokens' env' pos' iend);  		string useText = "";  		for (int j = 0; j < list.Count; j++) {  			useText += list [j];  			if (j != list.Count - 1) {  				useText += ".";  			}  		}  		usingList.Add (useText);  		i = iend;  		continue;  	}  	if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == "[") {  		if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  			bJumpClass = true;  			i = i + 2;  			continue;  		}  	}  	if (tokens [i].type == TokenType.KEYWORD && (tokens [i].text == "class" || tokens [i].text == "interface")) {  		string name = tokens [i + 1].text;  		//在这里检查继承  		List<string> typebase = null;  		int ibegin = i + 2;  		if (onlyGotType) {  			while (tokens [ibegin].text != "{") {  				ibegin++;  			}  		} else {  			if (tokens [ibegin].text == ":") {  				typebase = new List<string> ();  				ibegin++;  			}  			while (tokens [ibegin].text != "{") {  				if (tokens [ibegin].type == TokenType.TYPE) {  					typebase.Add (tokens [ibegin].text);  				}  				ibegin++;  			}  		}  		int iend = FindBlock (env' tokens' ibegin);  		if (iend == -1) {  			env.logger.Log_Error ("查找文件尾失败。");  			return null;  		}  		if (bJumpClass) {  			env.logger.Log ("(NotScript)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else if (onlyGotType) {  			env.logger.Log ("(scriptPreParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		} else {  			env.logger.Log ("(scriptParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  		}  		if (bJumpClass) {  			//忽略这个Class  			//ICLS_Type type = Compiler_Class(env' name' (tokens[i].text == "interface")' filename' tokens' ibegin' iend' embDeubgToken' true);  			//bJumpClass = false;  		} else {  			ICLS_Type type = Compiler_Class (env' name' (tokens [i].text == "interface")' typebase' filename' tokens' ibegin' iend' embDeubgToken' onlyGotType' usingList);  			if (type != null) {  				typelist.Add (type);  			}  		}  		i = iend;  		continue;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == "[") {  	if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  		bJumpClass = true;  		i = i + 2;  		continue;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: if (tokens [i].type == TokenType.PUNCTUATION && tokens [i].text == "[") {  	if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  		bJumpClass = true;  		i = i + 2;  		continue;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  	bJumpClass = true;  	i = i + 2;  	continue;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: if (tokens [i + 1].text == "NotScipt" || (tokens [i + 1].text == "CSLE" && tokens [i + 3].text == "NotScipt")) {  	bJumpClass = true;  	i = i + 2;  	continue;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: i = i + 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,_FileCompiler,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && (tokens [i].text == "class" || tokens [i].text == "interface")) {  	string name = tokens [i + 1].text;  	//在这里检查继承  	List<string> typebase = null;  	int ibegin = i + 2;  	if (onlyGotType) {  		while (tokens [ibegin].text != "{") {  			ibegin++;  		}  	} else {  		if (tokens [ibegin].text == ":") {  			typebase = new List<string> ();  			ibegin++;  		}  		while (tokens [ibegin].text != "{") {  			if (tokens [ibegin].type == TokenType.TYPE) {  				typebase.Add (tokens [ibegin].text);  			}  			ibegin++;  		}  	}  	int iend = FindBlock (env' tokens' ibegin);  	if (iend == -1) {  		env.logger.Log_Error ("查找文件尾失败。");  		return null;  	}  	if (bJumpClass) {  		env.logger.Log ("(NotScript)findclass:" + name + "(" + ibegin + "'" + iend + ")");  	} else if (onlyGotType) {  		env.logger.Log ("(scriptPreParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  	} else {  		env.logger.Log ("(scriptParser)findclass:" + name + "(" + ibegin + "'" + iend + ")");  	}  	if (bJumpClass) {  		//忽略这个Class  		//ICLS_Type type = Compiler_Class(env' name' (tokens[i].text == "interface")' filename' tokens' ibegin' iend' embDeubgToken' true);  		//bJumpClass = false;  	} else {  		ICLS_Type type = Compiler_Class (env' name' (tokens [i].text == "interface")' typebase' filename' tokens' ibegin' iend' embDeubgToken' onlyGotType' usingList);  		if (type != null) {  			typelist.Add (type);  		}  	}  	i = iend;  	continue;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int i = ibegin; i <= iend; i++) {  	if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  		bPublic = true;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  		bPublic = false;  		continue;  	} else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  		bStatic = true;  		continue;  	} else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型  	 {  		ICLS_Type idtype = env.GetTypeByKeyword ("null");  		bool bctor = false;  		if (tokens [i].type == TokenType.TYPE)//类型  		 {  			if (tokens [i].text == classname && tokens [i + 1].text == "(") {  				//构造函数  				bctor = true;  				i--;  			} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  				idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  				i += 2;  			} else if (tokens [i].text == "void") {  			} else {  				idtype = env.GetTypeByKeyword (tokens [i].text);  			}  		}  		if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  		 {  			string idname = tokens [i + 1].text;  			if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  			 {  				logger.Log ("发现函数:" + idname);  				SType.Function func = new SType.Function ();  				func.bStatic = bStatic;  				func.bPublic = bPublic;  				int funcparambegin = i + 2;  				int funcparamend = FindBlock (env' tokens' funcparambegin);  				if (funcparamend - funcparambegin > 1) {  					int start = funcparambegin + 1;  					//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  					for (int j = funcparambegin + 1; j <= funcparamend; j++) {  						if (tokens [j].text == "'" || tokens [j].text == ")") {  							string ptype = "";  							for (int k = start; k <= j - 2; k++)  								ptype += tokens [k].text;  							var pid = tokens [j - 1].text;  							var type = env.GetTypeByKeyword (ptype);  							// _params[pid] = type;  							//func._params.Add(pid' type);  							if (type == null) {  								throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  							}  							func._paramnames.Add (pid);  							func._paramtypes.Add (type);  							start = j + 1;  						}  					}  				}  				int funcbegin = funcparamend + 1;  				if (tokens [funcbegin].text == "{") {  					int funcend = FindBlock (env' tokens' funcbegin);  					this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  					if (func.expr_runtime == null) {  						logger.Log_Warn ("警告，该函数编译为null，请检查");  					}  					(stype.function as SType).functions.Add (idname' func);  					i = funcend;  				} else if (tokens [funcbegin].text == ";") {  					func.expr_runtime = null;  					(stype.function as SType).functions.Add (idname' func);  					i = funcbegin;  				} else {  					throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  				}  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  			 {  				//get set 成员定义  				bool setpublic = true;  				bool haveset = false;  				for (int j = i + 3; j <= iend; j++) {  					if (tokens [j].text == "get") {  						setpublic = true;  					}  					if (tokens [j].text == "private") {  						setpublic = false;  					}  					if (tokens [j].text == "set") {  						haveset = true;  					}  					if (tokens [j].text == "}") {  						break;  					}  				}  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = !(haveset && setpublic);  				member.type = idtype;  				logger.Log ("发现Get/Set:" + idname);  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("Get/Set定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  			 {  				logger.Log ("发现成员定义:" + idname);  				var member = new SType.Member ();  				member.bStatic = bStatic;  				member.bPublic = bPublic;  				member.bReadOnly = false;  				member.type = idtype;  				//ICLS_Expression expr = null;  				if (tokens [i + 2].text == "=") {  					int posend = 0;  					for (int j = i; j < iend; j++) {  						if (tokens [j].text == ";") {  							posend = j - 1;  							break;  						}  					}  					int jbegin = i + 3;  					int jdep;  					int jend = FindCodeAny (tokens' ref jbegin' out jdep);  					if (jend < posend) {  						jend = posend;  					}  					if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  						logger.Log_Error ("成员定义错误");  					}  					i = jend;  				}  				(stype.function as SType).members.Add (idname' member);  			}  			bPublic = false;  			bStatic = false;  			continue;  		} else {  			throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "public") {  	bPublic = true;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "private") {  	bPublic = false;  	continue;  } else if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.KEYWORD && tokens [i].text == "static") {  	bStatic = true;  	continue;  } else if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE || (tokens [i].type == TokenType.IDENTIFIER && tokens [i].text == classname))//发现类型   {  	ICLS_Type idtype = env.GetTypeByKeyword ("null");  	bool bctor = false;  	if (tokens [i].type == TokenType.TYPE)//类型  	 {  		if (tokens [i].text == classname && tokens [i + 1].text == "(") {  			//构造函数  			bctor = true;  			i--;  		} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  			idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  			i += 2;  		} else if (tokens [i].text == "void") {  		} else {  			idtype = env.GetTypeByKeyword (tokens [i].text);  		}  	}  	if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称  	 {  		string idname = tokens [i + 1].text;  		if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  		 {  			logger.Log ("发现函数:" + idname);  			SType.Function func = new SType.Function ();  			func.bStatic = bStatic;  			func.bPublic = bPublic;  			int funcparambegin = i + 2;  			int funcparamend = FindBlock (env' tokens' funcparambegin);  			if (funcparamend - funcparambegin > 1) {  				int start = funcparambegin + 1;  				//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  				for (int j = funcparambegin + 1; j <= funcparamend; j++) {  					if (tokens [j].text == "'" || tokens [j].text == ")") {  						string ptype = "";  						for (int k = start; k <= j - 2; k++)  							ptype += tokens [k].text;  						var pid = tokens [j - 1].text;  						var type = env.GetTypeByKeyword (ptype);  						// _params[pid] = type;  						//func._params.Add(pid' type);  						if (type == null) {  							throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  						}  						func._paramnames.Add (pid);  						func._paramtypes.Add (type);  						start = j + 1;  					}  				}  			}  			int funcbegin = funcparamend + 1;  			if (tokens [funcbegin].text == "{") {  				int funcend = FindBlock (env' tokens' funcbegin);  				this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  				if (func.expr_runtime == null) {  					logger.Log_Warn ("警告，该函数编译为null，请检查");  				}  				(stype.function as SType).functions.Add (idname' func);  				i = funcend;  			} else if (tokens [funcbegin].text == ";") {  				func.expr_runtime = null;  				(stype.function as SType).functions.Add (idname' func);  				i = funcbegin;  			} else {  				throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  			}  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  		 {  			//get set 成员定义  			bool setpublic = true;  			bool haveset = false;  			for (int j = i + 3; j <= iend; j++) {  				if (tokens [j].text == "get") {  					setpublic = true;  				}  				if (tokens [j].text == "private") {  					setpublic = false;  				}  				if (tokens [j].text == "set") {  					haveset = true;  				}  				if (tokens [j].text == "}") {  					break;  				}  			}  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = !(haveset && setpublic);  			member.type = idtype;  			logger.Log ("发现Get/Set:" + idname);  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("Get/Set定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  		 {  			logger.Log ("发现成员定义:" + idname);  			var member = new SType.Member ();  			member.bStatic = bStatic;  			member.bPublic = bPublic;  			member.bReadOnly = false;  			member.type = idtype;  			//ICLS_Expression expr = null;  			if (tokens [i + 2].text == "=") {  				int posend = 0;  				for (int j = i; j < iend; j++) {  					if (tokens [j].text == ";") {  						posend = j - 1;  						break;  					}  				}  				int jbegin = i + 3;  				int jdep;  				int jend = FindCodeAny (tokens' ref jbegin' out jdep);  				if (jend < posend) {  					jend = posend;  				}  				if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  					logger.Log_Error ("成员定义错误");  				}  				i = jend;  			}  			(stype.function as SType).members.Add (idname' member);  		}  		bPublic = false;  		bStatic = false;  		continue;  	} else {  		throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE)//类型   {  	if (tokens [i].text == classname && tokens [i + 1].text == "(") {  		//构造函数  		bctor = true;  		i--;  	} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  		idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  		i += 2;  	} else if (tokens [i].text == "void") {  	} else {  		idtype = env.GetTypeByKeyword (tokens [i].text);  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].type == TokenType.TYPE)//类型   {  	if (tokens [i].text == classname && tokens [i + 1].text == "(") {  		//构造函数  		bctor = true;  		i--;  	} else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  		idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  		i += 2;  	} else if (tokens [i].text == "void") {  	} else {  		idtype = env.GetTypeByKeyword (tokens [i].text);  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].text == classname && tokens [i + 1].text == "(") {  	//构造函数  	bctor = true;  	i--;  } else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  	idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  	i += 2;  } else if (tokens [i].text == "void") {  } else {  	idtype = env.GetTypeByKeyword (tokens [i].text);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i].text == classname && tokens [i + 1].text == "(") {  	//构造函数  	bctor = true;  	i--;  } else if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  	idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  	i += 2;  } else if (tokens [i].text == "void") {  } else {  	idtype = env.GetTypeByKeyword (tokens [i].text);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  	idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  	i += 2;  } else if (tokens [i].text == "void") {  } else {  	idtype = env.GetTypeByKeyword (tokens [i].text);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].text == "[" && tokens [i + 2].text == "]") {  	idtype = env.GetTypeByKeyword (tokens [i].text + "[]");  	i += 2;  } else if (tokens [i].text == "void") {  } else {  	idtype = env.GetTypeByKeyword (tokens [i].text);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: i += 2;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 1].type == CSLE.TokenType.IDENTIFIER || bctor)//类型后面是名称   {  	string idname = tokens [i + 1].text;  	if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数  	 {  		logger.Log ("发现函数:" + idname);  		SType.Function func = new SType.Function ();  		func.bStatic = bStatic;  		func.bPublic = bPublic;  		int funcparambegin = i + 2;  		int funcparamend = FindBlock (env' tokens' funcparambegin);  		if (funcparamend - funcparambegin > 1) {  			int start = funcparambegin + 1;  			//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  			for (int j = funcparambegin + 1; j <= funcparamend; j++) {  				if (tokens [j].text == "'" || tokens [j].text == ")") {  					string ptype = "";  					for (int k = start; k <= j - 2; k++)  						ptype += tokens [k].text;  					var pid = tokens [j - 1].text;  					var type = env.GetTypeByKeyword (ptype);  					// _params[pid] = type;  					//func._params.Add(pid' type);  					if (type == null) {  						throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  					}  					func._paramnames.Add (pid);  					func._paramtypes.Add (type);  					start = j + 1;  				}  			}  		}  		int funcbegin = funcparamend + 1;  		if (tokens [funcbegin].text == "{") {  			int funcend = FindBlock (env' tokens' funcbegin);  			this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  			if (func.expr_runtime == null) {  				logger.Log_Warn ("警告，该函数编译为null，请检查");  			}  			(stype.function as SType).functions.Add (idname' func);  			i = funcend;  		} else if (tokens [funcbegin].text == ";") {  			func.expr_runtime = null;  			(stype.function as SType).functions.Add (idname' func);  			i = funcbegin;  		} else {  			throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  		}  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性  	 {  		//get set 成员定义  		bool setpublic = true;  		bool haveset = false;  		for (int j = i + 3; j <= iend; j++) {  			if (tokens [j].text == "get") {  				setpublic = true;  			}  			if (tokens [j].text == "private") {  				setpublic = false;  			}  			if (tokens [j].text == "set") {  				haveset = true;  			}  			if (tokens [j].text == "}") {  				break;  			}  		}  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = !(haveset && setpublic);  		member.type = idtype;  		logger.Log ("发现Get/Set:" + idname);  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("Get/Set定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	} else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义  	 {  		logger.Log ("发现成员定义:" + idname);  		var member = new SType.Member ();  		member.bStatic = bStatic;  		member.bPublic = bPublic;  		member.bReadOnly = false;  		member.type = idtype;  		//ICLS_Expression expr = null;  		if (tokens [i + 2].text == "=") {  			int posend = 0;  			for (int j = i; j < iend; j++) {  				if (tokens [j].text == ";") {  					posend = j - 1;  					break;  				}  			}  			int jbegin = i + 3;  			int jdep;  			int jend = FindCodeAny (tokens' ref jbegin' out jdep);  			if (jend < posend) {  				jend = posend;  			}  			if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  				logger.Log_Error ("成员定义错误");  			}  			i = jend;  		}  		(stype.function as SType).members.Add (idname' member);  	}  	bPublic = false;  	bStatic = false;  	continue;  } else {  	throw new Exception (filename + ":不可识别的表达式:" + tokens [i].ToString () + tokens [i].SourcePos ());  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "(")//参数开始'这是函数   {  	logger.Log ("发现函数:" + idname);  	SType.Function func = new SType.Function ();  	func.bStatic = bStatic;  	func.bPublic = bPublic;  	int funcparambegin = i + 2;  	int funcparamend = FindBlock (env' tokens' funcparambegin);  	if (funcparamend - funcparambegin > 1) {  		int start = funcparambegin + 1;  		//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  		for (int j = funcparambegin + 1; j <= funcparamend; j++) {  			if (tokens [j].text == "'" || tokens [j].text == ")") {  				string ptype = "";  				for (int k = start; k <= j - 2; k++)  					ptype += tokens [k].text;  				var pid = tokens [j - 1].text;  				var type = env.GetTypeByKeyword (ptype);  				// _params[pid] = type;  				//func._params.Add(pid' type);  				if (type == null) {  					throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  				}  				func._paramnames.Add (pid);  				func._paramtypes.Add (type);  				start = j + 1;  			}  		}  	}  	int funcbegin = funcparamend + 1;  	if (tokens [funcbegin].text == "{") {  		int funcend = FindBlock (env' tokens' funcbegin);  		this.Compiler_Expression_Block (tokens' env' funcbegin' funcend' out func.expr_runtime);  		if (func.expr_runtime == null) {  			logger.Log_Warn ("警告，该函数编译为null，请检查");  		}  		(stype.function as SType).functions.Add (idname' func);  		i = funcend;  	} else if (tokens [funcbegin].text == ";") {  		func.expr_runtime = null;  		(stype.function as SType).functions.Add (idname' func);  		i = funcbegin;  	} else {  		throw new Exception (filename + ":不可识别的函数表达式:" + tokens [funcbegin].ToString () + tokens [funcbegin].SourcePos ());  	}  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (funcparamend - funcparambegin > 1) {  	int start = funcparambegin + 1;  	//Dictionary<string' ICLS_Type> _params = new Dictionary<string' ICLS_Type>();  	for (int j = funcparambegin + 1; j <= funcparamend; j++) {  		if (tokens [j].text == "'" || tokens [j].text == ")") {  			string ptype = "";  			for (int k = start; k <= j - 2; k++)  				ptype += tokens [k].text;  			var pid = tokens [j - 1].text;  			var type = env.GetTypeByKeyword (ptype);  			// _params[pid] = type;  			//func._params.Add(pid' type);  			if (type == null) {  				throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  			}  			func._paramnames.Add (pid);  			func._paramtypes.Add (type);  			start = j + 1;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int j = funcparambegin + 1; j <= funcparamend; j++) {  	if (tokens [j].text == "'" || tokens [j].text == ")") {  		string ptype = "";  		for (int k = start; k <= j - 2; k++)  			ptype += tokens [k].text;  		var pid = tokens [j - 1].text;  		var type = env.GetTypeByKeyword (ptype);  		// _params[pid] = type;  		//func._params.Add(pid' type);  		if (type == null) {  			throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  		}  		func._paramnames.Add (pid);  		func._paramtypes.Add (type);  		start = j + 1;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [j].text == "'" || tokens [j].text == ")") {  	string ptype = "";  	for (int k = start; k <= j - 2; k++)  		ptype += tokens [k].text;  	var pid = tokens [j - 1].text;  	var type = env.GetTypeByKeyword (ptype);  	// _params[pid] = type;  	//func._params.Add(pid' type);  	if (type == null) {  		throw new Exception (filename + ":不可识别的函数头参数:" + tokens [funcparambegin].ToString () + tokens [funcparambegin].SourcePos ());  	}  	func._paramnames.Add (pid);  	func._paramtypes.Add (type);  	start = j + 1;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int k = start; k <= j - 2; k++)  	ptype += tokens [k].text;  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && tokens [i + 2].text == "{")//语句块开始，这是 getset属性   {  	//get set 成员定义  	bool setpublic = true;  	bool haveset = false;  	for (int j = i + 3; j <= iend; j++) {  		if (tokens [j].text == "get") {  			setpublic = true;  		}  		if (tokens [j].text == "private") {  			setpublic = false;  		}  		if (tokens [j].text == "set") {  			haveset = true;  		}  		if (tokens [j].text == "}") {  			break;  		}  	}  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = !(haveset && setpublic);  	member.type = idtype;  	logger.Log ("发现Get/Set:" + idname);  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("Get/Set定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  } else if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: for (int j = i + 3; j <= iend; j++) {  	if (tokens [j].text == "get") {  		setpublic = true;  	}  	if (tokens [j].text == "private") {  		setpublic = false;  	}  	if (tokens [j].text == "set") {  		haveset = true;  	}  	if (tokens [j].text == "}") {  		break;  	}  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].text == "=") {  	int jbegin = i + 3;  	int jdep;  	int jend = FindCodeAny (tokens' ref jbegin' out jdep);  	if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  		logger.Log_Error ("Get/Set定义错误");  	}  	i = jend;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].text == "=") {  	int jbegin = i + 3;  	int jdep;  	int jend = FindCodeAny (tokens' ref jbegin' out jdep);  	if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  		logger.Log_Error ("Get/Set定义错误");  	}  	i = jend;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].type == CSLE.TokenType.PUNCTUATION && (tokens [i + 2].text == "=" || tokens [i + 2].text == ";"))//这是成员定义   {  	logger.Log ("发现成员定义:" + idname);  	var member = new SType.Member ();  	member.bStatic = bStatic;  	member.bPublic = bPublic;  	member.bReadOnly = false;  	member.type = idtype;  	//ICLS_Expression expr = null;  	if (tokens [i + 2].text == "=") {  		int posend = 0;  		for (int j = i; j < iend; j++) {  			if (tokens [j].text == ";") {  				posend = j - 1;  				break;  			}  		}  		int jbegin = i + 3;  		int jdep;  		int jend = FindCodeAny (tokens' ref jbegin' out jdep);  		if (jend < posend) {  			jend = posend;  		}  		if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  			logger.Log_Error ("成员定义错误");  		}  		i = jend;  	}  	(stype.function as SType).members.Add (idname' member);  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].text == "=") {  	int posend = 0;  	for (int j = i; j < iend; j++) {  		if (tokens [j].text == ";") {  			posend = j - 1;  			break;  		}  	}  	int jbegin = i + 3;  	int jdep;  	int jend = FindCodeAny (tokens' ref jbegin' out jdep);  	if (jend < posend) {  		jend = posend;  	}  	if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  		logger.Log_Error ("成员定义错误");  	}  	i = jend;  }  
Magic Number,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,Compiler_Class,The following statement contains a magic number: if (tokens [i + 2].text == "=") {  	int posend = 0;  	for (int j = i; j < iend; j++) {  		if (tokens [j].text == ";") {  			posend = j - 1;  			break;  		}  	}  	int jbegin = i + 3;  	int jdep;  	int jend = FindCodeAny (tokens' ref jbegin' out jdep);  	if (jend < posend) {  		jend = posend;  	}  	if (!Compiler_Expression (tokens' env' jbegin' jend' out member.expr_defvalue)) {  		logger.Log_Error ("成员定义错误");  	}  	i = jend;  }  
Magic Number,CSLE,CLS_Expression_LoopBreak,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopBreak.cs,ComputeValue,The following statement contains a magic number: rv.breakBlock = 2;  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: do {  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  } while ((bool)expr_while.ComputeValue (content).value);  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: do {  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  } while ((bool)expr_while.ComputeValue (content).value);  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		bbreak = true;  }  
Magic Number,CSLE,CLS_Expression_LoopDowhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopDowhile.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: for (; ;) {  	if (expr_continue != null && !(bool)expr_continue.ComputeValue (content).value)  		break;  	//expr2  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  	if (expr_step != null)  		expr_step.ComputeValue (content);  	//expr3  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: for (; ;) {  	if (expr_continue != null && !(bool)expr_continue.ComputeValue (content).value)  		break;  	//expr2  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  	if (expr_step != null)  		expr_step.ComputeValue (content);  	//expr3  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		bbreak = true;  }  
Magic Number,CSLE,CLS_Expression_LoopFor,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopFor.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: while (it.MoveNext ()) {  	content.Set (define.value_name' it.Current);  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: while (it.MoveNext ()) {  	content.Set (define.value_name' it.Current);  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  	}  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		bbreak = true;  }  
Magic Number,CSLE,CLS_Expression_LoopForEach,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopForEach.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopIf,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopIf.cs,ComputeValue,The following statement contains a magic number: if (listParam.Count > 2)  	expr_go2 = listParam [2];  
Magic Number,CSLE,CLS_Expression_LoopIf,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopIf.cs,ComputeValue,The following statement contains a magic number: if (listParam.Count > 2)  	expr_go2 = listParam [2];  
Magic Number,CSLE,CLS_Expression_LoopIf,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopIf.cs,ComputeValue,The following statement contains a magic number: expr_go2 = listParam [2];  
Magic Number,CSLE,CLS_Expression_LoopReturn,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopReturn.cs,ComputeValue,The following statement contains a magic number: rv.breakBlock = 10;  
Magic Number,CSLE,CLS_Expression_LoopTry,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopTry.cs,ComputeValue,The following statement contains a magic number: try {  	ICLS_Expression expr = listParam [0];  	if (expr is CLS_Expression_Block) {  		expr.ComputeValue (content);  	} else {  		content.DepthAdd ();  		expr.ComputeValue (content);  		content.DepthRemove ();  	}  } catch (Exception err) {  	bool bParse = false;  	int i = 1;  	while (i < listParam.Count) {  		CLS_Expression_Define def = listParam [i] as CLS_Expression_Define;  		if (err.GetType () == (Type)def.value_type || err.GetType ().IsSubclassOf ((Type)def.value_type)) {  			content.DepthAdd ();  			content.DefineAndSet (def.value_name' def.value_type' err);  			listParam [i + 1].ComputeValue (content);  			content.DepthRemove ();  			bParse = true;  			break;  		}  		i += 2;  	}  	if (!bParse) {  		throw err;  	}  }  
Magic Number,CSLE,CLS_Expression_LoopTry,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopTry.cs,ComputeValue,The following statement contains a magic number: while (i < listParam.Count) {  	CLS_Expression_Define def = listParam [i] as CLS_Expression_Define;  	if (err.GetType () == (Type)def.value_type || err.GetType ().IsSubclassOf ((Type)def.value_type)) {  		content.DepthAdd ();  		content.DefineAndSet (def.value_name' def.value_type' err);  		listParam [i + 1].ComputeValue (content);  		content.DepthRemove ();  		bParse = true;  		break;  	}  	i += 2;  }  
Magic Number,CSLE,CLS_Expression_LoopTry,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopTry.cs,ComputeValue,The following statement contains a magic number: i += 2;  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: while ((bool)expr_while.ComputeValue (content).value) {  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: while ((bool)expr_while.ComputeValue (content).value) {  	if (expr_block != null) {  		if (expr_block is CLS_Expression_Block) {  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					break;  			}  		} else {  			content.DepthAdd ();  			bool bbreak = false;  			var v = expr_block.ComputeValue (content);  			if (v != null) {  				if (v.breakBlock > 2)  					vrt = v;  				if (v.breakBlock > 1)  					bbreak = true;  			}  			content.DepthRemove ();  			if (bbreak)  				break;  		}  		//if (v.breakBlock == 1) continue;  		//if (v.breakBlock == 2) break;  		//if (v.breakBlock == 10) return v;  	}  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block != null) {  	if (expr_block is CLS_Expression_Block) {  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				break;  		}  	} else {  		content.DepthAdd ();  		bool bbreak = false;  		var v = expr_block.ComputeValue (content);  		if (v != null) {  			if (v.breakBlock > 2)  				vrt = v;  			if (v.breakBlock > 1)  				bbreak = true;  		}  		content.DepthRemove ();  		if (bbreak)  			break;  	}  	//if (v.breakBlock == 1) continue;  	//if (v.breakBlock == 2) break;  	//if (v.breakBlock == 10) return v;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (expr_block is CLS_Expression_Block) {  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			break;  	}  } else {  	content.DepthAdd ();  	bool bbreak = false;  	var v = expr_block.ComputeValue (content);  	if (v != null) {  		if (v.breakBlock > 2)  			vrt = v;  		if (v.breakBlock > 1)  			bbreak = true;  	}  	content.DepthRemove ();  	if (bbreak)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		break;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (v != null) {  	if (v.breakBlock > 2)  		vrt = v;  	if (v.breakBlock > 1)  		bbreak = true;  }  
Magic Number,CSLE,CLS_Expression_LoopWhile,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Loop\CLS_Expression_LoopWhile.cs,ComputeValue,The following statement contains a magic number: if (v.breakBlock > 2)  	vrt = v;  
Magic Number,CSLE,CLS_Expression_Math3Value,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Math\CLS_Expression_Math3Value.cs,ComputeValue,The following statement contains a magic number: if (bv)  	result = listParam [1].ComputeValue (content);  else  	result = listParam [2].ComputeValue (content);  
Magic Number,CSLE,CLS_Expression_Math3Value,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Expression\Math\CLS_Expression_Math3Value.cs,ComputeValue,The following statement contains a magic number: result = listParam [2].ComputeValue (content);  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: if (func.expr_runtime != null) {  	CLS_Content content = new CLS_Content (env' true);  	try {  		content.DepthAdd ();  		content.CallThis = _func.callthis;  		content.CallType = _func.calltype;  		content.function = _func.function;  		content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  		content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  		content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  		func.expr_runtime.ComputeValue (content);  		content.DepthRemove ();  	} catch (Exception err) {  		string errinfo = "Dump Call in:";  		if (_func.calltype != null)  			errinfo += _func.calltype.Name + "::";  		if (_func.function != null)  			errinfo += _func.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: if (func.expr_runtime != null) {  	CLS_Content content = new CLS_Content (env' true);  	try {  		content.DepthAdd ();  		content.CallThis = _func.callthis;  		content.CallType = _func.calltype;  		content.function = _func.function;  		content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  		content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  		content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  		func.expr_runtime.ComputeValue (content);  		content.DepthRemove ();  	} catch (Exception err) {  		string errinfo = "Dump Call in:";  		if (_func.calltype != null)  			errinfo += _func.calltype.Name + "::";  		if (_func.function != null)  			errinfo += _func.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.CallThis = _func.callthis;  	content.CallType = _func.calltype;  	content.function = _func.function;  	content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  	content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  	content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  	func.expr_runtime.ComputeValue (content);  	content.DepthRemove ();  } catch (Exception err) {  	string errinfo = "Dump Call in:";  	if (_func.calltype != null)  		errinfo += _func.calltype.Name + "::";  	if (_func.function != null)  		errinfo += _func.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.CallThis = _func.callthis;  	content.CallType = _func.calltype;  	content.function = _func.function;  	content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  	content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  	content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  	func.expr_runtime.ComputeValue (content);  	content.DepthRemove ();  } catch (Exception err) {  	string errinfo = "Dump Call in:";  	if (_func.calltype != null)  		errinfo += _func.calltype.Name + "::";  	if (_func.function != null)  		errinfo += _func.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: if (expr != null) {  	try {  		content.DepthAdd ();  		content.DefineAndSet (pnames [0]' typeof(T)' param0);  		content.DefineAndSet (pnames [1]' typeof(T1)' param1);  		content.DefineAndSet (pnames [2]' typeof(T2)' param2);  		expr.ComputeValue (content);  		content.DepthRemove ();  	} catch (Exception err) {  		string errinfo = "Dump Call lambda in:";  		if (content.CallType != null)  			errinfo += content.CallType.Name + "::";  		if (content.function != null)  			errinfo += content.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.DefineAndSet (pnames [0]' typeof(T)' param0);  	content.DefineAndSet (pnames [1]' typeof(T1)' param1);  	content.DefineAndSet (pnames [2]' typeof(T2)' param2);  	expr.ComputeValue (content);  	content.DepthRemove ();  } catch (Exception err) {  	string errinfo = "Dump Call lambda in:";  	if (content.CallType != null)  		errinfo += content.CallType.Name + "::";  	if (content.function != null)  		errinfo += content.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (pnames [2]' typeof(T2)' param2);  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: if (func.expr_runtime != null) {  	CLS_Content content = new CLS_Content (env' true);  	try {  		content.DepthAdd ();  		content.CallThis = _func.callthis;  		content.CallType = _func.calltype;  		content.function = _func.function;  		content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  		content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  		content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  		CLS_Content.Value retValue = func.expr_runtime.ComputeValue (content);  		content.DepthRemove ();  		return (ReturnType)retValue.value;  	} catch (Exception err) {  		string errinfo = "Dump Call in:";  		if (_func.calltype != null)  			errinfo += _func.calltype.Name + "::";  		if (_func.function != null)  			errinfo += _func.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: if (func.expr_runtime != null) {  	CLS_Content content = new CLS_Content (env' true);  	try {  		content.DepthAdd ();  		content.CallThis = _func.callthis;  		content.CallType = _func.calltype;  		content.function = _func.function;  		content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  		content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  		content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  		CLS_Content.Value retValue = func.expr_runtime.ComputeValue (content);  		content.DepthRemove ();  		return (ReturnType)retValue.value;  	} catch (Exception err) {  		string errinfo = "Dump Call in:";  		if (_func.calltype != null)  			errinfo += _func.calltype.Name + "::";  		if (_func.function != null)  			errinfo += _func.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.CallThis = _func.callthis;  	content.CallType = _func.calltype;  	content.function = _func.function;  	content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  	content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  	content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  	CLS_Content.Value retValue = func.expr_runtime.ComputeValue (content);  	content.DepthRemove ();  	return (ReturnType)retValue.value;  } catch (Exception err) {  	string errinfo = "Dump Call in:";  	if (_func.calltype != null)  		errinfo += _func.calltype.Name + "::";  	if (_func.function != null)  		errinfo += _func.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.CallThis = _func.callthis;  	content.CallType = _func.calltype;  	content.function = _func.function;  	content.DefineAndSet (func._paramnames [0]' func._paramtypes [0].type' param0);  	content.DefineAndSet (func._paramnames [1]' func._paramtypes [1].type' param1);  	content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  	CLS_Content.Value retValue = func.expr_runtime.ComputeValue (content);  	content.DepthRemove ();  	return (ReturnType)retValue.value;  } catch (Exception err) {  	string errinfo = "Dump Call in:";  	if (_func.calltype != null)  		errinfo += _func.calltype.Name + "::";  	if (_func.function != null)  		errinfo += _func.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (func._paramnames [2]' func._paramtypes [2].type' param2);  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: if (expr != null) {  	try {  		content.DepthAdd ();  		content.DefineAndSet (pnames [0]' typeof(T)' param0);  		content.DefineAndSet (pnames [1]' typeof(T1)' param1);  		content.DefineAndSet (pnames [2]' typeof(T2)' param2);  		CLS_Content.Value retValue = expr.ComputeValue (content);  		content.DepthRemove ();  		return (ReturnType)retValue.value;  	} catch (Exception err) {  		string errinfo = "Dump Call lambda in:";  		if (content.CallType != null)  			errinfo += content.CallType.Name + "::";  		if (content.function != null)  			errinfo += content.function;  		errinfo += "\n";  		env.logger.Log (errinfo + content.Dump ());  		throw err;  	}  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: try {  	content.DepthAdd ();  	content.DefineAndSet (pnames [0]' typeof(T)' param0);  	content.DefineAndSet (pnames [1]' typeof(T1)' param1);  	content.DefineAndSet (pnames [2]' typeof(T2)' param2);  	CLS_Content.Value retValue = expr.ComputeValue (content);  	content.DepthRemove ();  	return (ReturnType)retValue.value;  } catch (Exception err) {  	string errinfo = "Dump Call lambda in:";  	if (content.CallType != null)  		errinfo += content.CallType.Name + "::";  	if (content.function != null)  		errinfo += content.function;  	errinfo += "\n";  	env.logger.Log (errinfo + content.Dump ());  	throw err;  }  
Magic Number,CSLE,RegHelper_DeleNonVoidAction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_DeleNonVoidAction.cs,CreateDelegate,The following statement contains a magic number: content.DefineAndSet (pnames [2]' typeof(T2)' param2);  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,StaticCall,The following statement contains a magic number: if (targetop == null) {  	if (function [function.Length - 1] == '>')//这是一个临时的模板函数调用  	 {  		int sppos = function.IndexOf ('<'' 0);  		string tfunc = function.Substring (0' sppos);  		string strparam = function.Substring (sppos + 1' function.Length - sppos - 2);  		string[] sf = strparam.Split (''');  		//string tfunc = sf[0];  		Type[] gtypes = new Type[sf.Length];  		for (int i = 0; i < sf.Length; i++) {  			gtypes [i] = environment.environment.GetTypeByKeyword (sf [i]).type;  		}  		targetop = FindTMethod (type' tfunc' _params' gtypes);  	}  	if (targetop == null) {  		Type ptype = type.BaseType;  		while (ptype != null) {  			targetop = ptype.GetMethod (function' types.ToArray ());  			if (targetop != null)  				break;  			var t = environment.environment.GetType (ptype);  			try {  				return t.function.StaticCall (environment' function' _params' cache);  			} catch {  			}  			ptype = ptype.BaseType;  		}  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,StaticCall,The following statement contains a magic number: if (function [function.Length - 1] == '>')//这是一个临时的模板函数调用   {  	int sppos = function.IndexOf ('<'' 0);  	string tfunc = function.Substring (0' sppos);  	string strparam = function.Substring (sppos + 1' function.Length - sppos - 2);  	string[] sf = strparam.Split (''');  	//string tfunc = sf[0];  	Type[] gtypes = new Type[sf.Length];  	for (int i = 0; i < sf.Length; i++) {  		gtypes [i] = environment.environment.GetTypeByKeyword (sf [i]).type;  	}  	targetop = FindTMethod (type' tfunc' _params' gtypes);  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCall,The following statement contains a magic number: if (targetop == null) {  	if (function [function.Length - 1] == '>')//这是一个临时的模板函数调用  	 {  		int sppos = function.IndexOf ('<'' 0);  		string tfunc = function.Substring (0' sppos);  		string strparam = function.Substring (sppos + 1' function.Length - sppos - 2);  		string[] sf = strparam.Split (''');  		//string tfunc = sf[0];  		Type[] gtypes = new Type[sf.Length];  		for (int i = 0; i < sf.Length; i++) {  			gtypes [i] = environment.environment.GetTypeByKeyword (sf [i]).type;  		}  		targetop = FindTMethod (type' tfunc' _params' gtypes);  		var ps = targetop.GetParameters ();  		for (int i = 0; i < Math.Min (ps.Length' _oparams.Count); i++) {  			if (ps [i].ParameterType != (Type)_params [i].type) {  				_oparams [i] = environment.environment.GetType (_params [i].type).ConvertTo (environment' _oparams [i]' ps [i].ParameterType);  			}  		}  	} else {  		if (!bEm) {  			foreach (var s in type.GetInterfaces ()) {  				targetop = s.GetMethod (function' types.ToArray ());  				if (targetop != null)  					break;  			}  		}  		if (targetop == null) {  			//因为有cache的存在，可以更慢更多的查找啦，哈哈哈哈  			targetop = GetMethodSlow (environment' false' function' types' _oparams);  			needConvert = true;  		}  		if (targetop == null) {  			throw new Exception ("函数不存在function:" + type.ToString () + "." + function);  		}  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberCall,The following statement contains a magic number: if (function [function.Length - 1] == '>')//这是一个临时的模板函数调用   {  	int sppos = function.IndexOf ('<'' 0);  	string tfunc = function.Substring (0' sppos);  	string strparam = function.Substring (sppos + 1' function.Length - sppos - 2);  	string[] sf = strparam.Split (''');  	//string tfunc = sf[0];  	Type[] gtypes = new Type[sf.Length];  	for (int i = 0; i < sf.Length; i++) {  		gtypes [i] = environment.environment.GetTypeByKeyword (sf [i]).type;  	}  	targetop = FindTMethod (type' tfunc' _params' gtypes);  	var ps = targetop.GetParameters ();  	for (int i = 0; i < Math.Min (ps.Length' _oparams.Count); i++) {  		if (ps [i].ParameterType != (Type)_params [i].type) {  			_oparams [i] = environment.environment.GetType (_params [i].type).ConvertTo (environment' _oparams [i]' ps [i].ParameterType);  		}  	}  } else {  	if (!bEm) {  		foreach (var s in type.GetInterfaces ()) {  			targetop = s.GetMethod (function' types.ToArray ());  			if (targetop != null)  				break;  		}  	}  	if (targetop == null) {  		//因为有cache的存在，可以更慢更多的查找啦，哈哈哈哈  		targetop = GetMethodSlow (environment' false' function' types' _oparams);  		needConvert = true;  	}  	if (targetop == null) {  		throw new Exception ("函数不存在function:" + type.ToString () + "." + function);  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (!memberValuegetCaches.TryGetValue (valuename' out c)) {  	c = new MemberValueCache ();  	memberValuegetCaches [valuename] = c;  	c.finfo = type.GetField (valuename);  	if (c.finfo == null) {  		c.minfo = type.GetMethod ("get_" + valuename);  		if (c.minfo == null) {  			c.einfo = type.GetEvent (valuename);  			if (c.einfo == null) {  				c.type = -1;  				return null;  			} else {  				c.type = 3;  			}  		} else {  			c.type = 2;  		}  	} else {  		c.type = 1;  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (!memberValuegetCaches.TryGetValue (valuename' out c)) {  	c = new MemberValueCache ();  	memberValuegetCaches [valuename] = c;  	c.finfo = type.GetField (valuename);  	if (c.finfo == null) {  		c.minfo = type.GetMethod ("get_" + valuename);  		if (c.minfo == null) {  			c.einfo = type.GetEvent (valuename);  			if (c.einfo == null) {  				c.type = -1;  				return null;  			} else {  				c.type = 3;  			}  		} else {  			c.type = 2;  		}  	} else {  		c.type = 1;  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (c.finfo == null) {  	c.minfo = type.GetMethod ("get_" + valuename);  	if (c.minfo == null) {  		c.einfo = type.GetEvent (valuename);  		if (c.einfo == null) {  			c.type = -1;  			return null;  		} else {  			c.type = 3;  		}  	} else {  		c.type = 2;  	}  } else {  	c.type = 1;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (c.finfo == null) {  	c.minfo = type.GetMethod ("get_" + valuename);  	if (c.minfo == null) {  		c.einfo = type.GetEvent (valuename);  		if (c.einfo == null) {  			c.type = -1;  			return null;  		} else {  			c.type = 3;  		}  	} else {  		c.type = 2;  	}  } else {  	c.type = 1;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (c.minfo == null) {  	c.einfo = type.GetEvent (valuename);  	if (c.einfo == null) {  		c.type = -1;  		return null;  	} else {  		c.type = 3;  	}  } else {  	c.type = 2;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (c.minfo == null) {  	c.einfo = type.GetEvent (valuename);  	if (c.einfo == null) {  		c.type = -1;  		return null;  	} else {  		c.type = 3;  	}  } else {  	c.type = 2;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: if (c.einfo == null) {  	c.type = -1;  	return null;  } else {  	c.type = 3;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: c.type = 3;  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: c.type = 2;  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: switch (c.type) {  case 1:  	v.value = c.finfo.GetValue (object_this);  	v.type = c.finfo.FieldType;  	break;  case 2:  	v.value = c.minfo.Invoke (object_this' null);  	v.type = c.minfo.ReturnType;  	break;  case 3:  	v.value = new DeleEvent (object_this' c.einfo);  	v.type = c.einfo.EventHandlerType;  	break;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following statement contains a magic number: switch (c.type) {  case 1:  	v.value = c.finfo.GetValue (object_this);  	v.type = c.finfo.FieldType;  	break;  case 2:  	v.value = c.minfo.Invoke (object_this' null);  	v.type = c.minfo.ReturnType;  	break;  case 3:  	v.value = new DeleEvent (object_this' c.einfo);  	v.type = c.einfo.EventHandlerType;  	break;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (!memberValuesetCaches.TryGetValue (valuename' out c)) {  	c = new MemberValueCache ();  	memberValuesetCaches [valuename] = c;  	c.finfo = type.GetField (valuename);  	if (c.finfo == null) {  		c.minfo = type.GetMethod ("set_" + valuename);  		var mss = type.GetMethods ();  		if (c.minfo == null) {  			if (type.GetMethod ("add_" + valuename) != null) {  				c.type = 3;  				//event;  			} else {  				c.type = -1;  				return false;  			}  		} else {  			c.type = 2;  		}  	} else {  		c.type = 1;  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (!memberValuesetCaches.TryGetValue (valuename' out c)) {  	c = new MemberValueCache ();  	memberValuesetCaches [valuename] = c;  	c.finfo = type.GetField (valuename);  	if (c.finfo == null) {  		c.minfo = type.GetMethod ("set_" + valuename);  		var mss = type.GetMethods ();  		if (c.minfo == null) {  			if (type.GetMethod ("add_" + valuename) != null) {  				c.type = 3;  				//event;  			} else {  				c.type = -1;  				return false;  			}  		} else {  			c.type = 2;  		}  	} else {  		c.type = 1;  	}  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.finfo == null) {  	c.minfo = type.GetMethod ("set_" + valuename);  	var mss = type.GetMethods ();  	if (c.minfo == null) {  		if (type.GetMethod ("add_" + valuename) != null) {  			c.type = 3;  			//event;  		} else {  			c.type = -1;  			return false;  		}  	} else {  		c.type = 2;  	}  } else {  	c.type = 1;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.finfo == null) {  	c.minfo = type.GetMethod ("set_" + valuename);  	var mss = type.GetMethods ();  	if (c.minfo == null) {  		if (type.GetMethod ("add_" + valuename) != null) {  			c.type = 3;  			//event;  		} else {  			c.type = -1;  			return false;  		}  	} else {  		c.type = 2;  	}  } else {  	c.type = 1;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.minfo == null) {  	if (type.GetMethod ("add_" + valuename) != null) {  		c.type = 3;  		//event;  	} else {  		c.type = -1;  		return false;  	}  } else {  	c.type = 2;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.minfo == null) {  	if (type.GetMethod ("add_" + valuename) != null) {  		c.type = 3;  		//event;  	} else {  		c.type = -1;  		return false;  	}  } else {  	c.type = 2;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (type.GetMethod ("add_" + valuename) != null) {  	c.type = 3;  	//event;  } else {  	c.type = -1;  	return false;  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: c.type = 3;  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: c.type = 2;  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.type == 1) {  	if (value != null && value.GetType () != c.finfo.FieldType) {  		value = content.environment.GetType (value.GetType ()).ConvertTo (content' value' c.finfo.FieldType);  	}  	c.finfo.SetValue (object_this' value);  } else if (c.type == 2) {  	var ptype = c.minfo.GetParameters () [0].ParameterType;  	if (value != null && value.GetType () != ptype) {  		value = content.environment.GetType (value.GetType ()).ConvertTo (content' value' ptype);  	}  	c.minfo.Invoke (object_this' new object[] {  		value  	});  }  
Magic Number,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueSet,The following statement contains a magic number: if (c.type == 2) {  	var ptype = c.minfo.GetParameters () [0].ParameterType;  	if (value != null && value.GetType () != ptype) {  		value = content.environment.GetType (value.GetType ()).ConvertTo (content' value' ptype);  	}  	c.minfo.Invoke (object_this' new object[] {  		value  	});  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (method.ReturnType == typeof(void)) {  	if (pp.Length == 0) {  		return new RegHelper_DeleAction (type' keyword);  	} else if (pp.Length == 1) {  		var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  			pp [0].ParameterType  		});  		return gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type;  	} else if (pp.Length == 2) {  		var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else if (pp.Length == 3) {  		var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  		return (gtype.GetConstructors () [0].Invoke (new object[] {  			type'  			keyword  		}) as RegHelper_Type);  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  } else {  	Type gtype = null;  	if (pp.Length == 0) {  		gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  			method.ReturnType  		});  	} else if (pp.Length == 1) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType  		});  	} else if (pp.Length == 2) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType  		});  	} else if (pp.Length == 3) {  		gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  			method.ReturnType'  			pp [0].ParameterType'  			pp [1].ParameterType'  			pp [2].ParameterType  		});  	} else {  		throw new Exception ("还没有支持这么多参数的委托");  	}  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	return new RegHelper_DeleAction (type' keyword);  } else if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	return new RegHelper_DeleAction (type' keyword);  } else if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	return new RegHelper_DeleAction (type' keyword);  } else if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	var gtype = typeof(RegHelper_DeleAction<>).MakeGenericType (new Type[] {  		pp [0].ParameterType  	});  	return gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type;  } else if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	var gtype = typeof(RegHelper_DeleAction<' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 3) {  	var gtype = typeof(RegHelper_DeleAction<' ' >).MakeGenericType (new Type[] {  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  	return (gtype.GetConstructors () [0].Invoke (new object[] {  		type'  		keyword  	}) as RegHelper_Type);  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  		method.ReturnType  	});  } else if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  		method.ReturnType  	});  } else if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 0) {  	gtype = typeof(RegHelper_DeleNonVoidAction<>).MakeGenericType (new Type[] {  		method.ReturnType  	});  } else if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 1) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType  	});  } else if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 2) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType  	});  } else if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: if (pp.Length == 3) {  	gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  		method.ReturnType'  		pp [0].ParameterType'  		pp [1].ParameterType'  		pp [2].ParameterType  	});  } else {  	throw new Exception ("还没有支持这么多参数的委托");  }  
Magic Number,CSLE,RegHelper_Type,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MakeType,The following statement contains a magic number: gtype = typeof(RegHelper_DeleNonVoidAction<' ' ' >).MakeGenericType (new Type[] {  	method.ReturnType'  	pp [0].ParameterType'  	pp [1].ParameterType'  	pp [2].ParameterType  });  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\"') {  	t.text = "\"";  	int pos = nstart + 1;  	bool bend = false;  	while (pos < line.Length) {  		char c = line [pos];  		if (c == '\n') {  			throw new Exception ("查找字符串失败");  		}  		if (c == '\"') {  			t.type = TokenType.STRING;  			bend = true;  			//break;  		}  		if (c == '\\') {  			pos++;  			c = line [pos];  			if (c == '\\') {  				t.text += '\\';  				pos++;  				continue;  			} else if (c == '"') {  				t.text += '\"';  				pos++;  				continue;  			} else if (c == '\'') {  				t.text += '\'';  				pos++;  				continue;  			} else if (c == '0') {  				t.text += '\0';  				pos++;  				continue;  			} else if (c == 'a') {  				t.text += '\a';  				pos++;  				continue;  			} else if (c == 'b') {  				t.text += '\b';  				pos++;  				continue;  			} else if (c == 'f') {  				t.text += '\f';  				pos++;  				continue;  			} else if (c == 'n') {  				t.text += '\n';  				pos++;  				continue;  			} else if (c == 'r') {  				t.text += '\r';  				pos++;  				continue;  			} else if (c == 't') {  				t.text += '\t';  				pos++;  				continue;  			} else if (c == 'v') {  				t.text += '\v';  				pos++;  				continue;  			} else {  				throw new Exception ("不可识别的转义序列:" + t.text);  			}  		}  		t.text += line [pos];  		pos++;  		if (bend)  			return pos;  	}  	throw new Exception ("查找字符串失败");  } else if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '\'')//char   {  	int nend = line.IndexOf ('\''' nstart + 1);  	int nsub = line.IndexOf ('\\'' nstart + 1);  	while (nsub > 0 && nsub < nend) {  		nend = line.IndexOf ('\''' nsub + 2);  		nsub = line.IndexOf ('\\'' nsub + 2);  	}  	if (nend - nstart + 1 < 1)  		throw new Exception ("查找字符失败");  	t.type = TokenType.VALUE;  	int pos = nend + 1;  	t.text = line.Substring (nstart' nend - nstart + 1);  	t.text = t.text.Replace ("\\\""' "\"");  	t.text = t.text.Replace ("\\\'"' "\'");  	t.text = t.text.Replace ("\\\\"' "\\");  	t.text = t.text.Replace ("\\0"' "\0");  	t.text = t.text.Replace ("\\a"' "\a");  	t.text = t.text.Replace ("\\b"' "\b");  	t.text = t.text.Replace ("\\f"' "\f");  	t.text = t.text.Replace ("\\n"' "\n");  	t.text = t.text.Replace ("\\r"' "\r");  	t.text = t.text.Replace ("\\t"' "\t");  	t.text = t.text.Replace ("\\v"' "\v");  	int sp = t.text.IndexOf ('\\');  	if (sp > 0) {  		throw new Exception ("不可识别的转义序列:" + t.text.Substring (sp));  	}  	if (t.text.Length > 3) {  		throw new Exception ("char 不可超过一个字节(" + t.line + ")");  	}  	return pos;  } else if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: while (nsub > 0 && nsub < nend) {  	nend = line.IndexOf ('\''' nsub + 2);  	nsub = line.IndexOf ('\\'' nsub + 2);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: while (nsub > 0 && nsub < nend) {  	nend = line.IndexOf ('\''' nsub + 2);  	nsub = line.IndexOf ('\\'' nsub + 2);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: nend = line.IndexOf ('\''' nsub + 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: nsub = line.IndexOf ('\\'' nsub + 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (t.text.Length > 3) {  	throw new Exception ("char 不可超过一个字节(" + t.line + ")");  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')// / /= 注释   {  	if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 2);  	} else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  		t.type = TokenType.COMMENT;  		int enterpos = line.IndexOf ('\n'' nstart + 2);  		if (enterpos < 0)  			t.text = line.Substring (nstart);  		else  			t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  	} else {  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  	}  	return nstart + t.text.Length;  } else if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 2);  } else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  	t.type = TokenType.COMMENT;  	int enterpos = line.IndexOf ('\n'' nstart + 2);  	if (enterpos < 0)  		t.text = line.Substring (nstart);  	else  		t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  } else {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 1);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 2);  } else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  	t.type = TokenType.COMMENT;  	int enterpos = line.IndexOf ('\n'' nstart + 2);  	if (enterpos < 0)  		t.text = line.Substring (nstart);  	else  		t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  } else {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 1);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=') {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 2);  } else if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  	t.type = TokenType.COMMENT;  	int enterpos = line.IndexOf ('\n'' nstart + 2);  	if (enterpos < 0)  		t.text = line.Substring (nstart);  	else  		t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  } else {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 1);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  	t.type = TokenType.COMMENT;  	int enterpos = line.IndexOf ('\n'' nstart + 2);  	if (enterpos < 0)  		t.text = line.Substring (nstart);  	else  		t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  } else {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 1);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '/') {  	t.type = TokenType.COMMENT;  	int enterpos = line.IndexOf ('\n'' nstart + 2);  	if (enterpos < 0)  		t.text = line.Substring (nstart);  	else  		t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  } else {  	t.type = TokenType.PUNCTUATION;  	t.text = line.Substring (nstart' 1);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (enterpos < 0)  	t.text = line.Substring (nstart);  else  	t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' line.IndexOf ('\n'' nstart + 2) - nstart);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '=')//= == =>   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else if (nstart < line.Length - 1 && line [nstart + 1] == '>')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '>')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '!')//= ==   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '+')//+ += ++   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } //通用的一元二元运算符检查  else if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && (line [nstart + 1] == '=' || line [nstart + 1] == '+'))  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '-')//- -= -- 负数也先作为符号处理   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=' || line [nstart + 1] == '-')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '*')//* *=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '/')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '%')/// /=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '>')//> >=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '<')//< <=   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '=')  		t.text = line.Substring (nstart' 2);  	else  		t.text = line.Substring (nstart' 1);  	return nstart + t.text.Length;  } else if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '=')  	t.text = line.Substring (nstart' 2);  else  	t.text = line.Substring (nstart' 1);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '&')//&&   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '&')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '&')  	t.text = line.Substring (nstart' 2);  else  	return -1;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '|')//||   {  	t.type = TokenType.PUNCTUATION;  	if (nstart < line.Length - 1 && line [nstart + 1] == '|')  		t.text = line.Substring (nstart' 2);  	else  		return -1;  } else if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (nstart < line.Length - 1 && line [nstart + 1] == '|')  	t.text = line.Substring (nstart' 2);  else  	return -1;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsLetter (line' nstart) || line [nstart] == '_') {  	//字母逻辑  	//判断完整性  	int i = nstart + 1;  	while (i < line.Length && (char.IsLetterOrDigit (line' i) || line [i] == '_')) {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	//判断字母类型： 关键字 类型 标识符  	if (keywords.Contains (t.text))//foreach (string s in keywords)  	 {  		//if (t.text == s)  		{  			t.type = TokenType.KEYWORD;  			return nstart + t.text.Length;  		}  	}  	if (types.Contains (t.text))//foreach (string s in types)  	 {  		//if (t.text == s)  		{  			while (line [i] == ' ' && i < line.Length) {  				i++;  			}  			if (line [i] == '<')/*  || line[i] == '['*/ {  				int dep = 0;  				string text = t.text;  				while (i < line.Length) {  					if (line [i] == '<')  						dep++;  					if (line [i] == '>')  						dep--;  					if (line [i] == ';' || line [i] == '(' || line [i] == '{') {  						break;  					}  					if (line [i] != ' ')  						text += line [i];  					i++;  					if (dep == 0) {  						t.text = text;  						break;  					}  				}  				//if (types.Contains(t.text))//自动注册  				{  					t.type = TokenType.TYPE;  					return i;  				}  			} else {  				t.type = TokenType.TYPE;  				return nstart + t.text.Length;  			}  		}  	}  	while (i < line.Length && line [i] == ' ') {  		i++;  	}  	if (i < line.Length && (line [i] == '<'/* || line[i] == '['*/))//检查特别类型  	 {  		int dep = 0;  		string text = t.text;  		while (i < line.Length) {  			if (line [i] == '<') {  				dep++;  				i++;  				text += '<';  				continue;  			}  			if (line [i] == '>') {  				dep--;  				i++;  				if (dep == 0) {  					t.text = text + '>';  					break;  				}  				continue;  			}  			Token tt;  			int nnstart = FindStart (line' i);  			i = GetToken (line' nnstart' out tt);  			if (tt.type != TokenType.IDENTIFIER && tt.type != TokenType.TYPE && tt.text != "'") {  				break;  			}  			text += tt.text;  		}  		if (types.Contains (t.text)) {  			t.type = TokenType.TYPE;  			return i;  		} else if (dep == 0) {  			t.type = TokenType.IDENTIFIER;  			return i;  		}  		//foreach (string s in types)  		//{  		//    if (s.Length > t.text.Length && line.IndexOf(s' nstart) == nstart)  		//    {  		//        t.type = TokenType.TYPE;  		//        t.text = s;  		//        return nstart + s.Length;  		//    }  		//}  	}  	t.type = TokenType.IDENTIFIER;  	return nstart + t.text.Length;  } else if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsPunctuation (line' nstart)) {  	//else  	{  		t.type = TokenType.PUNCTUATION;  		t.text = line.Substring (nstart' 1);  		return nstart + t.text.Length;  	//符号逻辑  	//-号逻辑  	//"号逻辑  	///逻辑  	//其他符号  	}  } else if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (char.IsNumber (line' nstart)) {  	//数字逻辑  	//判断数字合法性  	if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....  	 {  		int iend = nstart + 2;  		for (int i = nstart + 2; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		t.text = line.Substring (nstart' iend - nstart + 1);  	} else {  		//纯数字  		int iend = nstart;  		for (int i = nstart + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				iend = i;  			} else {  				break;  			}  		}  		t.type = TokenType.VALUE;  		int dend = iend + 1;  		if (dend < line.Length && line [dend] == '.') {  			int fend = dend;  			for (int i = dend + 1; i < line.Length; i++) {  				if (char.IsNumber (line' i)) {  					fend = i;  				} else {  					break;  				}  			}  			if (fend + 1 < line.Length && line [fend + 1] == 'f') {  				t.text = line.Substring (nstart' fend + 2 - nstart);  			} else {  				t.text = line.Substring (nstart' fend + 1 - nstart);  			}  			//.111  			//.123f  		} else {  			if (dend < line.Length && line [dend] == 'f') {  				t.text = line.Substring (nstart' dend - nstart + 1);  			} else {  				t.text = line.Substring (nstart' dend - nstart);  			}  		}  	}  	return nstart + t.text.Length;  } else {  	//不可识别逻辑  	int i = nstart + 1;  	while (i < line.Length - 1 && char.IsSeparator (line' i) == false && line [i] != '\n' && line [i] != '\r' && line [i] != '\t') {  		i++;  	}  	t.text = line.Substring (nstart' i - nstart);  	return nstart + t.text.Length;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....   {  	int iend = nstart + 2;  	for (int i = nstart + 2; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	t.text = line.Substring (nstart' iend - nstart + 1);  } else {  	//纯数字  	int iend = nstart;  	for (int i = nstart + 1; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	int dend = iend + 1;  	if (dend < line.Length && line [dend] == '.') {  		int fend = dend;  		for (int i = dend + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				fend = i;  			} else {  				break;  			}  		}  		if (fend + 1 < line.Length && line [fend + 1] == 'f') {  			t.text = line.Substring (nstart' fend + 2 - nstart);  		} else {  			t.text = line.Substring (nstart' fend + 1 - nstart);  		}  		//.111  		//.123f  	} else {  		if (dend < line.Length && line [dend] == 'f') {  			t.text = line.Substring (nstart' dend - nstart + 1);  		} else {  			t.text = line.Substring (nstart' dend - nstart);  		}  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....   {  	int iend = nstart + 2;  	for (int i = nstart + 2; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	t.text = line.Substring (nstart' iend - nstart + 1);  } else {  	//纯数字  	int iend = nstart;  	for (int i = nstart + 1; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	int dend = iend + 1;  	if (dend < line.Length && line [dend] == '.') {  		int fend = dend;  		for (int i = dend + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				fend = i;  			} else {  				break;  			}  		}  		if (fend + 1 < line.Length && line [fend + 1] == 'f') {  			t.text = line.Substring (nstart' fend + 2 - nstart);  		} else {  			t.text = line.Substring (nstart' fend + 1 - nstart);  		}  		//.111  		//.123f  	} else {  		if (dend < line.Length && line [dend] == 'f') {  			t.text = line.Substring (nstart' dend - nstart + 1);  		} else {  			t.text = line.Substring (nstart' dend - nstart);  		}  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (line [nstart] == '0' && line [nstart + 1] == 'x')//0x....   {  	int iend = nstart + 2;  	for (int i = nstart + 2; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	t.text = line.Substring (nstart' iend - nstart + 1);  } else {  	//纯数字  	int iend = nstart;  	for (int i = nstart + 1; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			iend = i;  		} else {  			break;  		}  	}  	t.type = TokenType.VALUE;  	int dend = iend + 1;  	if (dend < line.Length && line [dend] == '.') {  		int fend = dend;  		for (int i = dend + 1; i < line.Length; i++) {  			if (char.IsNumber (line' i)) {  				fend = i;  			} else {  				break;  			}  		}  		if (fend + 1 < line.Length && line [fend + 1] == 'f') {  			t.text = line.Substring (nstart' fend + 2 - nstart);  		} else {  			t.text = line.Substring (nstart' fend + 1 - nstart);  		}  		//.111  		//.123f  	} else {  		if (dend < line.Length && line [dend] == 'f') {  			t.text = line.Substring (nstart' dend - nstart + 1);  		} else {  			t.text = line.Substring (nstart' dend - nstart);  		}  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: for (int i = nstart + 2; i < line.Length; i++) {  	if (char.IsNumber (line' i)) {  		iend = i;  	} else {  		break;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (dend < line.Length && line [dend] == '.') {  	int fend = dend;  	for (int i = dend + 1; i < line.Length; i++) {  		if (char.IsNumber (line' i)) {  			fend = i;  		} else {  			break;  		}  	}  	if (fend + 1 < line.Length && line [fend + 1] == 'f') {  		t.text = line.Substring (nstart' fend + 2 - nstart);  	} else {  		t.text = line.Substring (nstart' fend + 1 - nstart);  	}  	//.111  	//.123f  } else {  	if (dend < line.Length && line [dend] == 'f') {  		t.text = line.Substring (nstart' dend - nstart + 1);  	} else {  		t.text = line.Substring (nstart' dend - nstart);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: if (fend + 1 < line.Length && line [fend + 1] == 'f') {  	t.text = line.Substring (nstart' fend + 2 - nstart);  } else {  	t.text = line.Substring (nstart' fend + 1 - nstart);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,GetToken,The following statement contains a magic number: t.text = line.Substring (nstart' fend + 2 - nstart);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: while (n >= 0) {  	Token t;  	t.line = this.line;  	int nstart = FindStart (lines' n);  	t.line = this.line;  	int nend = GetToken (lines' nstart' out t);  	if (nend >= 0) {  		for (int i = nstart; i < nend; i++) {  			if (lines [i] == '\n')  				line++;  		}  	}  	n = nend;  	if (n >= 0) {  		if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  			string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			if (types.Contains (ntype)) {  				//类中类，合并之  				t.type = TokenType.TYPE;  				t.text = ntype;  				t.pos = ts [ts.Count - 2].pos;  				t.line = ts [ts.Count - 2].line;  				ts.RemoveAt (ts.Count - 1);  				ts.RemoveAt (ts.Count - 1);  				ts.Add (t);  				continue;  			}  		}  		if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  			//模板函数调用'合并之  			string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  			t.type = TokenType.IDENTIFIER;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  			//Type.Type IDENTIFIER.Type 均不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  			//Type Type 不可能，为重名  			t.type = TokenType.IDENTIFIER;  			ts.Add (t);  			continue;  		}  		ts.Add (t);  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (n >= 0) {  	if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  		string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		if (types.Contains (ntype)) {  			//类中类，合并之  			t.type = TokenType.TYPE;  			t.text = ntype;  			t.pos = ts [ts.Count - 2].pos;  			t.line = ts [ts.Count - 2].line;  			ts.RemoveAt (ts.Count - 1);  			ts.RemoveAt (ts.Count - 1);  			ts.Add (t);  			continue;  		}  	}  	if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  		//模板函数调用'合并之  		string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  		t.type = TokenType.IDENTIFIER;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  		//Type.Type IDENTIFIER.Type 均不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	if (ts.Count >= 1 && t.type == TokenType.TYPE && ts [ts.Count - 1].type == TokenType.TYPE) {  		//Type Type 不可能，为重名  		t.type = TokenType.IDENTIFIER;  		ts.Add (t);  		continue;  	}  	ts.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  	string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	if (types.Contains (ntype)) {  		//类中类，合并之  		t.type = TokenType.TYPE;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  	string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	if (types.Contains (ntype)) {  		//类中类，合并之  		t.type = TokenType.TYPE;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  	string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	if (types.Contains (ntype)) {  		//类中类，合并之  		t.type = TokenType.TYPE;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  	string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	if (types.Contains (ntype)) {  		//类中类，合并之  		t.type = TokenType.TYPE;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.IDENTIFIER && ts [ts.Count - 1].text == "." && ts [ts.Count - 2].type == TokenType.TYPE) {  	string ntype = ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	if (types.Contains (ntype)) {  		//类中类，合并之  		t.type = TokenType.TYPE;  		t.text = ntype;  		t.pos = ts [ts.Count - 2].pos;  		t.line = ts [ts.Count - 2].line;  		ts.RemoveAt (ts.Count - 1);  		ts.RemoveAt (ts.Count - 1);  		ts.Add (t);  		continue;  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (types.Contains (ntype)) {  	//类中类，合并之  	t.type = TokenType.TYPE;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (types.Contains (ntype)) {  	//类中类，合并之  	t.type = TokenType.TYPE;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: t.pos = ts [ts.Count - 2].pos;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: t.line = ts [ts.Count - 2].line;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 3 && t.type == TokenType.PUNCTUATION && t.text == ">" && ts [ts.Count - 1].type == TokenType.TYPE && ts [ts.Count - 2].type == TokenType.PUNCTUATION && ts [ts.Count - 2].text == "<" && ts [ts.Count - 3].type == TokenType.IDENTIFIER) {  	//模板函数调用'合并之  	string ntype = ts [ts.Count - 3].text + ts [ts.Count - 2].text + ts [ts.Count - 1].text + t.text;  	t.type = TokenType.IDENTIFIER;  	t.text = ntype;  	t.pos = ts [ts.Count - 2].pos;  	t.line = ts [ts.Count - 2].line;  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.RemoveAt (ts.Count - 1);  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: t.pos = ts [ts.Count - 2].pos;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: t.line = ts [ts.Count - 2].line;  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  	//Type.Type IDENTIFIER.Type 均不可能，为重名  	t.type = TokenType.IDENTIFIER;  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  	//Type.Type IDENTIFIER.Type 均不可能，为重名  	t.type = TokenType.IDENTIFIER;  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,Parse,The following statement contains a magic number: if (ts.Count >= 2 && t.type == TokenType.TYPE && ts [ts.Count - 1].text == "." && (ts [ts.Count - 2].type == TokenType.TYPE || ts [ts.Count - 2].type == TokenType.IDENTIFIER)) {  	//Type.Type IDENTIFIER.Type 均不可能，为重名  	t.type = TokenType.IDENTIFIER;  	ts.Add (t);  	continue;  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,SaveTokenList,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (linecount)' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,SaveTokenList,The following statement contains a magic number: foreach (UInt16 lstarttoken in lines) {  	byte[] nbs = BitConverter.GetBytes (lstarttoken);  	stream.Write (nbs' 0' 2);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,SaveTokenList,The following statement contains a magic number: stream.Write (nbs' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bs' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bs' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: for (int i = 0; i < lenstr; i++) {  	stream.Read (bs' 0' 2);  	UInt16 slen = BitConverter.ToUInt16 (bs' 0);  	stream.Read (bs' 0' slen);  	strstore.Add (System.Text.Encoding.UTF8.GetString (bs' 0' slen));  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bs' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	Token t = new Token ();  	stream.Read (bs' 0' 4);  	UInt32 type = BitConverter.ToUInt32 (bs' 0);  	t.type = (TokenType)(type % 0x0100);  	t.text = strstore [(int)(type / 0x100)];  	tokens.Add (t);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bs' 0' 4);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: if (stream.Position < stream.Length) {  	UInt16 linecount = 0;  	byte[] bufu = new byte[2];  	stream.Read (bufu' 0' 2);  	linecount = BitConverter.ToUInt16 (bufu' 0);  	UInt16[] linetoken = new UInt16[linecount];  	for (int i = 0; i < linecount; i++) {  		stream.Read (bufu' 0' 2);  		linetoken [i] = BitConverter.ToUInt16 (bufu' 0);  	}  	//int token = 0;  	for (int i = 0; i < linecount; i++) {  		if ((i + 1) < linecount && linetoken [i + 1] == linetoken [i])  			continue;  		if ((i + 1) < linecount) {  			for (int j = linetoken [i]; j < linetoken [i + 1]; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		} else {  			for (int j = linetoken [i]; j < tokens.Count; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		}  		//token = linetoken[i];  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: if (stream.Position < stream.Length) {  	UInt16 linecount = 0;  	byte[] bufu = new byte[2];  	stream.Read (bufu' 0' 2);  	linecount = BitConverter.ToUInt16 (bufu' 0);  	UInt16[] linetoken = new UInt16[linecount];  	for (int i = 0; i < linecount; i++) {  		stream.Read (bufu' 0' 2);  		linetoken [i] = BitConverter.ToUInt16 (bufu' 0);  	}  	//int token = 0;  	for (int i = 0; i < linecount; i++) {  		if ((i + 1) < linecount && linetoken [i + 1] == linetoken [i])  			continue;  		if ((i + 1) < linecount) {  			for (int j = linetoken [i]; j < linetoken [i + 1]; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		} else {  			for (int j = linetoken [i]; j < tokens.Count; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		}  		//token = linetoken[i];  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: if (stream.Position < stream.Length) {  	UInt16 linecount = 0;  	byte[] bufu = new byte[2];  	stream.Read (bufu' 0' 2);  	linecount = BitConverter.ToUInt16 (bufu' 0);  	UInt16[] linetoken = new UInt16[linecount];  	for (int i = 0; i < linecount; i++) {  		stream.Read (bufu' 0' 2);  		linetoken [i] = BitConverter.ToUInt16 (bufu' 0);  	}  	//int token = 0;  	for (int i = 0; i < linecount; i++) {  		if ((i + 1) < linecount && linetoken [i + 1] == linetoken [i])  			continue;  		if ((i + 1) < linecount) {  			for (int j = linetoken [i]; j < linetoken [i + 1]; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		} else {  			for (int j = linetoken [i]; j < tokens.Count; j++) {  				var t = tokens [j];  				t.line = i + 1;  				tokens [j] = t;  			}  		}  		//token = linetoken[i];  	}  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bufu' 0' 2);  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: for (int i = 0; i < linecount; i++) {  	stream.Read (bufu' 0' 2);  	linetoken [i] = BitConverter.ToUInt16 (bufu' 0);  }  
Magic Number,CSLE,CLS_TokenParser,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Token\CLS_Token.cs,ReadTokenList,The following statement contains a magic number: stream.Read (bufu' 0' 2);  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (useDebug) {  	if (this.CallType != null && this.CallType.tokenlist != null) {  		tokenlist = this.CallType.tokenlist;  	}  	foreach (var subc in this.stackContent) {  		svalues += subc.DumpStack (tokenlist);  	}  	svalues += "DumpStack:" + this.CallName + "\n";  	foreach (var s in stackExpr) {  		if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  		} else {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  			if (s.tokenEnd - s.tokenBegin >= 20) {  				for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  					svalues += tokenlist [i].text + " ";  				}  				svalues += "...";  				for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			} else {  				for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			}  			svalues += "\n";  		}  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (useDebug) {  	if (this.CallType != null && this.CallType.tokenlist != null) {  		tokenlist = this.CallType.tokenlist;  	}  	foreach (var subc in this.stackContent) {  		svalues += subc.DumpStack (tokenlist);  	}  	svalues += "DumpStack:" + this.CallName + "\n";  	foreach (var s in stackExpr) {  		if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  		} else {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  			if (s.tokenEnd - s.tokenBegin >= 20) {  				for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  					svalues += tokenlist [i].text + " ";  				}  				svalues += "...";  				for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			} else {  				for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			}  			svalues += "\n";  		}  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (useDebug) {  	if (this.CallType != null && this.CallType.tokenlist != null) {  		tokenlist = this.CallType.tokenlist;  	}  	foreach (var subc in this.stackContent) {  		svalues += subc.DumpStack (tokenlist);  	}  	svalues += "DumpStack:" + this.CallName + "\n";  	foreach (var s in stackExpr) {  		if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  		} else {  			svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  			if (s.tokenEnd - s.tokenBegin >= 20) {  				for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  					svalues += tokenlist [i].text + " ";  				}  				svalues += "...";  				for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			} else {  				for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  					svalues += tokenlist [i].text + " ";  				}  			}  			svalues += "\n";  		}  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: foreach (var s in stackExpr) {  	if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  	} else {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  		if (s.tokenEnd - s.tokenBegin >= 20) {  			for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  				svalues += tokenlist [i].text + " ";  			}  			svalues += "...";  			for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		} else {  			for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		}  		svalues += "\n";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: foreach (var s in stackExpr) {  	if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  	} else {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  		if (s.tokenEnd - s.tokenBegin >= 20) {  			for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  				svalues += tokenlist [i].text + " ";  			}  			svalues += "...";  			for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		} else {  			for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		}  		svalues += "\n";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: foreach (var s in stackExpr) {  	if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  	} else {  		svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  		if (s.tokenEnd - s.tokenBegin >= 20) {  			for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  				svalues += tokenlist [i].text + " ";  			}  			svalues += "...";  			for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		} else {  			for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  				svalues += tokenlist [i].text + " ";  			}  		}  		svalues += "\n";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  } else {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  	if (s.tokenEnd - s.tokenBegin >= 20) {  		for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  			svalues += tokenlist [i].text + " ";  		}  		svalues += "...";  		for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	} else {  		for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	}  	svalues += "\n";  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  } else {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  	if (s.tokenEnd - s.tokenBegin >= 20) {  		for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  			svalues += tokenlist [i].text + " ";  		}  		svalues += "...";  		for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	} else {  		for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	}  	svalues += "\n";  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if ((s.tokenBegin == 0 && s.tokenEnd == 0) || tokenlist == null) {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")\n";  } else {  	svalues += "<C#LE>:line(" + s.lineBegin + "-" + s.lineEnd + ")";  	if (s.tokenEnd - s.tokenBegin >= 20) {  		for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  			svalues += tokenlist [i].text + " ";  		}  		svalues += "...";  		for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	} else {  		for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  			svalues += tokenlist [i].text + " ";  		}  	}  	svalues += "\n";  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (s.tokenEnd - s.tokenBegin >= 20) {  	for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  		svalues += tokenlist [i].text + " ";  	}  	svalues += "...";  	for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  } else {  	for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (s.tokenEnd - s.tokenBegin >= 20) {  	for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  		svalues += tokenlist [i].text + " ";  	}  	svalues += "...";  	for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  } else {  	for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: if (s.tokenEnd - s.tokenBegin >= 20) {  	for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  		svalues += tokenlist [i].text + " ";  	}  	svalues += "...";  	for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  } else {  	for (int i = s.tokenBegin; i <= s.tokenEnd; i++) {  		svalues += tokenlist [i].text + " ";  	}  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: for (int i = s.tokenBegin; i < s.tokenBegin + 8; i++) {  	svalues += tokenlist [i].text + " ";  }  
Magic Number,CSLE,CLS_Content,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\_Interface\CLS_Content.cs,DumpStack,The following statement contains a magic number: for (int i = s.tokenEnd - 7; i <= s.tokenEnd; i++) {  	svalues += tokenlist [i].text + " ";  }  
Missing Default,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetExpressionOp,The following switch statement is missing a default case: switch (tokens [i].text) {  case "<":  	max = 6;  	break;  case ">":  	max = 6;  	break;  case "<=":  	max = 6;  	break;  case ">=":  	max = 6;  	break;  case "&&":  	max = 5;  	break;  case "||":  	max = 5;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 3;  	break;  case "/":  	max = 3;  	break;  case "+":  	max = 2;  	break;  case "-":  	max = 2;  	break;  }  
Missing Default,CSLE,CLS_Expression_Compiler,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\Compitler\CLS_Compiler.cs,GetLowestMathOp,The following switch statement is missing a default case: switch (tokens [i].text) {  case "?":  	max = -1;  	break;  case ":":  	max = 0;  	break;  case "<":  	max = 5;  	break;  case ">":  	max = 5;  	break;  case "<=":  	max = 5;  	break;  case ">=":  	max = 5;  	break;  case "&&":  	max = 3;  	break;  case "||":  	max = 3;  	break;  case "==":  	max = 4;  	break;  case "!=":  	max = 4;  	break;  case "*":  	max = 7;  	break;  case "/":  	max = 7;  	break;  case "%":  	max = 7;  	break;  case "+":  	max = 6;  	break;  case "-":  	max = 6;  	break;  case ".":  	max = 10;  	break;  case "=>":  	max = 8;  	break;  case "[":  	max = 10;  	break;  case "(":  	max = 9;  	//提高括弧的处理顺序到11，已回滚此修改  	//表达式识别存在缺陷，并非单纯的改动可以解决，可能造成其他的不明显bug  	break;  case "as":  	max = 9;  	break;  case "is":  	max = 9;  	break;  }  
Missing Default,CSLE,RegHelper_TypeFunction,F:\newReposMay17\lightszero_cslightcore\core\CSLightEvil\C#LE\RegHelper\RegHelper_Type.cs,MemberValueGet,The following switch statement is missing a default case: switch (c.type) {  case 1:  	v.value = c.finfo.GetValue (object_this);  	v.type = c.finfo.FieldType;  	break;  case 2:  	v.value = c.minfo.Invoke (object_this' null);  	v.type = c.minfo.ReturnType;  	break;  case 3:  	v.value = new DeleEvent (object_this' c.einfo);  	v.type = c.einfo.EventHandlerType;  	break;  }  
