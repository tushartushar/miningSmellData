Implementation smell,Namespace,Class,File,Method,Description
Long Method,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,Main,The method has 103 lines of code.
Long Method,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The method has 119 lines of code.
Complex Method,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,Cyclomatic complexity of the method is 17
Long Statement,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,Main,The length of the statement  "                Console.WriteLine("Invalid: map directory cannot be processed into single output map. Specify destination output directory."); " is 126.
Long Statement,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The length of the statement  "                        Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID); " is 131.
Long Statement,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The length of the statement  "                        Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name); " is 131.
Long Statement,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The length of the statement  "                        Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID); " is 144.
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,Main,The following statement contains a magic number: if (args.Length != 3)              {                  Console.WriteLine("Usage: BatchMap.exe <srcmap|srcdir> <dstmap|dstdir> <pubdir>");                  return;              }
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,Main,The following statement contains a magic number: var pubFilePath = args[2];
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The following statement contains a magic number: for (int mapIndex = 0; mapIndex < inFiles.Length; ++mapIndex)              {                  var mapID = new MapPathToIDConverter().ConvertFromPathToID(inFiles[mapIndex]);                    mapFileLoadActions.LoadMapFileByName(inFiles[mapIndex]);                  var mapFile = _mapFileProvider.MapFiles[mapID];                                    var changesMade = false;                    //todo: find way to store actual input data' since invalid tiles/warps will be auto-removed                  //for (int i = mapFile.TileRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.TileRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Tile {1}x{2} ({3}) is out of map bounds. Removing."'                  //                              mapID' tt.X' tr.Y' Enum.GetName(typeof(TileSpec)' tt.Value));                  //            mapFile.RemoveTileAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    //for (int i = mapFile.WarpRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.WarpRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Warp {1}x{2} is out of map bounds. Removing."' mapID' tt.X' tr.Y);                  //            mapFile.RemoveWarpAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    for(int ndx = mapFile.NPCSpawns.Count - 1; ndx >= 0; --ndx)                  {                      var npcSpawn = mapFile.NPCSpawns[ndx];                      var npcRec = _pubProvider.ENFFile[npcSpawn.ID];                      if (npcSpawn.ID > _pubProvider.ENFFile.Data.Count || npcRec == null)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (npcSpawn.X > mapFile.Properties.Width || npcSpawn.Y > mapFile.Properties.Height)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (!TileIsValidNPCSpawnPoint(mapFile' npcSpawn.X' npcSpawn.Y))                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is invalid..."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          var found = false;                          for (int row = npcSpawn.Y - 2; row < npcSpawn.Y + 2; ++row)                          {                              if (found) break;                              for (int col = npcSpawn.X - 2; col < npcSpawn.X + 2; ++col)                              {                                  if (found) break;                                  if (TileIsValidNPCSpawnPoint(mapFile' col' row))                                  {                                      Console.WriteLine("[MAP {0}] Found valid spawn point. Continuing."' mapID);                                      found = true;                                  }                              }                          }                            if (!found)                          {                              Console.WriteLine("[MAP {0}] NPC couldn't spawn anywhere valid! Removing."' mapID);                              mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                              changesMade = true;                          }                      }                  }                    for(int ndx = mapFile.Chests.Count - 1; ndx >= 0; --ndx)                  {                      var chestSpawn = mapFile.Chests[ndx];                      var rec = _pubProvider.EIFFile[chestSpawn.ItemID];                      if (chestSpawn.ItemID > _pubProvider.EIFFile.Data.Count || rec == null)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                          continue;                      }                        if (chestSpawn.X > mapFile.Properties.Width ||                          chestSpawn.Y > mapFile.Properties.Height ||                          mapFile.Tiles[chestSpawn.Y' chestSpawn.X] != TileSpec.Chest)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} points to a non-chest. Removing."' mapID' chestSpawn.X' chestSpawn.Y);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                      }                  }                    if (!changesMade)                  {                      Console.WriteLine("Map {0} processed without any errors. No changes made."' mapID);                      continue;                  }                    if (mapIndex == 0 && singleFile && inFiles.Length == 1)                  {                      mapFileSaveService.SaveFile(dst' mapFile);                      break;                  }                    mapFileSaveService.SaveFile(                      Path.Combine(dst' $"{mapID'5:D5}.emf")'                      mapFile);              }
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The following statement contains a magic number: for (int mapIndex = 0; mapIndex < inFiles.Length; ++mapIndex)              {                  var mapID = new MapPathToIDConverter().ConvertFromPathToID(inFiles[mapIndex]);                    mapFileLoadActions.LoadMapFileByName(inFiles[mapIndex]);                  var mapFile = _mapFileProvider.MapFiles[mapID];                                    var changesMade = false;                    //todo: find way to store actual input data' since invalid tiles/warps will be auto-removed                  //for (int i = mapFile.TileRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.TileRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Tile {1}x{2} ({3}) is out of map bounds. Removing."'                  //                              mapID' tt.X' tr.Y' Enum.GetName(typeof(TileSpec)' tt.Value));                  //            mapFile.RemoveTileAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    //for (int i = mapFile.WarpRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.WarpRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Warp {1}x{2} is out of map bounds. Removing."' mapID' tt.X' tr.Y);                  //            mapFile.RemoveWarpAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    for(int ndx = mapFile.NPCSpawns.Count - 1; ndx >= 0; --ndx)                  {                      var npcSpawn = mapFile.NPCSpawns[ndx];                      var npcRec = _pubProvider.ENFFile[npcSpawn.ID];                      if (npcSpawn.ID > _pubProvider.ENFFile.Data.Count || npcRec == null)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (npcSpawn.X > mapFile.Properties.Width || npcSpawn.Y > mapFile.Properties.Height)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (!TileIsValidNPCSpawnPoint(mapFile' npcSpawn.X' npcSpawn.Y))                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is invalid..."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          var found = false;                          for (int row = npcSpawn.Y - 2; row < npcSpawn.Y + 2; ++row)                          {                              if (found) break;                              for (int col = npcSpawn.X - 2; col < npcSpawn.X + 2; ++col)                              {                                  if (found) break;                                  if (TileIsValidNPCSpawnPoint(mapFile' col' row))                                  {                                      Console.WriteLine("[MAP {0}] Found valid spawn point. Continuing."' mapID);                                      found = true;                                  }                              }                          }                            if (!found)                          {                              Console.WriteLine("[MAP {0}] NPC couldn't spawn anywhere valid! Removing."' mapID);                              mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                              changesMade = true;                          }                      }                  }                    for(int ndx = mapFile.Chests.Count - 1; ndx >= 0; --ndx)                  {                      var chestSpawn = mapFile.Chests[ndx];                      var rec = _pubProvider.EIFFile[chestSpawn.ItemID];                      if (chestSpawn.ItemID > _pubProvider.EIFFile.Data.Count || rec == null)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                          continue;                      }                        if (chestSpawn.X > mapFile.Properties.Width ||                          chestSpawn.Y > mapFile.Properties.Height ||                          mapFile.Tiles[chestSpawn.Y' chestSpawn.X] != TileSpec.Chest)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} points to a non-chest. Removing."' mapID' chestSpawn.X' chestSpawn.Y);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                      }                  }                    if (!changesMade)                  {                      Console.WriteLine("Map {0} processed without any errors. No changes made."' mapID);                      continue;                  }                    if (mapIndex == 0 && singleFile && inFiles.Length == 1)                  {                      mapFileSaveService.SaveFile(dst' mapFile);                      break;                  }                    mapFileSaveService.SaveFile(                      Path.Combine(dst' $"{mapID'5:D5}.emf")'                      mapFile);              }
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The following statement contains a magic number: for (int mapIndex = 0; mapIndex < inFiles.Length; ++mapIndex)              {                  var mapID = new MapPathToIDConverter().ConvertFromPathToID(inFiles[mapIndex]);                    mapFileLoadActions.LoadMapFileByName(inFiles[mapIndex]);                  var mapFile = _mapFileProvider.MapFiles[mapID];                                    var changesMade = false;                    //todo: find way to store actual input data' since invalid tiles/warps will be auto-removed                  //for (int i = mapFile.TileRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.TileRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Tile {1}x{2} ({3}) is out of map bounds. Removing."'                  //                              mapID' tt.X' tr.Y' Enum.GetName(typeof(TileSpec)' tt.Value));                  //            mapFile.RemoveTileAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    //for (int i = mapFile.WarpRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.WarpRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Warp {1}x{2} is out of map bounds. Removing."' mapID' tt.X' tr.Y);                  //            mapFile.RemoveWarpAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    for(int ndx = mapFile.NPCSpawns.Count - 1; ndx >= 0; --ndx)                  {                      var npcSpawn = mapFile.NPCSpawns[ndx];                      var npcRec = _pubProvider.ENFFile[npcSpawn.ID];                      if (npcSpawn.ID > _pubProvider.ENFFile.Data.Count || npcRec == null)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (npcSpawn.X > mapFile.Properties.Width || npcSpawn.Y > mapFile.Properties.Height)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (!TileIsValidNPCSpawnPoint(mapFile' npcSpawn.X' npcSpawn.Y))                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is invalid..."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          var found = false;                          for (int row = npcSpawn.Y - 2; row < npcSpawn.Y + 2; ++row)                          {                              if (found) break;                              for (int col = npcSpawn.X - 2; col < npcSpawn.X + 2; ++col)                              {                                  if (found) break;                                  if (TileIsValidNPCSpawnPoint(mapFile' col' row))                                  {                                      Console.WriteLine("[MAP {0}] Found valid spawn point. Continuing."' mapID);                                      found = true;                                  }                              }                          }                            if (!found)                          {                              Console.WriteLine("[MAP {0}] NPC couldn't spawn anywhere valid! Removing."' mapID);                              mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                              changesMade = true;                          }                      }                  }                    for(int ndx = mapFile.Chests.Count - 1; ndx >= 0; --ndx)                  {                      var chestSpawn = mapFile.Chests[ndx];                      var rec = _pubProvider.EIFFile[chestSpawn.ItemID];                      if (chestSpawn.ItemID > _pubProvider.EIFFile.Data.Count || rec == null)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                          continue;                      }                        if (chestSpawn.X > mapFile.Properties.Width ||                          chestSpawn.Y > mapFile.Properties.Height ||                          mapFile.Tiles[chestSpawn.Y' chestSpawn.X] != TileSpec.Chest)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} points to a non-chest. Removing."' mapID' chestSpawn.X' chestSpawn.Y);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                      }                  }                    if (!changesMade)                  {                      Console.WriteLine("Map {0} processed without any errors. No changes made."' mapID);                      continue;                  }                    if (mapIndex == 0 && singleFile && inFiles.Length == 1)                  {                      mapFileSaveService.SaveFile(dst' mapFile);                      break;                  }                    mapFileSaveService.SaveFile(                      Path.Combine(dst' $"{mapID'5:D5}.emf")'                      mapFile);              }
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The following statement contains a magic number: for (int mapIndex = 0; mapIndex < inFiles.Length; ++mapIndex)              {                  var mapID = new MapPathToIDConverter().ConvertFromPathToID(inFiles[mapIndex]);                    mapFileLoadActions.LoadMapFileByName(inFiles[mapIndex]);                  var mapFile = _mapFileProvider.MapFiles[mapID];                                    var changesMade = false;                    //todo: find way to store actual input data' since invalid tiles/warps will be auto-removed                  //for (int i = mapFile.TileRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.TileRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Tile {1}x{2} ({3}) is out of map bounds. Removing."'                  //                              mapID' tt.X' tr.Y' Enum.GetName(typeof(TileSpec)' tt.Value));                  //            mapFile.RemoveTileAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    //for (int i = mapFile.WarpRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.WarpRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Warp {1}x{2} is out of map bounds. Removing."' mapID' tt.X' tr.Y);                  //            mapFile.RemoveWarpAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    for(int ndx = mapFile.NPCSpawns.Count - 1; ndx >= 0; --ndx)                  {                      var npcSpawn = mapFile.NPCSpawns[ndx];                      var npcRec = _pubProvider.ENFFile[npcSpawn.ID];                      if (npcSpawn.ID > _pubProvider.ENFFile.Data.Count || npcRec == null)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (npcSpawn.X > mapFile.Properties.Width || npcSpawn.Y > mapFile.Properties.Height)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (!TileIsValidNPCSpawnPoint(mapFile' npcSpawn.X' npcSpawn.Y))                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is invalid..."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          var found = false;                          for (int row = npcSpawn.Y - 2; row < npcSpawn.Y + 2; ++row)                          {                              if (found) break;                              for (int col = npcSpawn.X - 2; col < npcSpawn.X + 2; ++col)                              {                                  if (found) break;                                  if (TileIsValidNPCSpawnPoint(mapFile' col' row))                                  {                                      Console.WriteLine("[MAP {0}] Found valid spawn point. Continuing."' mapID);                                      found = true;                                  }                              }                          }                            if (!found)                          {                              Console.WriteLine("[MAP {0}] NPC couldn't spawn anywhere valid! Removing."' mapID);                              mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                              changesMade = true;                          }                      }                  }                    for(int ndx = mapFile.Chests.Count - 1; ndx >= 0; --ndx)                  {                      var chestSpawn = mapFile.Chests[ndx];                      var rec = _pubProvider.EIFFile[chestSpawn.ItemID];                      if (chestSpawn.ItemID > _pubProvider.EIFFile.Data.Count || rec == null)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                          continue;                      }                        if (chestSpawn.X > mapFile.Properties.Width ||                          chestSpawn.Y > mapFile.Properties.Height ||                          mapFile.Tiles[chestSpawn.Y' chestSpawn.X] != TileSpec.Chest)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} points to a non-chest. Removing."' mapID' chestSpawn.X' chestSpawn.Y);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                      }                  }                    if (!changesMade)                  {                      Console.WriteLine("Map {0} processed without any errors. No changes made."' mapID);                      continue;                  }                    if (mapIndex == 0 && singleFile && inFiles.Length == 1)                  {                      mapFileSaveService.SaveFile(dst' mapFile);                      break;                  }                    mapFileSaveService.SaveFile(                      Path.Combine(dst' $"{mapID'5:D5}.emf")'                      mapFile);              }
Magic Number,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,ProcessFiles,The following statement contains a magic number: for (int mapIndex = 0; mapIndex < inFiles.Length; ++mapIndex)              {                  var mapID = new MapPathToIDConverter().ConvertFromPathToID(inFiles[mapIndex]);                    mapFileLoadActions.LoadMapFileByName(inFiles[mapIndex]);                  var mapFile = _mapFileProvider.MapFiles[mapID];                                    var changesMade = false;                    //todo: find way to store actual input data' since invalid tiles/warps will be auto-removed                  //for (int i = mapFile.TileRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.TileRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Tile {1}x{2} ({3}) is out of map bounds. Removing."'                  //                              mapID' tt.X' tr.Y' Enum.GetName(typeof(TileSpec)' tt.Value));                  //            mapFile.RemoveTileAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    //for (int i = mapFile.WarpRows.Count - 1; i >= 0; --i)                  //{                  //    var tr = mapFile.WarpRows[i];                  //    for (int j = tr.EntityItems.Count - 1; j >= 0; --j)                  //    {                  //        var tt = tr.EntityItems[j];                  //        if (tt.X > mapFile.Properties.Width || tr.Y > mapFile.Properties.Height)                  //        {                  //            Console.WriteLine("[MAP {0}] Warp {1}x{2} is out of map bounds. Removing."' mapID' tt.X' tr.Y);                  //            mapFile.RemoveWarpAt(tr.Y' tt.X);                  //            changesMade = true;                  //        }                  //    }                  //}                    for(int ndx = mapFile.NPCSpawns.Count - 1; ndx >= 0; --ndx)                  {                      var npcSpawn = mapFile.NPCSpawns[ndx];                      var npcRec = _pubProvider.ENFFile[npcSpawn.ID];                      if (npcSpawn.ID > _pubProvider.ENFFile.Data.Count || npcRec == null)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} uses non-existent NPC #{3}. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcSpawn.ID);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (npcSpawn.X > mapFile.Properties.Width || npcSpawn.Y > mapFile.Properties.Height)                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is out of map bounds. Removing."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                          changesMade = true;                          continue;                      }                        if (!TileIsValidNPCSpawnPoint(mapFile' npcSpawn.X' npcSpawn.Y))                      {                          Console.WriteLine("[MAP {0}] NPC Spawn {1}x{2} ({3}) is invalid..."' mapID' npcSpawn.X' npcSpawn.Y' npcRec.Name);                          var found = false;                          for (int row = npcSpawn.Y - 2; row < npcSpawn.Y + 2; ++row)                          {                              if (found) break;                              for (int col = npcSpawn.X - 2; col < npcSpawn.X + 2; ++col)                              {                                  if (found) break;                                  if (TileIsValidNPCSpawnPoint(mapFile' col' row))                                  {                                      Console.WriteLine("[MAP {0}] Found valid spawn point. Continuing."' mapID);                                      found = true;                                  }                              }                          }                            if (!found)                          {                              Console.WriteLine("[MAP {0}] NPC couldn't spawn anywhere valid! Removing."' mapID);                              mapFile = mapFile.RemoveNPCSpawn(npcSpawn);                              changesMade = true;                          }                      }                  }                    for(int ndx = mapFile.Chests.Count - 1; ndx >= 0; --ndx)                  {                      var chestSpawn = mapFile.Chests[ndx];                      var rec = _pubProvider.EIFFile[chestSpawn.ItemID];                      if (chestSpawn.ItemID > _pubProvider.EIFFile.Data.Count || rec == null)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} uses non-existent Item #{3}. Removing."' mapID' chestSpawn.X' chestSpawn.Y' chestSpawn.ItemID);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                          continue;                      }                        if (chestSpawn.X > mapFile.Properties.Width ||                          chestSpawn.Y > mapFile.Properties.Height ||                          mapFile.Tiles[chestSpawn.Y' chestSpawn.X] != TileSpec.Chest)                      {                          Console.WriteLine("[MAP {0}] Chest Spawn {1}x{2} points to a non-chest. Removing."' mapID' chestSpawn.X' chestSpawn.Y);                          mapFile = mapFile.RemoveChestSpawn(chestSpawn);                          changesMade = true;                      }                  }                    if (!changesMade)                  {                      Console.WriteLine("Map {0} processed without any errors. No changes made."' mapID);                      continue;                  }                    if (mapIndex == 0 && singleFile && inFiles.Length == 1)                  {                      mapFileSaveService.SaveFile(dst' mapFile);                      break;                  }                    mapFileSaveService.SaveFile(                      Path.Combine(dst' $"{mapID'5:D5}.emf")'                      mapFile);              }
Missing Default,BatchMap,Program,C:\repos\ethanmoffat_EndlessClient\BatchMap\Program.cs,TileIsValidNPCSpawnPoint,The following switch statement is missing a default case: switch (EMF.Tiles[y' x])              {                  case TileSpec.Wall:                  case TileSpec.ChairDown:                  case TileSpec.ChairLeft:                  case TileSpec.ChairRight:                  case TileSpec.ChairUp:                  case TileSpec.ChairDownRight:                  case TileSpec.ChairUpLeft:                  case TileSpec.ChairAll:                  case TileSpec.Chest:                  case TileSpec.BankVault:                  case TileSpec.NPCBoundary:                  case TileSpec.MapEdge:                  case TileSpec.Board1:                  case TileSpec.Board2:                  case TileSpec.Board3:                  case TileSpec.Board4:                  case TileSpec.Board5:                  case TileSpec.Board6:                  case TileSpec.Board7:                  case TileSpec.Board8:                  case TileSpec.Jukebox:                      return false;              }
