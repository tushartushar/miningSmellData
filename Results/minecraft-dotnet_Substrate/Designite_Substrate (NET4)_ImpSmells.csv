Implementation smell,Namespace,Class,File,Method,Description
Long Method,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The method has 173 lines of code.
Long Method,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The method has 283 lines of code.
Long Method,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The method has 107 lines of code.
Long Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateFast,The method has 101 lines of code.
Long Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The method has 127 lines of code.
Long Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The method has 155 lines of code.
Long Method,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method has 448 lines of code.
Long Method,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method has 307 lines of code.
Long Method,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,Ionic.Zlib,ParallelDeflateOutputStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The method has 140 lines of code.
Complex Method,Substrate,AlphaChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,SetLocation,Cyclomatic complexity of the method is 11
Complex Method,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,SetLocation,Cyclomatic complexity of the method is 11
Complex Method,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,LoadTree,Cyclomatic complexity of the method is 11
Complex Method,Substrate,AlphaBlockCollection,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,SetID,Cyclomatic complexity of the method is 14
Complex Method,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,LoadTree,Cyclomatic complexity of the method is 19
Complex Method,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,BuildTree,Cyclomatic complexity of the method is 18
Complex Method,Substrate,Player,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,LoadTree,Cyclomatic complexity of the method is 21
Complex Method,Substrate,Player,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,BuildTree,Cyclomatic complexity of the method is 13
Complex Method,Substrate,RegionChunkManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\RegionChunkManager.cs,RelightDirtyChunks,Cyclomatic complexity of the method is 9
Complex Method,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,Cyclomatic complexity of the method is 20
Complex Method,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,Cyclomatic complexity of the method is 10
Complex Method,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,Cyclomatic complexity of the method is 12
Complex Method,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,Cyclomatic complexity of the method is 11
Complex Method,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,UpdateBlockSkyLight,Cyclomatic complexity of the method is 8
Complex Method,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadBlockLight,Cyclomatic complexity of the method is 11
Complex Method,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadSkyLight,Cyclomatic complexity of the method is 23
Complex Method,Substrate.ImportExport,Schematic,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ImportExport\Schematic.cs,Import,Cyclomatic complexity of the method is 8
Complex Method,Substrate.Nbt,NbtVerifier,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,Verify,Cyclomatic complexity of the method is 10
Complex Method,Substrate.Nbt,NbtVerifier,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,VerifyList,Cyclomatic complexity of the method is 9
Complex Method,Substrate.TileEntities,TileEntityMobSpawner,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\TileEntities\TileEntityMobSpawner.cs,LoadTree,Cyclomatic complexity of the method is 14
Complex Method,Substrate.TileEntities,TileEntityMobSpawner,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\TileEntities\TileEntityMobSpawner.cs,BuildTree,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 14
Complex Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,Cyclomatic complexity of the method is 19
Complex Method,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 18
Long Parameter List,Substrate,AlphaBlockCollection,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,AlphaBlockCollection,The method has 6 parameters. Parameters: blocks' data' blockLight' skyLight' heightMap' tileEntities
Long Parameter List,Substrate,AlphaBlockCollection,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,AlphaBlockCollection,The method has 7 parameters. Parameters: blocks' data' blockLight' skyLight' heightMap' tileEntities' tileTicks
Long Parameter List,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,SpreadSkyLight,The method has 5 parameters. Parameters: chunkMap' heightMap' lx' ly' lz
Long Parameter List,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,TestBlockLight,The method has 7 parameters. Parameters: chunk' x1' y1' z1' x2' y2' z2
Long Parameter List,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,TestSkyLight,The method has 7 parameters. Parameters: chunk' x1' y1' z1' x2' y2' z2
Long Parameter List,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Debug,The method has 5 parameters. Parameters: mode' x' z' count' str
Long Parameter List,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The method has 5 parameters. Parameters: x' z' data' length' timestamp
Long Parameter List,Substrate.Nbt,SchemaNodeList,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\SchemaNodeList.cs,SchemaNodeList,The method has 5 parameters. Parameters: name' type' length' subschema' options
Long Parameter List,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The method has 5 parameters. Parameters: codec' level' windowBits' memLevel' strategy
Long Parameter List,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: goodLength' maxLazy' niceLength' maxChainLength' flavor
Long Parameter List,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,Ionic.Zlib,StaticTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: treeCodes' extraBits' extraBase' elems' maxLength
Long Parameter List,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' flavor' leaveOpen
Long Statement,Substrate,AlphaChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,LoadTree,The length of the statement  "            _blockManager = new AlphaBlockCollection(_blocks' _data' _blockLight' _skyLight' _heightMap' _tileEntities' _tileTicks); " is 120.
Long Statement,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,LoadTree,The length of the statement  "            _blockManager = new AlphaBlockCollection(_blocks' _data' _blockLight' _skyLight' _heightMap' _tileEntities' _tileTicks); " is 120.
Long Statement,Substrate,AlphaBlock,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlock.cs,CreateTileEntity,The length of the statement  "                throw new UnknownTileEntityException("The TileEntity type '" + info.TileEntityName + "' has not been registered with the TileEntityFactory."); " is 142.
Long Statement,Substrate,AlphaBlockCollection,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlockCollection.cs,SetID,The length of the statement  "                if (info1.Luminance != info2.Luminance || info1.Opacity != info2.Opacity || info1.TransmitsLight != info2.TransmitsLight) { " is 123.
Long Statement,Substrate.Core,BlockTileEntities,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockTileEntities.cs,CreateTileEntity,The length of the statement  "                throw new UnknownTileEntityException("The TileEntity type '" + info.TileEntityName + "' has not been registered with the TileEntityFactory."); " is 142.
Long Statement,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColorIndex,The length of the statement  "                throw new ArgumentOutOfRangeException("level"' level' "Argument 'level' must be in range [0' " + (_groupSize - 1) + "]"); " is 121.
Long Statement,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,GroupToColorIndex,The length of the statement  "                throw new ArgumentOutOfRangeException("level"' level' "Argument 'level' must be in range [0' " + (_groupSize - 1) + "]"); " is 121.
Long Statement,Substrate.Nbt,VerifierLogger,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\VerifierLogger.cs,InvalidTagTypeHandler,The length of the statement  "            Console.WriteLine("Invalid Tag Type Error: '{0}' has type '{1}'' expected '{2}'"' e.TagName' e.Tag.GetTagType()' e.Schema.ToString()); " is 134.
Long Statement,Substrate.Nbt,VerifierLogger,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\VerifierLogger.cs,InvalidTagValueHandler,The length of the statement  "            Console.WriteLine("Invalid Tag Value Error: '{0}' of type '{1}' is set to invalid value '{2}'"' e.TagName' e.Tag.GetTagType()' e.Tag.ToString()); " is 145.
Long Statement,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 133.
Long Statement,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 126.
Complex Conditional,Substrate.Core,CompositeDataArray3,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\CompositeDataArray.cs,CompositeDataArray3,The conditional expression  "sections[i].Length != sections[0].Length                      || sections[i].XDim != sections[0].XDim                      || sections[i].YDim != sections[0].YDim                      || sections[i].ZDim != sections[0].ZDim"  is complex.
Complex Conditional,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The conditional expression  "key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1]"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null ||                  (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) ||                  (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,Ionic.Zlib,ZlibCodec,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending ||                  OutputBuffer.Length <= NextOut ||                  dstate.pending.Length < (dstate.nextPending + len) ||                  OutputBuffer.Length < (NextOut + len)"  is complex.
Virtual Method Call from Constructor,Substrate,AlphaBlock,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaBlock.cs,AlphaBlock,The constructor "AlphaBlock" calls a virtual method "Copy".
Virtual Method Call from Constructor,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The constructor "Level" calls a virtual method "Copy".
Virtual Method Call from Constructor,Substrate.Core,Region,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,Region,The constructor "Region" calls a virtual method "GetFilePath".
Virtual Method Call from Constructor,Substrate.Core,Region,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,Region,The constructor "Region" calls a virtual method "ParseFileNameCore".
Virtual Method Call from Constructor,Substrate.Core,Enumerator,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionManager.cs,Enumerator,The constructor "Enumerator" calls a virtual method "GetRegion".
Magic Number,Substrate,AlphaChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunk.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,AnvilChunk,The following statement contains a magic number: _sections = new AnvilSection[16];
Magic Number,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,LoadTree,The following statement contains a magic number: if (level.ContainsKey("Biomes"))                  _biomes = new ZXByteArray(XDIM' ZDIM' level["Biomes"] as TagNodeByteArray);              else {                  level["Biomes"] = new TagNodeByteArray(new byte[256]);                  _biomes = new ZXByteArray(XDIM' ZDIM' level["Biomes"] as TagNodeByteArray);                  for (int x = 0; x < XDIM; x++)                      for (int z = 0; z < ZDIM; z++)                          _biomes[x' z] = BiomeType.Default;              }
Magic Number,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,BuildNBTTree,The following statement contains a magic number: _sections = new AnvilSection[16];
Magic Number,Substrate,AnvilChunk,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilChunk.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate,AnvilRegion,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilRegion.cs,ParseFileName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate,AnvilSection,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilSection.cs,LoadTree,The following statement contains a magic number: if (!ctree.ContainsKey("Add"))                  ctree["Add"] = new TagNodeByteArray(new byte[2048]);
Magic Number,Substrate,AnvilWorld,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AnvilWorld.cs,OnResolveOpen,The following statement contains a magic number: try {                  AnvilWorld world = new AnvilWorld().OpenWorld(e.Path);                  if (world == null) {                      return;                  }                    string regPath = IO.Path.Combine(e.Path' _REGION_DIR);                  if (!Directory.Exists(regPath)) {                      return;                  }                    if (world.Level.Version < 19133) {                      return;                  }                    e.AddHandler(Open);              }              catch (Exception) {                  return;              }
Magic Number,Substrate,BetaRegion,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaRegion.cs,ParseFileName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate,BetaWorld,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaWorld.cs,CreateWorld,The following statement contains a magic number: _level.Version = 19132;
Magic Number,Substrate,BetaWorld,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BetaWorld.cs,OnResolveOpen,The following statement contains a magic number: try {                  BetaWorld world = new BetaWorld().OpenWorld(e.Path);                  if (world == null) {                      return;                  }                    string regPath = IO.Path.Combine(e.Path' _REGION_DIR);                  if (!Directory.Exists(regPath)) {                      return;                  }                    if (world.Level.Version != 19132) {                      return;                  }                    e.AddHandler(Open);              }              catch (Exception) {                  return;              }
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Protection = new EnchantmentInfo(EnchantmentType.PROTECTION' "Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FireProtection = new EnchantmentInfo(EnchantmentType.FIRE_PROTECTION' "Fire Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FeatherFalling = new EnchantmentInfo(EnchantmentType.FEATHER_FALLING' "Feather Falling").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: BlastProtection = new EnchantmentInfo(EnchantmentType.BLAST_PROTECTION' "Blast Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: ProjectileProtection = new EnchantmentInfo(EnchantmentType.PROJECTILE_PROTECTION' "Projectile Protection").SetMaxLevel(4);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Respiration = new EnchantmentInfo(EnchantmentType.RESPIRATION' "Respiration").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Thorns = new EnchantmentInfo(EnchantmentType.THORNS' "Thorns").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Sharpness = new EnchantmentInfo(EnchantmentType.SHARPNESS' "Sharpness").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Smite = new EnchantmentInfo(EnchantmentType.SMITE' "Smite").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: BaneOfArthropods = new EnchantmentInfo(EnchantmentType.BANE_OF_ARTHROPODS' "Bane of Arthropods").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Knockback = new EnchantmentInfo(EnchantmentType.KNOCKBACK' "Knockback").SetMaxLevel(2);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: FireAspect = new EnchantmentInfo(EnchantmentType.FIRE_ASPECT' "Fire Aspect").SetMaxLevel(2);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Looting = new EnchantmentInfo(EnchantmentType.LOOTING' "Looting").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Efficiency = new EnchantmentInfo(EnchantmentType.EFFICIENCY' "Efficiency").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Unbreaking = new EnchantmentInfo(EnchantmentType.UNBREAKING' "Unbreaking").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Fortune = new EnchantmentInfo(EnchantmentType.FORTUNE' "Fortune").SetMaxLevel(3);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Power = new EnchantmentInfo(EnchantmentType.POWER' "Power").SetMaxLevel(5);
Magic Number,Substrate,EnchantmentInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EnchantmentInfo.cs,EnchantmentInfo,The following statement contains a magic number: Punch = new EnchantmentInfo(EnchantmentType.PUNCH' "Punch").SetMaxLevel(2);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronShovel = new ItemInfo(256' "Iron Shovel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronPickaxe = new ItemInfo(257' "Iron Pickaxe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronAxe = new ItemInfo(258' "Iron Axe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlintAndSteel = new ItemInfo(259' "Flint and Steel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Apple = new ItemInfo(260' "Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Apple = new ItemInfo(260' "Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bow = new ItemInfo(261' "Bow");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Arrow = new ItemInfo(262' "Arrow").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Arrow = new ItemInfo(262' "Arrow").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Coal = new ItemInfo(263' "Coal").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Coal = new ItemInfo(263' "Coal").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Diamond = new ItemInfo(264' "Diamond").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Diamond = new ItemInfo(264' "Diamond").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronIngot = new ItemInfo(265' "Iron Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronIngot = new ItemInfo(265' "Iron Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldIngot = new ItemInfo(266' "Gold Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldIngot = new ItemInfo(266' "Gold Ingot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronSword = new ItemInfo(267' "Iron Sword");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenSword = new ItemInfo(268' "Wooden Sword");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenShovel = new ItemInfo(269' "Wooden Shovel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenPickaxe = new ItemInfo(270' "Wooden Pickaxe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenAxe = new ItemInfo(271' "Wooden Axe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneSword = new ItemInfo(272' "Stone Sword");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneShovel = new ItemInfo(273' "Stone Shovel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StonePickaxe = new ItemInfo(274' "Stone Pickaxe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneAxe = new ItemInfo(275' "Stone Axe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondSword = new ItemInfo(276' "Diamond Sword");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondShovel = new ItemInfo(277' "Diamond Shovel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondPickaxe = new ItemInfo(278' "Diamond Pickaxe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondAxe = new ItemInfo(279' "Diamond Axe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Stick = new ItemInfo(280' "Stick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Stick = new ItemInfo(280' "Stick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bowl = new ItemInfo(281' "Bowl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bowl = new ItemInfo(281' "Bowl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MushroomSoup = new ItemInfo(282' "Mushroom Soup");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldSword = new ItemInfo(283' "Gold Sword");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldShovel = new ItemInfo(284' "Gold Shovel");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldPickaxe = new ItemInfo(285' "Gold Pickaxe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldAxe = new ItemInfo(286' "Gold Axe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: String = new ItemInfo(287' "String").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: String = new ItemInfo(287' "String").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Feather = new ItemInfo(288' "Feather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Feather = new ItemInfo(288' "Feather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Gunpowder = new ItemInfo(289' "Gunpowder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Gunpowder = new ItemInfo(289' "Gunpowder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenHoe = new ItemInfo(290' "Wooden Hoe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StoneHoe = new ItemInfo(291' "Stone Hoe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHoe = new ItemInfo(292' "Iron Hoe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHoe = new ItemInfo(293' "Diamond Hoe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHoe = new ItemInfo(294' "Gold Hoe");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Seeds = new ItemInfo(295' "Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Seeds = new ItemInfo(295' "Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Wheat = new ItemInfo(296' "Wheat").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Wheat = new ItemInfo(296' "Wheat").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bread = new ItemInfo(297' "Bread").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bread = new ItemInfo(297' "Bread").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherCap = new ItemInfo(298' "Leather Cap");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherTunic = new ItemInfo(299' "Leather Tunic");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherPants = new ItemInfo(300' "Leather Pants");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LeatherBoots = new ItemInfo(301' "Leather Boots");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainHelmet = new ItemInfo(302' "Chain Helmet");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainChestplate = new ItemInfo(303' "Chain Chestplate");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainLeggings = new ItemInfo(304' "Chain Leggings");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ChainBoots = new ItemInfo(305' "Chain Boots");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHelmet = new ItemInfo(306' "Iron Helmet");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronChestplate = new ItemInfo(307' "Iron Chestplate");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronLeggings = new ItemInfo(308' "Iron Leggings");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronBoots = new ItemInfo(309' "Iron Boots");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHelmet = new ItemInfo(310' "Diamond Helmet");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondChestplate = new ItemInfo(311' "Diamond Chestplate");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondLeggings = new ItemInfo(312' "Diamond Leggings");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondBoots = new ItemInfo(313' "Diamond Boots");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHelmet = new ItemInfo(314' "Gold Helmet");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldChestplate = new ItemInfo(315' "Gold Chestplate");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldLeggings = new ItemInfo(316' "Gold Leggings");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldBoots = new ItemInfo(317' "Gold Boots");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Flint = new ItemInfo(318' "Flint").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Flint = new ItemInfo(318' "Flint").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawPorkchop = new ItemInfo(319' "Raw Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawPorkchop = new ItemInfo(319' "Raw Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedPorkchop = new ItemInfo(320' "Cooked Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedPorkchop = new ItemInfo(320' "Cooked Porkchop").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Painting = new ItemInfo(321' "Painting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Painting = new ItemInfo(321' "Painting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenApple = new ItemInfo(322' "Golden Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenApple = new ItemInfo(322' "Golden Apple").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sign = new ItemInfo(323' "Sign");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WoodenDoor = new ItemInfo(324' "Door");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bucket = new ItemInfo(325' "Bucket");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WaterBucket = new ItemInfo(326' "Water Bucket");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: LavaBucket = new ItemInfo(327' "Lava Bucket");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Minecart = new ItemInfo(328' "Minecart");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Saddle = new ItemInfo(329' "Saddle");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronDoor = new ItemInfo(330' "Iron Door");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneDust = new ItemInfo(331' "Redstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneDust = new ItemInfo(331' "Redstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Snowball = new ItemInfo(332' "Snowball").SetStackSize(16);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Snowball = new ItemInfo(332' "Snowball").SetStackSize(16);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Boat = new ItemInfo(333' "Boat");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Leather = new ItemInfo(334' "Leather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Leather = new ItemInfo(334' "Leather").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Milk = new ItemInfo(335' "Milk");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ClayBrick = new ItemInfo(336' "Clay Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ClayBrick = new ItemInfo(336' "Clay Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clay = new ItemInfo(337' "Clay").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clay = new ItemInfo(337' "Clay").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SugarCane = new ItemInfo(338' "Sugar Cane").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SugarCane = new ItemInfo(338' "Sugar Cane").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Paper = new ItemInfo(339' "Paper").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Paper = new ItemInfo(339' "Paper").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Book = new ItemInfo(340' "Book").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Book = new ItemInfo(340' "Book").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Slimeball = new ItemInfo(341' "Slimeball").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Slimeball = new ItemInfo(341' "Slimeball").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: StorageMinecart = new ItemInfo(342' "Storage Minecart");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoweredMinecart = new ItemInfo(343' "Powered Minecart");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Egg = new ItemInfo(344' "Egg").SetStackSize(16);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Egg = new ItemInfo(344' "Egg").SetStackSize(16);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Compass = new ItemInfo(345' "Compass");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FishingRod = new ItemInfo(346' "Fishing Rod");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Clock = new ItemInfo(347' "Clock");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlowstoneDust = new ItemInfo(348' "Glowstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlowstoneDust = new ItemInfo(348' "Glowstone Dust").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawFish = new ItemInfo(349' "Raw Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawFish = new ItemInfo(349' "Raw Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedFish = new ItemInfo(350' "Cooked Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedFish = new ItemInfo(350' "Cooked Fish").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Dye = new ItemInfo(351' "Dye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Dye = new ItemInfo(351' "Dye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bone = new ItemInfo(352' "Bone").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bone = new ItemInfo(352' "Bone").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sugar = new ItemInfo(353' "Sugar").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Sugar = new ItemInfo(353' "Sugar").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cake = new ItemInfo(354' "Cake");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Bed = new ItemInfo(355' "Bed");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneRepeater = new ItemInfo(356' "Redstone Repeater").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneRepeater = new ItemInfo(356' "Redstone Repeater").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cookie = new ItemInfo(357' "Cookie").SetStackSize(8);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cookie = new ItemInfo(357' "Cookie").SetStackSize(8);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Map = new ItemInfo(358' "Map");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Shears = new ItemInfo(359' "Shears");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSlice = new ItemInfo(360' "Melon Slice").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSlice = new ItemInfo(360' "Melon Slice").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinSeeds = new ItemInfo(361' "Pumpkin Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinSeeds = new ItemInfo(361' "Pumpkin Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSeeds = new ItemInfo(362' "Melon Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MelonSeeds = new ItemInfo(362' "Melon Seeds").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawBeef = new ItemInfo(363' "Raw Beef").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawBeef = new ItemInfo(363' "Raw Beef").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Steak = new ItemInfo(364' "Steak").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Steak = new ItemInfo(364' "Steak").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawChicken = new ItemInfo(365' "Raw Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RawChicken = new ItemInfo(365' "Raw Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedChicken = new ItemInfo(366' "Cooked Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CookedChicken = new ItemInfo(366' "Cooked Chicken").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RottenFlesh = new ItemInfo(367' "Rotten Flesh").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RottenFlesh = new ItemInfo(367' "Rotten Flesh").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnderPearl = new ItemInfo(368' "Ender Pearl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnderPearl = new ItemInfo(368' "Ender Pearl").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazeRod = new ItemInfo(369' "Blaze Rod").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazeRod = new ItemInfo(369' "Blaze Rod").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GhastTear = new ItemInfo(370' "Ghast Tear").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GhastTear = new ItemInfo(370' "Ghast Tear").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldNugget = new ItemInfo(371' "Gold Nugget").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldNugget = new ItemInfo(371' "Gold Nugget").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherWart = new ItemInfo(372' "Nether Wart").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherWart = new ItemInfo(372' "Nether Wart").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potion = new ItemInfo(373' "Potion");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlassBottle = new ItemInfo(374' "Glass Bottle").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlassBottle = new ItemInfo(374' "Glass Bottle").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpiderEye = new ItemInfo(375' "Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpiderEye = new ItemInfo(375' "Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FermentedSpiderEye = new ItemInfo(376' "Fermented Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FermentedSpiderEye = new ItemInfo(376' "Fermented Spider Eye").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazePowder = new ItemInfo(377' "Blaze Powder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BlazePowder = new ItemInfo(377' "Blaze Powder").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MagmaCream = new ItemInfo(378' "Magma Cream").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MagmaCream = new ItemInfo(378' "Magma Cream").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BrewingStand = new ItemInfo(379' "Brewing Stand").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BrewingStand = new ItemInfo(379' "Brewing Stand").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Cauldron = new ItemInfo(380' "Cauldron");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EyeOfEnder = new ItemInfo(381' "Eye of Ender").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EyeOfEnder = new ItemInfo(381' "Eye of Ender").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlisteringMelon = new ItemInfo(382' "Glistering Melon").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GlisteringMelon = new ItemInfo(382' "Glistering Melon").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpawnEgg = new ItemInfo(383' "Spawn Egg").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: SpawnEgg = new ItemInfo(383' "Spawn Egg").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BottleOEnchanting = new ItemInfo(384' "Bottle O' Enchanting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BottleOEnchanting = new ItemInfo(384' "Bottle O' Enchanting").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireCharge = new ItemInfo(385' "Fire Charge").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireCharge = new ItemInfo(385' "Fire Charge").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BookAndQuill = new ItemInfo(386' "Book and Quill");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: WrittenBook = new ItemInfo(387' "Written Book");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Emerald = new ItemInfo(388' "Emerald").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Emerald = new ItemInfo(388' "Emerald").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ItemFrame = new ItemInfo(389' "Item Frame").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: ItemFrame = new ItemInfo(389' "Item Frame").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlowerPot = new ItemInfo(390' "Flower Pot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FlowerPot = new ItemInfo(390' "Flower Pot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Carrot = new ItemInfo(391' "Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Carrot = new ItemInfo(391' "Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potato = new ItemInfo(392' "Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Potato = new ItemInfo(392' "Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BakedPotato = new ItemInfo(393' "Baked Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: BakedPotato = new ItemInfo(393' "Baked Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoisonPotato = new ItemInfo(394' "Poisonous Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PoisonPotato = new ItemInfo(394' "Poisonous Potato").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EmptyMap = new ItemInfo(395' "Empty Map").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EmptyMap = new ItemInfo(395' "Empty Map").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenCarrot = new ItemInfo(396' "Golden Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldenCarrot = new ItemInfo(396' "Golden Carrot").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MobHead = new ItemInfo(397' "Mob Head").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MobHead = new ItemInfo(397' "Mob Head").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: CarrotOnStick = new ItemInfo(398' "Carrot on a Stick");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherStar = new ItemInfo(399' "Nether Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherStar = new ItemInfo(399' "Nether Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinPie = new ItemInfo(400' "Pumpkin Pie").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: PumpkinPie = new ItemInfo(400' "Pumpkin Pie").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkRocket = new ItemInfo(401' "Firework Rocket");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkStar = new ItemInfo(402' "Firework Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: FireworkStar = new ItemInfo(402' "Firework Star").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: EnchantedBook = new ItemInfo(403' "Enchanted Book");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneComparator = new ItemInfo(404' "Redstone Comparator").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: RedstoneComparator = new ItemInfo(404' "Redstone Comparator").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherBrick = new ItemInfo(405' "Nether Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherBrick = new ItemInfo(405' "Nether Brick").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherQuartz = new ItemInfo(406' "Nether Quartz").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NetherQuartz = new ItemInfo(406' "Nether Quartz").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: TntMinecart = new ItemInfo(407' "Minecart with TNT");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: HopperMinecart = new ItemInfo(408' "Minecart with Hopper");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: IronHorseArmor = new ItemInfo(417' "Iron Horse Armor");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: GoldHorseArmor = new ItemInfo(418' "Gold Horse Armor");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: DiamondHorseArmor = new ItemInfo(419' "Diamond Horse Armor");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Lead = new ItemInfo(420' "Lead").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: Lead = new ItemInfo(420' "Lead").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NameTag = new ItemInfo(421' "Name Tag").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: NameTag = new ItemInfo(421' "Name Tag").SetStackSize(64);
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDisc13 = new ItemInfo(2256' "13 Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscCat = new ItemInfo(2257' "Cat Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscBlocks = new ItemInfo(2258' "Blocks Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscChirp = new ItemInfo(2259' "Chirp Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscFar = new ItemInfo(2260' "Far Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscMall = new ItemInfo(2261' "Mall Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscMellohi = new ItemInfo(2262' "Mellohi Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscStal = new ItemInfo(2263' "Stal Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscStrad = new ItemInfo(2264' "Strad Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDiscWard = new ItemInfo(2265' "Ward Disc");
Magic Number,Substrate,ItemInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\ItemInfo.cs,ItemInfo,The following statement contains a magic number: MusicDisc11 = new ItemInfo(2266' "11 Disc");
Magic Number,Substrate,Enumerator,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\EntityCollection.cs,ParseFileName,The following statement contains a magic number: z = (int)Base36.Decode(match.Groups[2].Value);
Magic Number,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The following statement contains a magic number: _spawnY = 64;
Magic Number,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,Level,The following statement contains a magic number: _version = 19133;
Magic Number,Substrate,Level,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Level.cs,SetDefaultPlayer,The following statement contains a magic number: _player.Position.Y = _spawnY + 1.7;
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Grass = new BlockInfo(2' "Grass").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Grass = new BlockInfo(2' "Grass").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dirt = new BlockInfo(3' "Dirt");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cobblestone = new BlockInfo(4' "Cobblestone");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlank = new BlockInfo(5' "Wooden Plank");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling = new BlockInfo(6' "Sapling").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling = new BlockInfo(6' "Sapling").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bedrock = new BlockInfo(7' "Bedrock");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water = new BlockInfo(8' "Water").SetOpacity(3).SetState(BlockState.FLUID).SetTick(5);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryWater = new BlockInfo(9' "Stationary Water").SetOpacity(3).SetState(BlockState.FLUID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryWater = new BlockInfo(9' "Stationary Water").SetOpacity(3).SetState(BlockState.FLUID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava = new BlockInfo(10' "Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava = new BlockInfo(10' "Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryLava = new BlockInfo(11' "Stationary Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StationaryLava = new BlockInfo(11' "Stationary Lava").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.FLUID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sand = new BlockInfo(12' "Sand").SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sand = new BlockInfo(12' "Sand").SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Gravel = new BlockInfo(13' "Gravel").SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Gravel = new BlockInfo(13' "Gravel").SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GoldOre = new BlockInfo(14' "Gold Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronOre = new BlockInfo(15' "Iron Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CoalOre = new BlockInfo(16' "Coal Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wood = new BlockInfo(17' "Wood");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves = new BlockInfo(18' "Leaves").SetOpacity(1).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves = new BlockInfo(18' "Leaves").SetOpacity(1).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sponge = new BlockInfo(19' "Sponge");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Glass = new BlockInfo(20' "Glass").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LapisOre = new BlockInfo(21' "Lapis Lazuli Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LapisBlock = new BlockInfo(22' "Lapis Lazuli Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser = (BlockInfoEx)new BlockInfoEx(23' "Dispenser").SetTick(4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser = (BlockInfoEx)new BlockInfoEx(23' "Dispenser").SetTick(4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sandstone = new BlockInfo(24' "Sandstone");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NoteBlock = new BlockInfoEx(25' "Note Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bed = new BlockInfo(26' "Bed").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PoweredRail = new BlockInfo(27' "Powered Rail").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail = new BlockInfo(28' "Detector Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail = new BlockInfo(28' "Detector Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StickyPiston = new BlockInfo(29' "Sticky Piston").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cobweb = new BlockInfo(30' "Cobweb").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TallGrass = new BlockInfo(31' "Tall Grass").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DeadShrub = new BlockInfo(32' "Dead Shrub").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Piston = new BlockInfo(33' "Piston").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonHead = new BlockInfo(34' "Piston Head").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wool = new BlockInfo(35' "Wool");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonMoving = (BlockInfoEx)new BlockInfoEx(36' "Piston Moving").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: YellowFlower = new BlockInfo(37' "Yellow Flower").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: YellowFlower = new BlockInfo(37' "Yellow Flower").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedRose = new BlockInfo(38' "Red Rose").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedRose = new BlockInfo(38' "Red Rose").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrownMushroom = new BlockInfo(39' "Brown Mushroom").SetOpacity(0).SetLuminance(1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrownMushroom = new BlockInfo(39' "Brown Mushroom").SetOpacity(0).SetLuminance(1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedMushroom = new BlockInfo(40' "Red Mushroom").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedMushroom = new BlockInfo(40' "Red Mushroom").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GoldBlock = new BlockInfo(41' "Gold Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronBlock = new BlockInfo(42' "Iron Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleStoneSlab = new BlockInfo(43' "Double Slab");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneSlab = new BlockInfo(44' "Slab").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrickBlock = new BlockInfo(45' "Brick Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TNT = new BlockInfo(46' "TNT");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bookshelf = new BlockInfo(47' "Bookshelf");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MossStone = new BlockInfo(48' "Moss Stone");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Obsidian = new BlockInfo(49' "Obsidian");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch = new BlockInfo(50' "Torch").SetOpacity(0).SetLuminance(MAX_LUMINANCE - 1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch = new BlockInfo(50' "Torch").SetOpacity(0).SetLuminance(MAX_LUMINANCE - 1).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fire = new BlockInfo(51' "Fire").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID).SetTick(40);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fire = new BlockInfo(51' "Fire").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID).SetTick(40);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MonsterSpawner = (BlockInfoEx)new BlockInfoEx(52' "Monster Spawner").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodStairs = new BlockInfo(53' "Wooden Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Chest = (BlockInfoEx)new BlockInfoEx(54' "Chest").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneWire = new BlockInfo(55' "Redstone Wire").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DiamondOre = new BlockInfo(56' "Diamond Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DiamondBlock = new BlockInfo(57' "Diamond Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CraftTable = new BlockInfo(58' "Crafting Table");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops = new BlockInfo(59' "Crops").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops = new BlockInfo(59' "Crops").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Farmland = new BlockInfo(60' "Farmland").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Farmland = new BlockInfo(60' "Farmland").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace = new BlockInfoEx(61' "Furnace");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace = (BlockInfoEx)new BlockInfoEx(62' "Burning Furnace").SetLuminance(MAX_LUMINANCE - 1);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SignPost = (BlockInfoEx)new BlockInfoEx(63' "Sign Post").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodDoor = new BlockInfo(64' "Wooden Door").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder = new BlockInfo(65' "Ladder").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Rails = new BlockInfo(66' "Rails").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobbleStairs = new BlockInfo(67' "Cobblestone Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign = (BlockInfoEx)new BlockInfoEx(68' "Wall Sign").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lever = new BlockInfo(69' "Lever").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StonePlate = new BlockInfo(70' "Stone Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StonePlate = new BlockInfo(70' "Stone Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronDoor = new BlockInfo(71' "Iron Door").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlate = new BlockInfo(72' "Wooden Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodPlate = new BlockInfo(72' "Wooden Pressure Plate").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneOre = new BlockInfo(73' "Redstone Ore").SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneOre = new BlockInfo(73' "Redstone Ore").SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlowRedstoneOre = new BlockInfo(74' "Glowing Redstone Ore").SetLuminance(9).SetTick(30);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch = new BlockInfo(75' "Redstone Torch (Off)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch = new BlockInfo(75' "Redstone Torch (Off)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn = new BlockInfo(76' "Redstone Torch (On)").SetOpacity(0).SetLuminance(7).SetState(BlockState.NONSOLID).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneButton = new BlockInfo(77' "Stone Button").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow = new BlockInfo(78' "Snow").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow = new BlockInfo(78' "Snow").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ice = new BlockInfo(79' "Ice").SetOpacity(3).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SnowBlock = new BlockInfo(80' "Snow Block").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SnowBlock = new BlockInfo(80' "Snow Block").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus = new BlockInfo(81' "Cactus").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus = new BlockInfo(81' "Cactus").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ClayBlock = new BlockInfo(82' "Clay Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane = new BlockInfo(83' "Sugar Cane").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane = new BlockInfo(83' "Sugar Cane").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Jukebox = new BlockInfo(84' "Jukebox");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Fence = new BlockInfo(85' "Fence").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Pumpkin = new BlockInfo(86' "Pumpkin");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Netherrack = new BlockInfo(87' "Netherrack");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SoulSand = new BlockInfo(88' "Soul Sand");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Glowstone = new BlockInfo(89' "Glowstone Block").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Portal = new BlockInfo(90' "Portal").SetOpacity(0).SetLuminance(11).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Portal = new BlockInfo(90' "Portal").SetOpacity(0).SetLuminance(11).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JackOLantern = new BlockInfo(91' "Jack-O-Lantern").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CakeBlock = new BlockInfo(92' "Cake Block").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeater = new BlockInfo(93' "Redstone Repeater (Off)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeater = new BlockInfo(93' "Redstone Repeater (Off)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneRepeaterOn = new BlockInfo(94' "Redstone Repeater (On)").SetOpacity(0).SetLuminance(7).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LockedChest = (BlockInfoEx)new BlockInfoEx(95' "Locked Chest").SetLuminance(MAX_LUMINANCE).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LockedChest = (BlockInfoEx)new BlockInfoEx(95' "Locked Chest").SetLuminance(MAX_LUMINANCE).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedGlass = new BlockInfo(95' "Stained Glass").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Trapdoor = new BlockInfo(96' "Trapdoor").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SilverfishStone = new BlockInfo(97' "Stone with Silverfish");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrick = new BlockInfo(98' "Stone Brick");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeRedMushroom = new BlockInfo(99' "Huge Red Mushroom");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeBrownMushroom = new BlockInfo(100' "Huge Brown Mushroom");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronBars = new BlockInfo(101' "Iron Bars").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: GlassPane = new BlockInfo(102' "Glass Pane").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Melon = new BlockInfo(103' "Melon");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PumpkinStem = new BlockInfo(104' "Pumpkin Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PumpkinStem = new BlockInfo(104' "Pumpkin Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MelonStem = new BlockInfo(105' "Melon Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: MelonStem = new BlockInfo(105' "Melon Stem").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Vines = new BlockInfo(106' "Vines").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Vines = new BlockInfo(106' "Vines").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FenceGate = new BlockInfo(107' "Fence Gate").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrickStairs = new BlockInfo(108' "Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrickStairs = new BlockInfo(109' "Stone Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Mycelium = new BlockInfo(110' "Mycelium").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Mycelium = new BlockInfo(110' "Mycelium").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: LillyPad = new BlockInfo(111' "Lilly Pad").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrick = new BlockInfo(112' "Nether Brick");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrickFence = new BlockInfo(113' "Nether Brick Fence").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherBrickStairs = new BlockInfo(114' "Nether Brick Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherWart = new BlockInfo(115' "Nether Wart").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherWart = new BlockInfo(115' "Nether Wart").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnchantmentTable = (BlockInfoEx)new BlockInfoEx(116' "Enchantment Table").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BrewingStand = (BlockInfoEx)new BlockInfoEx(117' "Brewing Stand").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cauldron = new BlockInfo(118' "Cauldron").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndPortal = (BlockInfoEx)new BlockInfoEx(119' "End Portal").SetOpacity(0).SetLuminance(MAX_LUMINANCE).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndPortalFrame = new BlockInfo(120' "End Portal Frame").SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EndStone = new BlockInfo(121' "End Stone");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DragonEgg = new BlockInfo(122' "Dragon Egg").SetOpacity(0).SetLuminance(1).SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DragonEgg = new BlockInfo(122' "Dragon Egg").SetOpacity(0).SetLuminance(1).SetTick(3);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOff = new BlockInfo(123' "Redstone Lamp (Off)").SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOff = new BlockInfo(123' "Redstone Lamp (Off)").SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneLampOn = new BlockInfo(124' "Redstone Lamp (On)").SetLuminance(15).SetTick(2);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleWoodSlab = new BlockInfo(125' "Double Wood Slab");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodSlab = new BlockInfo(126' "Wood Slab");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CocoaPlant = new BlockInfo(127' "Cocoa Plant").SetLuminance(2).SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CocoaPlant = new BlockInfo(127' "Cocoa Plant").SetLuminance(2).SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SandstoneStairs = new BlockInfo(128' "Sandstone Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EmeraldOre = new BlockInfo(129' "Emerald Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnderChest = (BlockInfoEx)new BlockInfoEx(130' "Ender Chest").SetLuminance(7).SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EnderChest = (BlockInfoEx)new BlockInfoEx(130' "Ender Chest").SetLuminance(7).SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TripwireHook = new BlockInfo(131' "Tripwire Hook").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Tripwire = new BlockInfo(132' "Tripwire").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: EmeraldBlock = new BlockInfo(133' "Emerald Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SpruceWoodStairs = new BlockInfo(134' "Sprice Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BirchWoodStairs = new BlockInfo(135' "Birch Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JungleWoodStairs = new BlockInfo(136' "Jungle Wood Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CommandBlock = (BlockInfoEx)new BlockInfoEx(137' "Command Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BeaconBlock = (BlockInfoEx)new BlockInfoEx(138' "Beacon Block").SetOpacity(0).SetLuminance(MAX_LUMINANCE);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobblestoneWall = new BlockInfo(139' "Cobblestone Wall").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FlowerPot = new BlockInfo(140' "Flower Pot").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carrots = new BlockInfo(141' "Carrots").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carrots = new BlockInfo(141' "Carrots").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Potatoes = new BlockInfo(142' "Potatoes").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Potatoes = new BlockInfo(142' "Potatoes").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodButton = new BlockInfo(143' "Wooden Button").SetOpacity(0).SetState(BlockState.NONSOLID);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Heads = new BlockInfo(144' "Heads").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Anvil = new BlockInfo(145' "Anvil").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TrappedChest = (BlockInfoEx)new BlockInfoEx(146' "Trapped Chest").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TrappedChest = (BlockInfoEx)new BlockInfoEx(146' "Trapped Chest").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateLight = new BlockInfo(147' "Weighted Pressure Plate (Light)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateLight = new BlockInfo(147' "Weighted Pressure Plate (Light)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateHeavy = new BlockInfo(148' "Weighted Pressure Plate (Heavy)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WeightedPressurePlateHeavy = new BlockInfo(148' "Weighted Pressure Plate (Heavy)").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(20);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorInactive = new BlockInfo(149' "Redstone Comparator (Inactive)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorInactive = new BlockInfo(149' "Redstone Comparator (Inactive)").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneComparatorActive = new BlockInfo(150' "Redstone Comparator (Active)").SetOpacity(0).SetLuminance(9).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DaylightSensor = new BlockInfo(151' "Daylight Sensor").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DaylightSensor = new BlockInfo(151' "Daylight Sensor").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneBlock = new BlockInfo(152' "Block of Redstone").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneBlock = new BlockInfo(152' "Block of Redstone").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: NetherQuartzOre = new BlockInfo(153' "Neither Quartz Ore");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper = (BlockInfoEx)new BlockInfoEx(154' "Hopper").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper = (BlockInfoEx)new BlockInfoEx(154' "Hopper").SetOpacity(0).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzBlock = new BlockInfo(155' "Block of Quartz");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzStairs = new BlockInfo(156' "Quartz Stairs").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ActivatorRail = new BlockInfo(157' "Activator Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: ActivatorRail = new BlockInfo(157' "Activator Rail").SetOpacity(0).SetState(BlockState.NONSOLID).SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper = (BlockInfoEx)new BlockInfoEx(158' "Dropper").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper = (BlockInfoEx)new BlockInfoEx(158' "Dropper").SetTick(10);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedClay = new BlockInfo(159' "Stained Clay");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StainedGlassPane = new BlockInfo(160' "Stained Glass Pane").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HayBlock = new BlockInfo(170' "Hay Block");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carpet = new BlockInfo(171' "Carpet").SetOpacity(0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HardenedClay = new BlockInfo(172' "Hardened Clay");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CoalBlock = new BlockInfo(173' "Block of Coal");
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wood.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Leaves.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Jukebox.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Sapling.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SugarCane.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Water.SetDataLimits(0' 7' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lava.SetDataLimits(0' 7' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TallGrass.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Crops.SetDataLimits(0' 7' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PoweredRail.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DetectorRail.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StickyPiston.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Piston.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: PistonHead.SetDataLimits(1' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Wool.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Torch.SetDataLimits(1' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorch.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: RedstoneTorchOn.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Rails.SetDataLimits(0' 9' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Ladder.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: CobbleStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Lever.SetDataLimits(0' 6' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodDoor.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: IronDoor.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneButton.SetDataLimits(1' 4' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Snow.SetDataLimits(0' 7' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SignPost.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WallSign.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Furnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: BurningFurnace.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dispenser.SetDataLimits(2' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Pumpkin.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: JackOLantern.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneSlab.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleStoneSlab.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cactus.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Bed.SetDataLimits(0' 3' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Trapdoor.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: StoneBrick.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeRedMushroom.SetDataLimits(0' 10' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: HugeBrownMushroom.SetDataLimits(0' 10' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: FenceGate.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: SilverfishStone.SetDataLimits(0' 2' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Cauldron.SetDataLimits(0' 3' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: WoodSlab.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: DoubleWoodSlab.SetDataLimits(0' 5' 0x8);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: TripwireHook.SetDataLimits(0' 3' 0xC);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzBlock.SetDataLimits(0' 4' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: QuartzStairs.SetDataLimits(0' 3' 0x4);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Carpet.SetDataLimits(0' 15' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Dropper.SetDataLimits(0' 5' 0);
Magic Number,Substrate,BlockInfo,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\BlockInfo.cs,BlockInfo,The following statement contains a magic number: Hopper.SetDataLimits(0' 5' 0);
Magic Number,Substrate,AlphaChunkManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\AlphaChunkManager.cs,AlphaChunkManager,The following statement contains a magic number: _cache = new LRUCache<ChunkKey' ChunkRef>(256);
Magic Number,Substrate,Entity,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Entity.cs,LoadTree,The following statement contains a magic number: _pos.Z = pos[2].ToTagDouble();
Magic Number,Substrate,Entity,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Entity.cs,LoadTree,The following statement contains a magic number: _motion.Z = motion[2].ToTagDouble();
Magic Number,Substrate,Player,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,Player,The following statement contains a magic number: Air = 300;
Magic Number,Substrate,Player,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Player.cs,Player,The following statement contains a magic number: Fire = -20;
Magic Number,Substrate,SpawnPoint,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate,SpawnPoint,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _x;
Magic Number,Substrate,SpawnPoint,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _y;
Magic Number,Substrate,SpawnPoint,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\SpawnPoint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + _z;
Magic Number,Substrate.Core,Region,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,ForeignX,The following statement contains a magic number: return (lcx + XDIM * 10000) & XMASK;
Magic Number,Substrate.Core,Region,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Region.cs,ForeignZ,The following statement contains a magic number: return (lcz + ZDIM * 10000) & ZMASK;
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,GetChunk,The following statement contains a magic number: int cx = x / _xdim + (x >> 31);
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,GetChunk,The following statement contains a magic number: int cz = z / _zdim + (z >> 31);
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The following statement contains a magic number: while (searchQueue.Count > 0) {                  BlockKey branch = searchQueue.Dequeue();                  int distance = markTable[branch];                    // Ignore blocks out of range                  if (distance > reach) {                      continue;                  }                    // Ignore invalid blocks                  BlockCoord branchHigh = TranslateCoord(branch.x' branch.y' branch.z);                  if (branchHigh.chunk == null || branch.y == 0) {                      markTable.Remove(branch);                      continue;                  }                    // If we're not the magical source block...                  if (distance > 0) {                      // Ignore blocks that block fluid (and thus could not become a fluid)                      BlockInfo branchHighInfo = branchHigh.chunk.GetInfo(branchHigh.lx' branchHigh.ly' branchHigh.lz);                      if (branchHighInfo.BlocksFluid) {                          markTable.Remove(branch);                          continue;                      }                  }                    // If we found a hole' add as a sink' mark the sink distance.                  BlockCoord branchLow = TranslateCoord(branch.x' branch.y - 1' branch.z);                  BlockInfo branchLowInfo = branchLow.chunk.GetInfo(branchLow.lx' branchLow.ly' branchLow.lz);                  if (!branchLowInfo.BlocksFluid) {                      // If we are our own sink' return the only legal outflow                      if (key == branch) {                          List<BlockKey> ret = new List<BlockKey>();                          ret.Add(new BlockKey(branch.x' branch.y - 1' branch.z));                          return ret;                      }                        reach = distance;                      traceQueue.Enqueue(new KeyValuePair<BlockKey' int>(branch' distance));                      continue;                  }                    // Expand to neighbors                  if (distance < reach) {                      BlockKey[] keys = {                          new BlockKey(branch.x - 1' branch.y' branch.z)'                          new BlockKey(branch.x + 1' branch.y' branch.z)'                          new BlockKey(branch.x' branch.y' branch.z - 1)'                          new BlockKey(branch.x' branch.y' branch.z + 1)'                      };                        for (int i = 0; i < 4; i++) {                          if (!markTable.ContainsKey(keys[i])) {                              searchQueue.Enqueue(keys[i]);                              markTable.Add(keys[i]' distance + 1);                          }                      }                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileOutflow,The following statement contains a magic number: while (traceQueue.Count > 0) {                    KeyValuePair<BlockKey' int> tilekv = traceQueue.Dequeue();                  BlockKey tile = tilekv.Key;                    int distance = tilekv.Value;                  markTable.Remove(tile);                    BlockKey[] keys = {                      new BlockKey(tile.x - 1' tile.y' tile.z)'                      new BlockKey(tile.x + 1' tile.y' tile.z)'                      new BlockKey(tile.x' tile.y' tile.z - 1)'                      new BlockKey(tile.x' tile.y' tile.z + 1)'                  };                    for (int i = 0; i < 4; i++) {                      int nval;                      if (!markTable.TryGetValue(keys[i]' out nval)) {                          continue;                      }                        if (nval < distance) {                          markTable.Remove(keys[i]);                          traceQueue.Enqueue(new KeyValuePair<BlockKey' int>(keys[i]' nval));                      }                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,The following statement contains a magic number: int minFlow = 16;
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,TileInflow,The following statement contains a magic number: for (int i = 0; i < 4; i++) {                  BlockCoord neighbor = TranslateCoord(keys[i].x' keys[i].y' keys[i].z);                  if (neighbor.chunk == null) {                      continue;                  }                    BlockInfo neighborInfo = neighbor.chunk.GetInfo(neighbor.lx' neighbor.ly' neighbor.lz);                    if (neighborInfo.State == BlockState.FLUID) {                      int flow = neighbor.chunk.GetData(neighbor.lx' neighbor.ly' neighbor.lz);                      bool flowFall = (flow & (int)LiquidState.FALLING) != 0;                        if (flowFall) {                          if (keys[i].y == 0) {                              continue;                          }                            BlockCoord low = TranslateCoord(keys[i].x' keys[i].y - 1' keys[i].z);                          BlockInfo lowinfo = low.chunk.GetInfo(low.lx' low.ly' low.lz);                            if (lowinfo.BlocksFluid) {                              return 0;                          }                          continue;                      }                      if (flow < minFlow) {                          minFlow = flow;                      }                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoWater,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 7) {                      newflow = 16;                  }                  else {                      newflow = inflow + 1;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove water tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting lava' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                          if ((newflow & (int)LiquidState.FALLING) != 0) {                              int odata = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                              if (odata == 0) {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Obsidian.ID);                              }                              else {                                  tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              }                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        // Otherwise replace the tile with our water flow                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryWater.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockFluid,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockFluid.cs,DoLava,The following statement contains a magic number: while (flowQueue.Count > 0) {                  BlockKey key = flowQueue.Dequeue();                    int curflow = 16;                  int inflow = TileInflow(key);                    BlockCoord tile = TranslateCoord(key.x' key.y' key.z);                  BlockInfo tileInfo = tile.chunk.GetInfo(tile.lx' tile.ly' tile.lz);                  if (tileInfo.ID == BlockInfo.StationaryLava.ID || tileInfo.ID == BlockInfo.Lava.ID) {                      curflow = tile.chunk.GetData(tile.lx' tile.ly' tile.lz);                  }                  else if (tileInfo.BlocksFluid) {                      continue;                  }                    bool curFall = (curflow & (int)LiquidState.FALLING) != 0;                  bool inFall = (inflow & (int)LiquidState.FALLING) != 0;                    // We won't update from the following states                  if (curflow == 0 || curflow == inflow || curFall) {                      continue;                  }                    int newflow = curflow;                    // Update from inflow if necessary                  if (inFall) {                      newflow = inflow;                  }                  else if (inflow >= 6) {                      newflow = 16;                  }                  else {                      newflow = inflow + 2;                  }                    // If we haven't changed the flow' don't propagate                  if (newflow == curflow) {                      continue;                  }                    // Update flow' add or remove lava tile as necessary                  if (newflow < 16 && curflow == 16) {                      // If we're overwriting water' replace with appropriate stone type and abort propagation                      if (tileInfo.ID == BlockInfo.StationaryWater.ID || tileInfo.ID == BlockInfo.Water.ID) {                          if ((newflow & (int)LiquidState.FALLING) == 0) {                              tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Cobblestone.ID);                              tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                              continue;                          }                      }                        tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.StationaryLava.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                  else if (newflow == 16) {                      tile.chunk.SetID(tile.lx' tile.ly' tile.lz' BlockInfo.Air.ID);                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' 0);                  }                  else {                      tile.chunk.SetData(tile.lx' tile.ly' tile.lz' newflow);                  }                    // Process outflows                  outflow = TileOutflow(key);                    foreach (BlockKey nkey in outflow) {                      flowQueue.Enqueue(nkey);                  }              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,BlockLight,The following statement contains a magic number: _lightbit = new BitArray(_blockset.XDim * 3 * _blockset.ZDim * 3 * _blockset.YDim);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: if (map[1' 2] != null) {                  StitchBlockLight(map[1' 2]' BlockCollectionEdge.WEST);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: if (map[1' 2] != null) {                  StitchBlockLight(map[1' 2]' BlockCollectionEdge.WEST);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: if (map[2' 1] != null) {                  StitchBlockLight(map[2' 1]' BlockCollectionEdge.SOUTH);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following statement contains a magic number: if (map[2' 1] != null) {                  StitchBlockLight(map[2' 1]' BlockCollectionEdge.SOUTH);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: if (map[1' 2] != null) {                  StitchBlockSkyLight(map[1' 2]' BlockCollectionEdge.WEST);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: if (map[1' 2] != null) {                  StitchBlockSkyLight(map[1' 2]' BlockCollectionEdge.WEST);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: if (map[2' 1] != null) {                  StitchBlockSkyLight(map[2' 1]' BlockCollectionEdge.SOUTH);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following statement contains a magic number: if (map[2' 1] != null) {                  StitchBlockSkyLight(map[2' 1]' BlockCollectionEdge.SOUTH);              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LightBitmapIndex,The following statement contains a magic number: int xstride = _zdim * 3 * zstride;
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: if (key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31) {                  return;              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: if (key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31) {                  return;              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: if (key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31) {                  return;              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,QueueRelight,The following statement contains a magic number: if (key.x < -15 || key.x >= 31 || key.z < -15 || key.z >= 31) {                  return;              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,NeighborHeight,The following statement contains a magic number: x = (x + _xdim * 2) % _xdim;
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,NeighborHeight,The following statement contains a magic number: z = (z + _zdim * 2) % _zdim;
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: IBoundedLitBlockCollection['] map = new IBoundedLitBlockCollection[3' 3];
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: IBoundedLitBlockCollection['] map = new IBoundedLitBlockCollection[3' 3];
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[0' 2] = OnResolveNeighbor(-1' 0' 1);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[1' 2] = OnResolveNeighbor(0' 0' 1);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 0] = OnResolveNeighbor(1' 0' -1);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 1] = OnResolveNeighbor(1' 0' 0);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 2] = OnResolveNeighbor(1' 0' 1);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalBlockLightMap,The following statement contains a magic number: map[2' 2] = OnResolveNeighbor(1' 0' 1);
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: int['] map = new int[3 * xdim' 3 * zdim];
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: int['] map = new int[3 * xdim' 3 * zdim];
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: for (int xi = 0; xi < 3; xi++) {                  int xoff = xi * xdim;                  for (int zi = 0; zi < 3; zi++) {                      int zoff = zi * zdim;                      if (chunkMap[xi' zi] == null) {                          continue;                      }                        for (int x = 0; x < xdim; x++) {                          int xx = xoff + x;                          for (int z = 0; z < zdim; z++) {                              int zz = zoff + z;                              map[xx' zz] = chunkMap[xi' zi].GetHeight(x' z);                          }                      }                  }              }
Magic Number,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,LocalHeightMap,The following statement contains a magic number: for (int xi = 0; xi < 3; xi++) {                  int xoff = xi * xdim;                  for (int zi = 0; zi < 3; zi++) {                      int zoff = zi * zdim;                      if (chunkMap[xi' zi] == null) {                          continue;                      }                        for (int x = 0; x < xdim; x++) {                          int xx = xoff + x;                          for (int z = 0; z < zdim; z++) {                              int zz = zoff + z;                              map[xx' zz] = chunkMap[xi' zi].GetHeight(x' z);                          }                      }                  }              }
Magic Number,Substrate.Core,PlayerFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\PlayerFile.cs,NameFromFilename,The following statement contains a magic number: if (filename.EndsWith(".dat")) {                  return filename.Remove(filename.Length - 4);              }
Magic Number,Substrate.Core,BlockKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,BlockKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + x;
Magic Number,Substrate.Core,BlockKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + y;
Magic Number,Substrate.Core,BlockKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + z;
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: while (cx < 0) {                  cx += (64 * 64);              }
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: while (cx < 0) {                  cx += (64 * 64);              }
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: while (cz < 0) {                  cz += (64 * 64);              }
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: while (cz < 0) {                  cz += (64 * 64);              }
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: string dir1 = Base36.Encode(cx % 64);
Magic Number,Substrate.Core,ChunkFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkFile.cs,ChunkFile,The following statement contains a magic number: string dir2 = Base36.Encode(cz % 64);
Magic Number,Substrate.Core,ChunkKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,ChunkKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + cx;
Magic Number,Substrate.Core,ChunkKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\ChunkKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + cz;
Magic Number,Substrate.Core,NBTFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NBTFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,ReadFile,The following statement contains a magic number: try {                  lock (this.fileLock) {                      file = new FileStream(fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.ReadWrite);                        //using (file) {                      if (file.Length < SectorBytes) {                          byte[] int0 = BitConverter.GetBytes((int)0);                            /* we need to write the chunk offset table */                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                          // write another sector for the timestamp info                          for (int i = 0; i < SectorInts; ++i) {                              file.Write(int0' 0' 4);                          }                            file.Flush();                            sizeDelta += SectorBytes * 2;                      }                        if ((file.Length & 0xfff) != 0) {                          /* the file size is not a multiple of 4KB' grow it */                          file.Seek(0' SeekOrigin.End);                          for (int i = 0; i < (file.Length & 0xfff); ++i) {                              file.WriteByte(0);                          }                            file.Flush();                      }                        /* set up the available sector map */                      int nSectors = (int)file.Length / SectorBytes;                      sectorFree = new List<Boolean>(nSectors);                        for (int i = 0; i < nSectors; ++i) {                          sectorFree.Add(true);                      }                        sectorFree[0] = false; // chunk offset table                      sectorFree[1] = false; // for the last modified info                        file.Seek(0' SeekOrigin.Begin);                      for (int i = 0; i < SectorInts; ++i) {                          byte[] offsetBytes = new byte[4];                          file.Read(offsetBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(offsetBytes);                          }                          int offset = BitConverter.ToInt32(offsetBytes' 0);                            offsets[i] = offset;                          if (offset != 0 && (offset >> 8) + (offset & 0xFF) <= sectorFree.Count) {                              for (int sectorNum = 0; sectorNum < (offset & 0xFF); ++sectorNum) {                                  sectorFree[(offset >> 8) + sectorNum] = false;                              }                          }                      }                      for (int i = 0; i < SectorInts; ++i) {                          byte[] modBytes = new byte[4];                          file.Read(modBytes' 0' 4);                            if (BitConverter.IsLittleEndian) {                              Array.Reverse(modBytes);                          }                          int lastModValue = BitConverter.ToInt32(modBytes' 0);                            chunkTimestamps[i] = lastModValue;                      }                  }              }              catch (IOException e) {                  System.Console.WriteLine(e.Message);                  System.Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  if (offset == 0) {                      // Debugln("READ"' x' z' "miss");                      return null;                  }                    int sectorNumber = offset >> 8;                  int numSectors = offset & 0xFF;                    lock (this.fileLock)                  {                      if (sectorNumber + numSectors > sectorFree.Count) {                          Debugln("READ"' x' z' "invalid sector");                          return null;                      }                        file.Seek(sectorNumber * SectorBytes' SeekOrigin.Begin);                      byte[] lengthBytes = new byte[4];                      file.Read(lengthBytes' 0' 4);                        if (BitConverter.IsLittleEndian) {                          Array.Reverse(lengthBytes);                      }                      int length = BitConverter.ToInt32(lengthBytes' 0);                        if (length > SectorBytes * numSectors) {                          Debugln("READ"' x' z' "invalid length: " + length + " > 4096 * " + numSectors);                          return null;                      }                        byte version = (byte)file.ReadByte();                      if (version == VERSION_GZIP) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                          Stream ret = new GZipStream(new MemoryStream(data)' CompressionMode.Decompress);                            return ret;                      }                      else if (version == VERSION_DEFLATE) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                            Stream ret = new ZlibStream(new MemoryStream(data)' CompressionMode.Decompress' true);                          return ret;                            /*MemoryStream sinkZ = new MemoryStream();                          ZlibStream zOut = new ZlibStream(sinkZ' CompressionMode.Decompress' true);                          zOut.Write(data' 0' data.Length);                          zOut.Flush();                          zOut.Close();                            sinkZ.Seek(0' SeekOrigin.Begin);                          return sinkZ;*/                      }                        Debugln("READ"' x' z' "unknown version " + version);                      return null;                  }              }              catch (IOException) {                  Debugln("READ"' x' z' "exception");                  return null;              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  if (offset == 0) {                      // Debugln("READ"' x' z' "miss");                      return null;                  }                    int sectorNumber = offset >> 8;                  int numSectors = offset & 0xFF;                    lock (this.fileLock)                  {                      if (sectorNumber + numSectors > sectorFree.Count) {                          Debugln("READ"' x' z' "invalid sector");                          return null;                      }                        file.Seek(sectorNumber * SectorBytes' SeekOrigin.Begin);                      byte[] lengthBytes = new byte[4];                      file.Read(lengthBytes' 0' 4);                        if (BitConverter.IsLittleEndian) {                          Array.Reverse(lengthBytes);                      }                      int length = BitConverter.ToInt32(lengthBytes' 0);                        if (length > SectorBytes * numSectors) {                          Debugln("READ"' x' z' "invalid length: " + length + " > 4096 * " + numSectors);                          return null;                      }                        byte version = (byte)file.ReadByte();                      if (version == VERSION_GZIP) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                          Stream ret = new GZipStream(new MemoryStream(data)' CompressionMode.Decompress);                            return ret;                      }                      else if (version == VERSION_DEFLATE) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                            Stream ret = new ZlibStream(new MemoryStream(data)' CompressionMode.Decompress' true);                          return ret;                            /*MemoryStream sinkZ = new MemoryStream();                          ZlibStream zOut = new ZlibStream(sinkZ' CompressionMode.Decompress' true);                          zOut.Write(data' 0' data.Length);                          zOut.Flush();                          zOut.Close();                            sinkZ.Seek(0' SeekOrigin.Begin);                          return sinkZ;*/                      }                        Debugln("READ"' x' z' "unknown version " + version);                      return null;                  }              }              catch (IOException) {                  Debugln("READ"' x' z' "exception");                  return null;              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetChunkDataInputStream,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  if (offset == 0) {                      // Debugln("READ"' x' z' "miss");                      return null;                  }                    int sectorNumber = offset >> 8;                  int numSectors = offset & 0xFF;                    lock (this.fileLock)                  {                      if (sectorNumber + numSectors > sectorFree.Count) {                          Debugln("READ"' x' z' "invalid sector");                          return null;                      }                        file.Seek(sectorNumber * SectorBytes' SeekOrigin.Begin);                      byte[] lengthBytes = new byte[4];                      file.Read(lengthBytes' 0' 4);                        if (BitConverter.IsLittleEndian) {                          Array.Reverse(lengthBytes);                      }                      int length = BitConverter.ToInt32(lengthBytes' 0);                        if (length > SectorBytes * numSectors) {                          Debugln("READ"' x' z' "invalid length: " + length + " > 4096 * " + numSectors);                          return null;                      }                        byte version = (byte)file.ReadByte();                      if (version == VERSION_GZIP) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                          Stream ret = new GZipStream(new MemoryStream(data)' CompressionMode.Decompress);                            return ret;                      }                      else if (version == VERSION_DEFLATE) {                          byte[] data = new byte[length - 1];                          file.Read(data' 0' data.Length);                            Stream ret = new ZlibStream(new MemoryStream(data)' CompressionMode.Decompress' true);                          return ret;                            /*MemoryStream sinkZ = new MemoryStream();                          ZlibStream zOut = new ZlibStream(sinkZ' CompressionMode.Decompress' true);                          zOut.Write(data' 0' data.Length);                          zOut.Flush();                          zOut.Close();                            sinkZ.Seek(0' SeekOrigin.Begin);                          return sinkZ;*/                      }                        Debugln("READ"' x' z' "unknown version " + version);                      return null;                  }              }              catch (IOException) {                  Debugln("READ"' x' z' "exception");                  return null;              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  int sectorNumber = offset >> 8;                  int sectorsAllocated = offset & 0xFF;                  int sectorsNeeded = (length + CHUNK_HEADER_SIZE) / SectorBytes + 1;                    // maximum chunk size is 1MB                  if (sectorsNeeded >= 256) {                      return;                  }                    if (sectorNumber != 0 && sectorsAllocated == sectorsNeeded) {                      /* we can simply overwrite the old sectors */                      Debug("SAVE"' x' z' length' "rewrite");                      Write(sectorNumber' data' length);                  }                  else {                      /* we need to allocate new sectors */                        lock (this.fileLock) {                          /* mark the sectors previously used for this chunk as free */                          for (int i = 0; i < sectorsAllocated; ++i) {                              sectorFree[sectorNumber + i] = true;                          }                            /* scan for a free space large enough to store this chunk */                          int runStart = sectorFree.FindIndex(b => b == true);                          int runLength = 0;                          if (runStart != -1) {                              for (int i = runStart; i < sectorFree.Count; ++i) {                                  if (runLength != 0) {                                      if (sectorFree[i]) runLength++;                                      else runLength = 0;                                  }                                  else if (sectorFree[i]) {                                      runStart = i;                                      runLength = 1;                                  }                                  if (runLength >= sectorsNeeded) {                                      break;                                  }                              }                          }                            if (runLength >= sectorsNeeded) {                              /* we found a free space large enough */                              Debug("SAVE"' x' z' length' "reuse");                              sectorNumber = runStart;                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                              for (int i = 0; i < sectorsNeeded; ++i) {                                  sectorFree[sectorNumber + i] = false;                              }                              Write(sectorNumber' data' length);                          }                          else {                              /*                               * no free space large enough found -- we need to grow the                               * file                               */                              Debug("SAVE"' x' z' length' "grow");                              file.Seek(0' SeekOrigin.End);                              sectorNumber = sectorFree.Count;                              for (int i = 0; i < sectorsNeeded; ++i) {                                  file.Write(emptySector' 0' emptySector.Length);                                  sectorFree.Add(false);                              }                              sizeDelta += SectorBytes * sectorsNeeded;                                Write(sectorNumber' data' length);                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                          }                      }                  }                  SetTimestamp(x' z' timestamp);              }              catch (IOException e) {                  Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  int sectorNumber = offset >> 8;                  int sectorsAllocated = offset & 0xFF;                  int sectorsNeeded = (length + CHUNK_HEADER_SIZE) / SectorBytes + 1;                    // maximum chunk size is 1MB                  if (sectorsNeeded >= 256) {                      return;                  }                    if (sectorNumber != 0 && sectorsAllocated == sectorsNeeded) {                      /* we can simply overwrite the old sectors */                      Debug("SAVE"' x' z' length' "rewrite");                      Write(sectorNumber' data' length);                  }                  else {                      /* we need to allocate new sectors */                        lock (this.fileLock) {                          /* mark the sectors previously used for this chunk as free */                          for (int i = 0; i < sectorsAllocated; ++i) {                              sectorFree[sectorNumber + i] = true;                          }                            /* scan for a free space large enough to store this chunk */                          int runStart = sectorFree.FindIndex(b => b == true);                          int runLength = 0;                          if (runStart != -1) {                              for (int i = runStart; i < sectorFree.Count; ++i) {                                  if (runLength != 0) {                                      if (sectorFree[i]) runLength++;                                      else runLength = 0;                                  }                                  else if (sectorFree[i]) {                                      runStart = i;                                      runLength = 1;                                  }                                  if (runLength >= sectorsNeeded) {                                      break;                                  }                              }                          }                            if (runLength >= sectorsNeeded) {                              /* we found a free space large enough */                              Debug("SAVE"' x' z' length' "reuse");                              sectorNumber = runStart;                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                              for (int i = 0; i < sectorsNeeded; ++i) {                                  sectorFree[sectorNumber + i] = false;                              }                              Write(sectorNumber' data' length);                          }                          else {                              /*                               * no free space large enough found -- we need to grow the                               * file                               */                              Debug("SAVE"' x' z' length' "grow");                              file.Seek(0' SeekOrigin.End);                              sectorNumber = sectorFree.Count;                              for (int i = 0; i < sectorsNeeded; ++i) {                                  file.Write(emptySector' 0' emptySector.Length);                                  sectorFree.Add(false);                              }                              sizeDelta += SectorBytes * sectorsNeeded;                                Write(sectorNumber' data' length);                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                          }                      }                  }                  SetTimestamp(x' z' timestamp);              }              catch (IOException e) {                  Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  int sectorNumber = offset >> 8;                  int sectorsAllocated = offset & 0xFF;                  int sectorsNeeded = (length + CHUNK_HEADER_SIZE) / SectorBytes + 1;                    // maximum chunk size is 1MB                  if (sectorsNeeded >= 256) {                      return;                  }                    if (sectorNumber != 0 && sectorsAllocated == sectorsNeeded) {                      /* we can simply overwrite the old sectors */                      Debug("SAVE"' x' z' length' "rewrite");                      Write(sectorNumber' data' length);                  }                  else {                      /* we need to allocate new sectors */                        lock (this.fileLock) {                          /* mark the sectors previously used for this chunk as free */                          for (int i = 0; i < sectorsAllocated; ++i) {                              sectorFree[sectorNumber + i] = true;                          }                            /* scan for a free space large enough to store this chunk */                          int runStart = sectorFree.FindIndex(b => b == true);                          int runLength = 0;                          if (runStart != -1) {                              for (int i = runStart; i < sectorFree.Count; ++i) {                                  if (runLength != 0) {                                      if (sectorFree[i]) runLength++;                                      else runLength = 0;                                  }                                  else if (sectorFree[i]) {                                      runStart = i;                                      runLength = 1;                                  }                                  if (runLength >= sectorsNeeded) {                                      break;                                  }                              }                          }                            if (runLength >= sectorsNeeded) {                              /* we found a free space large enough */                              Debug("SAVE"' x' z' length' "reuse");                              sectorNumber = runStart;                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                              for (int i = 0; i < sectorsNeeded; ++i) {                                  sectorFree[sectorNumber + i] = false;                              }                              Write(sectorNumber' data' length);                          }                          else {                              /*                               * no free space large enough found -- we need to grow the                               * file                               */                              Debug("SAVE"' x' z' length' "grow");                              file.Seek(0' SeekOrigin.End);                              sectorNumber = sectorFree.Count;                              for (int i = 0; i < sectorsNeeded; ++i) {                                  file.Write(emptySector' 0' emptySector.Length);                                  sectorFree.Add(false);                              }                              sizeDelta += SectorBytes * sectorsNeeded;                                Write(sectorNumber' data' length);                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                          }                      }                  }                  SetTimestamp(x' z' timestamp);              }              catch (IOException e) {                  Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: try {                  int offset = GetOffset(x' z);                  int sectorNumber = offset >> 8;                  int sectorsAllocated = offset & 0xFF;                  int sectorsNeeded = (length + CHUNK_HEADER_SIZE) / SectorBytes + 1;                    // maximum chunk size is 1MB                  if (sectorsNeeded >= 256) {                      return;                  }                    if (sectorNumber != 0 && sectorsAllocated == sectorsNeeded) {                      /* we can simply overwrite the old sectors */                      Debug("SAVE"' x' z' length' "rewrite");                      Write(sectorNumber' data' length);                  }                  else {                      /* we need to allocate new sectors */                        lock (this.fileLock) {                          /* mark the sectors previously used for this chunk as free */                          for (int i = 0; i < sectorsAllocated; ++i) {                              sectorFree[sectorNumber + i] = true;                          }                            /* scan for a free space large enough to store this chunk */                          int runStart = sectorFree.FindIndex(b => b == true);                          int runLength = 0;                          if (runStart != -1) {                              for (int i = runStart; i < sectorFree.Count; ++i) {                                  if (runLength != 0) {                                      if (sectorFree[i]) runLength++;                                      else runLength = 0;                                  }                                  else if (sectorFree[i]) {                                      runStart = i;                                      runLength = 1;                                  }                                  if (runLength >= sectorsNeeded) {                                      break;                                  }                              }                          }                            if (runLength >= sectorsNeeded) {                              /* we found a free space large enough */                              Debug("SAVE"' x' z' length' "reuse");                              sectorNumber = runStart;                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                              for (int i = 0; i < sectorsNeeded; ++i) {                                  sectorFree[sectorNumber + i] = false;                              }                              Write(sectorNumber' data' length);                          }                          else {                              /*                               * no free space large enough found -- we need to grow the                               * file                               */                              Debug("SAVE"' x' z' length' "grow");                              file.Seek(0' SeekOrigin.End);                              sectorNumber = sectorFree.Count;                              for (int i = 0; i < sectorsNeeded; ++i) {                                  file.Write(emptySector' 0' emptySector.Length);                                  sectorFree.Add(false);                              }                              sizeDelta += SectorBytes * sectorsNeeded;                                Write(sectorNumber' data' length);                              SetOffset(x' z' (sectorNumber << 8) | sectorsNeeded);                          }                      }                  }                  SetTimestamp(x' z' timestamp);              }              catch (IOException e) {                  Console.WriteLine(e.StackTrace);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Write,The following statement contains a magic number: lock (this.fileLock) {                  Debugln(" " + sectorNumber);                  file.Seek(sectorNumber * SectorBytes' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(length + 1);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                  file.Write(bytes' 0' 4); // chunk length                  file.WriteByte(VERSION_DEFLATE); // chunk version number                  file.Write(data' 0' length); // chunk data              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,DeleteChunk,The following statement contains a magic number: lock (this.fileLock) {                  int offset = GetOffset(x' z);                  int sectorNumber = offset >> 8;                  int sectorsAllocated = offset & 0xFF;                    file.Seek(sectorNumber * SectorBytes' SeekOrigin.Begin);                  for (int i = 0; i < sectorsAllocated; i++) {                      file.Write(emptySector' 0' SectorBytes);                  }                    SetOffset(x' z' 0);                  SetTimestamp(x' z' 0);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,OutOfBounds,The following statement contains a magic number: return x < 0 || x >= 32 || z < 0 || z >= 32;
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,OutOfBounds,The following statement contains a magic number: return x < 0 || x >= 32 || z < 0 || z >= 32;
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetOffset,The following statement contains a magic number: return offsets[x + z * 32];
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: lock (this.fileLock) {                  offsets[x + z * 32] = offset;                  file.Seek((x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(offset);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: lock (this.fileLock) {                  offsets[x + z * 32] = offset;                  file.Seek((x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(offset);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: lock (this.fileLock) {                  offsets[x + z * 32] = offset;                  file.Seek((x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(offset);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetOffset,The following statement contains a magic number: lock (this.fileLock) {                  offsets[x + z * 32] = offset;                  file.Seek((x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(offset);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,Timestamp,The following statement contains a magic number: DateTime epoch = new DateTime(1970' 1' 1' 0' 0' 0' 0);
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,GetTimestamp,The following statement contains a magic number: return chunkTimestamps[x + z * 32];
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: lock (this.fileLock) {                  chunkTimestamps[x + z * 32] = value;                  file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(value);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: lock (this.fileLock) {                  chunkTimestamps[x + z * 32] = value;                  file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(value);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: lock (this.fileLock) {                  chunkTimestamps[x + z * 32] = value;                  file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(value);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,SetTimestamp,The following statement contains a magic number: lock (this.fileLock) {                  chunkTimestamps[x + z * 32] = value;                  file.Seek(SectorBytes + (x + z * 32) * 4' SeekOrigin.Begin);                    byte[] bytes = BitConverter.GetBytes(value);                  if (BitConverter.IsLittleEndian) {                      ;                      Array.Reverse(bytes);                  }                    file.Write(bytes' 0' 4);              }
Magic Number,Substrate.Core,RegionFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionFile.cs,parseCoordinatesFromName,The following statement contains a magic number: z = Convert.ToInt32(match.Groups[2].Value);
Magic Number,Substrate.Core,RegionKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: int hash = 23;
Magic Number,Substrate.Core,RegionKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + rx;
Magic Number,Substrate.Core,RegionKey,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\RegionKey.cs,GetHashCode,The following statement contains a magic number: hash = hash * 37 + rz;
Magic Number,Substrate.Core,Base36,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: while (input != 0) {                  result.Push(_alphabet[(int)(input % 36)]);                  input /= 36;              }
Magic Number,Substrate.Core,Base36,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: while (input != 0) {                  result.Push(_alphabet[(int)(input % 36)]);                  input /= 36;              }
Magic Number,Substrate.Core,Base36,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Decode,The following statement contains a magic number: for (int i = input.Length - 1; i >= 0; i--) {                  result += _alphabet.IndexOf(input[i]) * (long)Math.Pow(36' pos);                  pos++;              }
Magic Number,Substrate.Core,Base16,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {                  int hi = (input[i] >> 4) & 0xF;                  int lo = input[i] & 0xF;                    result.Add(_alphabet[hi]);                  if (stride > 0 && (((i + 1) * 2 - 1) % stride) == 0) {                      result.Add(strideChar);                  }                    result.Add(_alphabet[lo]);                  if (stride > 0 && (((i + 1) * 2) % stride) == 0) {                      result.Add(strideChar);                  }              }
Magic Number,Substrate.Core,Base16,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {                  int hi = (input[i] >> 4) & 0xF;                  int lo = input[i] & 0xF;                    result.Add(_alphabet[hi]);                  if (stride > 0 && (((i + 1) * 2 - 1) % stride) == 0) {                      result.Add(strideChar);                  }                    result.Add(_alphabet[lo]);                  if (stride > 0 && (((i + 1) * 2) % stride) == 0) {                      result.Add(strideChar);                  }              }
Magic Number,Substrate.Core,Base16,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\Base.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {                  int hi = (input[i] >> 4) & 0xF;                  int lo = input[i] & 0xF;                    result.Add(_alphabet[hi]);                  if (stride > 0 && (((i + 1) * 2 - 1) % stride) == 0) {                      result.Add(strideChar);                  }                    result.Add(_alphabet[lo]);                  if (stride > 0 && (((i + 1) * 2) % stride) == 0) {                      result.Add(strideChar);                  }              }
Magic Number,Substrate.Core,NibbleArray,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,NibbleArray,The following statement contains a magic number: _data = new byte[(int)Math.Ceiling(length / 2.0)];
Magic Number,Substrate.Core,XZYNibbleArray,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,XZYNibbleArray,The following statement contains a magic number: if (xdim * ydim * zdim != data.Length * 2)              {                  throw new ArgumentException("Product of dimensions must equal half length of raw data");              }
Magic Number,Substrate.Core,YZXNibbleArray,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\NibbleArray.cs,YZXNibbleArray,The following statement contains a magic number: if (xdim * ydim * zdim != data.Length * 2) {                  throw new ArgumentException("Product of dimensions must equal half length of raw data");              }
Magic Number,Substrate.Data,MapFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapFile.cs,IdFromFilename,The following statement contains a magic number: if (filename.EndsWith(".dat")) {                  return Convert.ToInt32(filename.Substring(4).Remove(filename.Length - 4));              }
Magic Number,Substrate.Data,MapFile,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapFile.cs,IdFromFilename,The following statement contains a magic number: if (filename.EndsWith(".dat")) {                  return Convert.ToInt32(filename.Substring(4).Remove(filename.Length - 4));              }
Magic Number,Substrate.Data,Map,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _scale = 3;
Magic Number,Substrate.Data,Map,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _height = 128;
Magic Number,Substrate.Data,Map,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\Map.cs,Map,The following statement contains a magic number: _width = 128;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _colorIndex = new Color[256];
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _labIndex = new Vector3[256];
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _blockIndex = new ColorGroup[4096];
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColorIndex,The following statement contains a magic number: if (blockId < 0 || blockId >= 4096) {                  throw new ArgumentOutOfRangeException("blockId");              }
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,BlockToColor,The following statement contains a magic number: if (ci < 0 || ci >= 256) {                  throw new InvalidOperationException("The specified Block ID mapped to an invalid color index.");              }
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,GroupToColor,The following statement contains a magic number: if (ci < 0 || ci >= 256) {                  throw new InvalidOperationException("The specified group mapped to an invalid color index.");              }
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double r = color.R / 255.0;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double g = color.G / 255.0;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: double b = color.B / 255.0;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r = (r > 0.04045)                  ? Math.Pow((r + 0.055) / 1.055' 2.4)                  : r / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g = (g > 0.04045)                  ? Math.Pow((g + 0.055) / 1.055' 2.4)                  : g / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b = (b > 0.04045)                  ? Math.Pow((b + 0.055) / 1.055' 2.4)                  : b / 12.92;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: r *= 100;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: g *= 100;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: b *= 100;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.X = r * 0.4124 + g * 0.3576 + b * 0.1805;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,RgbToXyz,The following statement contains a magic number: xyz.Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double x = xyz.X / 95.047;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double y = xyz.Y / 100.0;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: double z = xyz.Z / 108.883;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: x = (x > 0.008856)                  ? Math.Pow(x' 1.0 / 3.0)                  : (7.787 * x) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: y = (y > 0.008856)                  ? Math.Pow(y' 1.0 / 3.0)                  : (7.787 * y) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: z = (z > 0.008856)                  ? Math.Pow(z' 1.0 / 3.0)                  : (7.787 * z) + (16.0 / 116.0);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.X = (116 * y) - 16;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.X = (116 * y) - 16;
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.Y = 500 * (x - y);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,XyzToLab,The following statement contains a magic number: lab.Z = 200 * (y - z);
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Data,MapConverter,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Data\MapConverter.cs,MapConverter,The following statement contains a magic number: _defaultColorIndex = new Color[] {                  Color.FromArgb(0' 0' 0' 0)'         // Unexplored                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(0' 0' 0' 0)'                  Color.FromArgb(89' 125' 39)'        // Grass                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(127' 178' 56)'                  Color.FromArgb(109' 153' 48)'                  Color.FromArgb(174' 164' 115)'      // Sand/Gravel                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(247' 233' 163)'                  Color.FromArgb(213' 201' 140)'                  Color.FromArgb(117' 117' 117)'      // Other                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(180' 0' 0)'          // Lava                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(255' 0' 0)'                  Color.FromArgb(220' 0' 0)'                  Color.FromArgb(112' 112' 180)'      // Ice                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(160' 160' 255)'                  Color.FromArgb(138' 138' 220)'                  Color.FromArgb(117' 117' 117)'      // Iron                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(167' 167' 167)'                  Color.FromArgb(144' 144' 144)'                  Color.FromArgb(0' 87' 0)'           // Leaves/Flowers                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(0' 124' 0)'                  Color.FromArgb(0' 106' 0)'                  Color.FromArgb(180' 180' 180)'      // Snow                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(255' 255' 255)'                  Color.FromArgb(220' 220' 220)'                  Color.FromArgb(115' 118' 129)'      // Clay                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(164' 168' 184)'                  Color.FromArgb(141' 144' 158)'                  Color.FromArgb(129' 74' 33)'        // Dirt                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(183' 106' 47)'                  Color.FromArgb(157' 91' 40)'                  Color.FromArgb(79' 79' 79)'         // Stone/Cobblestone/Ore                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(112' 112' 112)'                  Color.FromArgb(96' 96' 96)'                  Color.FromArgb(45' 45' 180)'        // Water                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(64' 64' 255)'                  Color.FromArgb(55' 55' 220)'                  Color.FromArgb(73' 58' 35)'         // Log/Tree/Wood                  Color.FromArgb(89' 71' 43)'                  Color.FromArgb(104' 83' 50)'                  Color.FromArgb(89' 71' 43)'              };
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShort,The following statement contains a magic number: byte[] gzBytes = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShort,The following statement contains a magic number: _stream.Read(gzBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadInt,The following statement contains a magic number: byte[] gzBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadInt,The following statement contains a magic number: _stream.Read(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLong,The following statement contains a magic number: byte[] gzBytes = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLong,The following statement contains a magic number: _stream.Read(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadFloat,The following statement contains a magic number: byte[] gzBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadFloat,The following statement contains a magic number: _stream.Read(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadDouble,The following statement contains a magic number: byte[] gzBytes = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadDouble,The following statement contains a magic number: _stream.Read(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadByteArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadByteArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadString,The following statement contains a magic number: byte[] lenBytes = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadString,The following statement contains a magic number: _stream.Read(lenBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadList,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadList,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadIntArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  _stream.Read(buffer' 0' 4);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  data[i] = BitConverter.ToInt32(buffer' 0);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: byte[] buffer = new byte[8];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadLongArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  _stream.Read(buffer' 0' 8);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  data[i] = BitConverter.ToInt64(buffer' 0);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: byte[] lenBytes = new byte[4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: _stream.Read(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: byte[] buffer = new byte[2];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadShortArray,The following statement contains a magic number: for (int i = 0; i < length; i++) {                  _stream.Read(buffer' 0' 2);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  data[i] = BitConverter.ToInt16(buffer' 0);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShort,The following statement contains a magic number: _stream.Write(gzBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteInt,The following statement contains a magic number: _stream.Write(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLong,The following statement contains a magic number: _stream.Write(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteFloat,The following statement contains a magic number: _stream.Write(gzBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteDouble,The following statement contains a magic number: _stream.Write(gzBytes' 0' 8);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteByteArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteString,The following statement contains a magic number: _stream.Write(lenBytes' 0' 2);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteList,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 4];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 4' 4);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteIntArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 4' 4);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 8];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 8' 8);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteLongArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 8' 8);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: _stream.Write(lenBytes' 0' 4);
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: byte[] data = new byte[val.Length * 2];
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 2' 2);              }
Magic Number,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteShortArray,The following statement contains a magic number: for (int i = 0; i < val.Length; i++) {                  byte[] buffer = BitConverter.GetBytes(val.Data[i]);                  if (BitConverter.IsLittleEndian) {                      Array.Reverse(buffer);                  }                  Array.Copy(buffer' 0' data' i * 2' 2);              }
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(block[x]) ^ ((_RunningCrc32Result) & 0x000000FF)];              }
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // PKZip specifies CRC32 with a polynomial of 0xEDB88320;                  // This is also the CRC-32 polynomial used bby Ethernet' FDDI'                  // bzip2' gzip' and others.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  // For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // PKZip specifies CRC32 with a polynomial of 0xEDB88320;                  // This is also the CRC-32 polynomial used bby Ethernet' FDDI'                  // bzip2' gzip' and others.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  // For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // PKZip specifies CRC32 with a polynomial of 0xEDB88320;                  // This is also the CRC-32 polynomial used bby Ethernet' FDDI'                  // bzip2' gzip' and others.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  // For more details' see http://en.wikipedia.org/wiki/Cyclic_redundancy_check                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,gf2_matrix_square,The following statement contains a magic number: for (int i = 0; i < 32; i++)                  square[i] = gf2_matrix_times(mat' mat[i]);
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,Ionic.Zlib,CRC32,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Crc32.cs,Combine,The following statement contains a magic number: for (int i = 1; i < 32; i++)              {                  odd[i] = row;                  row <<= 1;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.L_CODES; i++)                  dyn_ltree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.D_CODES; i++)                  dyn_dtree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: for (int i = 0; i < InternalConstants.BL_CODES; i++)                  bl_tree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = (int)tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)0x7fff;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = (int)tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      bl_tree[curlen * 2] = (short)(bl_tree[curlen * 2] + count);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                          bl_tree[curlen * 2]++;                      bl_tree[InternalConstants.REP_3_6 * 2]++;                  }                  else if (count <= 10)                  {                      bl_tree[InternalConstants.REPZ_3_10 * 2]++;                  }                  else                  {                      bl_tree[InternalConstants.REPZ_11_138 * 2]++;                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = InternalConstants.BL_CODES - 1; max_blindex >= 3; max_blindex--)              {                  if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)                      break;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)              {                  send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen   = tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)              {                  max_count = 138; min_count = 3;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];                  if (++count < max_count && curlen == nextlen)                  {                      continue;                  }                  else if (count < min_count)                  {                      do                      {                          send_code(curlen' bl_tree);                      }                      while (--count != 0);                  }                  else if (curlen != 0)                  {                      if (curlen != prevlen)                      {                          send_code(curlen' bl_tree); count--;                      }                      send_code(InternalConstants.REP_3_6' bl_tree);                      send_bits(count - 3' 2);                  }                  else if (count <= 10)                  {                      send_code(InternalConstants.REPZ_3_10' bl_tree);                      send_bits(count - 3' 3);                  }                  else                  {                      send_code(InternalConstants.REPZ_11_138' bl_tree);                      send_bits(count - 11' 7);                  }                  count = 0; prevlen = curlen;                  if (nextlen == 0)                  {                      max_count = 138; min_count = 3;                  }                  else if (curlen == nextlen)                  {                      max_count = 6; min_count = 3;                  }                  else                  {                      max_count = 7; min_count = 4;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_bits,The following statement contains a magic number: unchecked              {                  if (bi_valid > (int)Buf_size - len)                  {                      //int val = value;                      //      bi_buf |= (val << bi_valid);                        bi_buf |= (short)((value << bi_valid) & 0xffff);                      //put_short(bi_buf);                          pending[pendingCount++] = (byte)bi_buf;                          pending[pendingCount++] = (byte)(bi_buf >> 8);                                              bi_buf = (short)((uint)value >> (Buf_size - bi_valid));                      bi_valid += len - Buf_size;                  }                  else                  {                      //      bi_buf |= (value) << bi_valid;                      bi_buf |= (short)((value << bi_valid) & 0xffff);                      bi_valid += len;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)              {                  send_bits(STATIC_TREES << 1' 3);                  send_code(END_BLOCK' StaticTree.lengthAndLiteralsTreeCodes);                  bi_flush();              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)              {                  // lc is the unmatched char                  dyn_ltree[lc * 2]++;              }              else              {                  matches++;                  // Here' lc is the match length - MIN_MATCH                  dist--; // dist = match distance - 1                  dyn_ltree[(Tree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;                  dyn_dtree[Tree.DistanceCode(dist) * 2]++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && (int)compressionLevel > 2)              {                  // Compute an upper bound for the compressed length                  int out_length = last_lit << 3;                  int in_length = strstart - block_start;                  int dcode;                  for (dcode = 0; dcode < InternalConstants.D_CODES; dcode++)                  {                      out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));                  }                  out_length >>= 3;                  if ((matches < (last_lit / 2)) && out_length < in_length / 2)                      return true;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      int ix = _distanceOffset + lx * 2;                      distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);                      lc = (pending[_lengthOffset + lx]) & 0xff;                      lx++;                        if (distance == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // literal or match pair                           // Here' lc is the match length - MIN_MATCH                          code = Tree.LengthCode[lc];                            // send the length code                          send_code(code + InternalConstants.LITERALS + 1' ltree);                          extra = Tree.ExtraLengthBits[code];                          if (extra != 0)                          {                              // send the extra length bits                              lc -= Tree.LengthBase[code];                              send_bits(lc' extra);                          }                          distance--; // dist is now the match distance - 1                          code = Tree.DistanceCode(distance);                            // send the distance code                          send_code(code' dtree);                            extra = Tree.ExtraDistanceBits[code];                          if (extra != 0)                          {                              // send the extra distance bits                              distance -= Tree.DistanceBase[code];                              send_bits(distance' extra);                          }                      }                        // Check that the overlay between pending and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: if (last_lit != 0)              {                  do                  {                      int ix = _distanceOffset + lx * 2;                      distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);                      lc = (pending[_lengthOffset + lx]) & 0xff;                      lx++;                        if (distance == 0)                      {                          send_code(lc' ltree); // send a literal byte                      }                      else                      {                          // literal or match pair                           // Here' lc is the match length - MIN_MATCH                          code = Tree.LengthCode[lc];                            // send the length code                          send_code(code + InternalConstants.LITERALS + 1' ltree);                          extra = Tree.ExtraLengthBits[code];                          if (extra != 0)                          {                              // send the extra length bits                              lc -= Tree.LengthBase[code];                              send_bits(lc' extra);                          }                          distance--; // dist is now the match distance - 1                          code = Tree.DistanceCode(distance);                            // send the distance code                          send_code(code' dtree);                            extra = Tree.ExtraDistanceBits[code];                          if (extra != 0)                          {                              // send the extra distance bits                              distance -= Tree.DistanceBase[code];                              send_bits(distance' extra);                          }                      }                        // Check that the overlay between pending and d_buf+l_buf is ok:                  }                  while (lx < last_lit);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)              {                  ascii_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < InternalConstants.LITERALS)              {                  bin_freq += dyn_ltree[n * 2]; n++;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                   bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                   bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                   bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                   bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);                   bi_buf = 0;                  bi_valid = 0;              }              else if (bi_valid >= 8)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;                  bi_buf >>= 8;                  bi_valid -= 8;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);              }              else if (bi_valid > 0)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)              {                  pending[pendingCount++] = (byte)bi_buf;                  pending[pendingCount++] = (byte)(bi_buf >> 8);              }              else if (bi_valid > 0)              {                  //put_byte((byte)bi_buf);                  pending[pendingCount++] = (byte)bi_buf;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)                  unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                       //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,copy_block,The following statement contains a magic number: if (header)                  unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                       //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5)              {                  max_block_size = pending.Length - 5;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateNone,The following statement contains a magic number: if (max_block_size > pending.Length - 5)              {                  max_block_size = pending.Length - 5;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (compressionLevel > 0)              {                  // Check if the file is ascii or binary                  if (data_type == Z_UNKNOWN)                      set_data_type();                    // Construct the literal and distance trees                  treeLiterals.build_tree(this);                    treeDistances.build_tree(this);                    // At this point' opt_len and static_len are the total bit lengths of                  // the compressed block data' excluding the tree representations.                    // Build the bit length tree for the above two trees' and get the index                  // in bl_order of the last bit length code to send.                  max_blindex = build_bl_tree();                    // Determine the best encoding. Compute first the block length in bytes                  opt_lenb = (opt_len + 3 + 7) >> 3;                  static_lenb = (static_len + 3 + 7) >> 3;                    if (static_lenb <= opt_lenb)                      opt_lenb = static_lenb;              }              else              {                  opt_lenb = static_lenb = stored_len + 5; // force a stored block              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1)              {                  // 4: two words for the lengths                  // The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                  // Otherwise we can't have processed more than WSIZE input bytes since                  // the last block flush' because compression would have been                  // successful. If LIT_BUFSIZE <= WSIZE' it is never too late to                  // transform a block into a stored block.                  _tr_stored_block(buf' stored_len' eof);              }              else if (static_lenb == opt_lenb)              {                  send_bits((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);                  send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes' StaticTree.distTreeCodes);              }              else              {                  send_bits((DYN_TREES << 1) + (eof ? 1 : 0)' 3);                  send_all_trees(treeLiterals.max_code + 1' treeDistances.max_code + 1' max_blindex + 1);                  send_compressed_block(dyn_ltree' dyn_dtree);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,DeflateSlow,The following statement contains a magic number: while (true)              {                  // Make sure that we always have enough lookahead' except                  // at the end of the input file. We need MAX_MATCH bytes                  // for the next match' plus MIN_MATCH bytes to insert the                  // string following the next match.                    if (lookahead < MIN_LOOKAHEAD)                  {                      _fillWindow();                      if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)                          return BlockState.NeedMore;                        if (lookahead == 0)                          break; // flush the current block                  }                    // Insert the string window[strstart .. strstart+2] in the                  // dictionary' and set hash_head to the head of the hash chain:                    if (lookahead >= MIN_MATCH)                  {                      ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                      //  prev[strstart&w_mask]=hash_head=head[ins_h];                      hash_head = (head[ins_h] & 0xffff);                      prev[strstart & w_mask] = head[ins_h];                      head[ins_h] = unchecked((short)strstart);                  }                    // Find the longest match' discarding those <= prev_length.                  prev_length = match_length;                  prev_match = match_start;                  match_length = MIN_MATCH - 1;                    if (hash_head != 0 && prev_length < config.MaxLazy &&                      ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)                  {                      // To simplify the code' we prevent matches with the string                      // of window index 0 (in particular we have to avoid a match                      // of the string with itself at the start of the input file).                        if (compressionStrategy != CompressionStrategy.HuffmanOnly)                      {                          match_length = longest_match(hash_head);                      }                      // longest_match() sets match_start                        if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096)))                      {                            // If prev_match is also MIN_MATCH' match_start is garbage                          // but we will ignore the current match anyway.                          match_length = MIN_MATCH - 1;                      }                  }                    // If there was a match at the previous step and the current                  // match is not better' output the previous match:                  if (prev_length >= MIN_MATCH && match_length <= prev_length)                  {                      int max_insert = strstart + lookahead - MIN_MATCH;                      // Do not insert strings in hash table beyond this.                        //          check_match(strstart-1' prev_match' prev_length);                        bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);                        // Insert in hash table all strings up to the end of the match.                      // strstart-1 and strstart are already inserted. If there is not                      // enough lookahead' the last two strings are not inserted in                      // the hash table.                      lookahead -= (prev_length - 1);                      prev_length -= 2;                      do                      {                          if (++strstart <= max_insert)                          {                              ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;                              //prev[strstart&w_mask]=hash_head=head[ins_h];                              hash_head = (head[ins_h] & 0xffff);                              prev[strstart & w_mask] = head[ins_h];                              head[ins_h] = unchecked((short)strstart);                          }                      }                      while (--prev_length != 0);                      match_available = 0;                      match_length = MIN_MATCH - 1;                      strstart++;                        if (bflush)                      {                          flush_block_only(false);                          if (_codec.AvailableBytesOut == 0)                              return BlockState.NeedMore;                      }                  }                  else if (match_available != 0)                  {                        // If there was no match at the previous position' output a                      // single literal. If there was a match but the current match                      // is longer' truncate the previous match to a single literal.                        bflush = _tr_tally(0' window[strstart - 1] & 0xff);                        if (bflush)                      {                          flush_block_only(false);                      }                      strstart++;                      lookahead--;                      if (_codec.AvailableBytesOut == 0)                          return BlockState.NeedMore;                  }                  else                  {                      // There is no previous match to compare with' wait for                      // the next step to decide.                        match_available = 1;                      strstart++;                      lookahead--;                  }              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= config.GoodLength)              {                  chain_length >>= 2;              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,longest_match,The following statement contains a magic number: do              {                  match = cur_match;                    // Skip to next match if the match length cannot increase                  // or if the match length is less than 2:                  if (window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1])                      continue;                    // The check at best_len-1 can be removed because it will be made                  // again later. (This heuristic is not always a win.)                  // It is not necessary to compare scan[2] and match[2] since they                  // are always equal when the other bytes match' given that                  // the hash keys are equal and that HASH_BITS >= 8.                  scan += 2; match++;                    // We check for insufficient lookahead only every 8th comparison;                  // the 256th check will be made at strstart+258.                  do                  {                  }                  while (window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] &&                         window[++scan] == window[++match] && scan < strend);                    len = MAX_MATCH - (int)(strend - scan);                  scan = strend - MAX_MATCH;                    if (len > best_len)                  {                      match_start = cur_match;                      best_len = len;                      if (len >= niceLength)                          break;                      scan_end1 = window[scan + best_len - 1];                      scan_end = window[scan + best_len];                  }              }              while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)                  throw new ZlibException("windowBits must be in the range 9..15.");
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: if (windowBits < 9 || windowBits > 15)                  throw new ZlibException("windowBits must be in the range 9..15.");
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: if (status == INIT_STATE)              {                  int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;                  int level_flags = (((int)compressionLevel - 1) & 0xff) >> 1;                    if (level_flags > 3)                      level_flags = 3;                  header |= (level_flags << 6);                  if (strstart != 0)                      header |= PRESET_DICT;                  header += 31 - (header % 31);                    status = BUSY_STATE;                  //putShortMSB(header);                  unchecked                  {                      pending[pendingCount++] = (byte)(header >> 8);                      pending[pendingCount++] = (byte)header;                  }                  // Save the adler32 of the preset dictionary:                  if (strstart != 0)                  {                      ////putShortMSB((int)(SharedUtils.URShift(_codec._Adler32' 16)));                      //putShortMSB((int)((UInt64)_codec._Adler32 >> 16));                      //putShortMSB((int)(_codec._Adler32 & 0xffff));              pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);              pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);              pending[pendingCount++] = (byte)(_codec._Adler32 & 0x000000FF);                  }                  _codec._Adler32 = Adler.Adler32(0' null' 0' 0);              }
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,GZipStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: int bufferLength = 10 + cbLength + fnLength;
Magic Number,Ionic.Zlib,GZipStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: header[i++] = 8;
Magic Number,Ionic.Zlib,GZipStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timet)' 0' header' i' 4);
Magic Number,Ionic.Zlib,GZipStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Flush,The following statement contains a magic number: for (int pass=0; pass < 2; pass++)              {                  if (pass==0)                  {                      // compute number of bytes to copy as far as end of window                      nBytes = (int)((readAt <= writeAt ? writeAt : end) - readAt);                  }                  else                  {                      // compute bytes to copy                      nBytes = writeAt - readAt;                  }                    // workitem 8870                  if (nBytes == 0)                  {                      if (r == ZlibConstants.Z_BUF_ERROR)                          r = ZlibConstants.Z_OK;                      return r;                  }                    if (nBytes > _codec.AvailableBytesOut)                      nBytes = _codec.AvailableBytesOut;                    if (nBytes != 0 && r == ZlibConstants.Z_BUF_ERROR)                      r = ZlibConstants.Z_OK;                    // update counters                  _codec.AvailableBytesOut -= nBytes;                  _codec.TotalBytesOut += nBytes;                    // update check information                  if (checkfn != null)                      _codec._Adler32 = check = Adler.Adler32(check' window' readAt' nBytes);                    // copy as far as end of window                  Array.Copy(window' readAt' _codec.OutputBuffer' _codec.NextOut' nBytes);                  _codec.NextOut += nBytes;                  readAt += nBytes;                    // see if more to copy at beginning of window                  if (readAt == end && pass == 0)                  {                      // wrap pointers                      readAt = 0;                      if (writeAt == end)                          writeAt = 0;                  }                  else pass++;              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }              }
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < 15)                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < e)                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);                                    b >>= e; k -= e;                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & InternalInflateConstants.InflateMask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.writeAt = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & InternalInflateConstants.InflateMask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                              b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                              s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                          c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.writeAt = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End();                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End();                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (_codec.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (_codec.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (_codec.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (_codec.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,Ionic.Zlib,InflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Sync,The following statement contains a magic number: if (m != 4)              {                  return ZlibConstants.Z_DATA_ERROR;              }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)                          {                                  a = c[k];                                  while (a-- != 0)                                  {                                          // here i is the Huffman code of length k bits for value *p                                          // make tables up to required level                                          while (k > w + l)                                          {                                                  h++;                                                  w += l; // previous table always l bits                                                  // compute minimum size table less than or equal to l bits                                                  z = g - w;                                                  z = (z > l)?l:z; // table size upper limit                                                  if ((f = 1 << (j = k - w)) > a + 1)                                                  {                                                          // try a k-w bit table                                                          // too few codes for k-w bit table                                                          f -= (a + 1); // deduct codes from patterns left                                                          xp = k;                                                          if (j < z)                                                          {                                                                  while (++j < z)                                                                  {                                                                          // try smaller tables up to z bits                                                                          if ((f <<= 1) <= c[++xp])                                                                                  break; // enough codes to use up j bits                                                                          f -= c[xp]; // else deduct codes from patterns                                                                  }                                                          }                                                  }                                                  z = 1 << j; // table entries for j-bit table                                                                                                    // allocate new table                                                  if (hn[0] + z > MANY)                                                  {                                                          // (note: doesn't matter for fixed)                                                          return Z_DATA_ERROR; // overflow of MANY                                                  }                                                  u[h] = q = hn[0]; // DEBUG                                                  hn[0] += z;                                                                                                    // connect to last table' if there is one                                                  if (h != 0)                                                  {                                                          x[h] = i; // save pattern for backing up                                                          r[0] = (sbyte) j; // bits in this table                                                          r[1] = (sbyte) l; // bits to dump before this table                                                          j = SharedUtils.URShift(i' (w - l));                                                          r[2] = (int) (q - u[h - 1] - j); // offset to this table                                                          Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table                                                  }                                                  else                                                  {                                                          t[0] = q; // first table is returned result                                                  }                                          }                                                                                    // set up table entry in r                                          r[1] = (sbyte) (k - w);                                          if (p >= n)                                          {                                                  r[0] = 128 + 64; // out of values--invalid code                                          }                                          else if (v[p] < s)                                          {                                                  r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block                                                  r[2] = v[p++]; // simple code is just the value                                          }                                          else                                          {                                                  r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists                                                  r[2] = d[v[p++] - s];                                          }                                                                                    // fill code-like entries with r                                          f = 1 << (k - w);                                          for (j = SharedUtils.URShift(i' w); j < z; j += f)                                          {                                                  Array.Copy(r' 0' hp' (q + j) * 3' 3);                                          }                                                                                    // backwards increment the k-bit code i                                          for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))                                          {                                                  i ^= j;                                          }                                          i ^= j;                                                                                    // backup over finished tables                                          mask = (1 << w) - 1; // needed on HP' cc -O bug                                          while ((i & mask) != x[h])                                          {                                                  h--; // don't need to update q                                                  w -= l;                                                  mask = (1 << w) - 1;                                          }                                  }                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (result != Z_OK || (bd[0] == 0 && nl > 257))                          {                                  if (result == Z_DATA_ERROR)                                  {                                          z.Message = "oversubscribed distance tree";                                  }                                  else if (result == Z_BUF_ERROR)                                  {                                          z.Message = "incomplete distance tree";                                          result = Z_DATA_ERROR;                                  }                                  else if (result != Z_MEM_ERROR)                                  {                                          z.Message = "empty distance tree with lengths";                                          result = Z_DATA_ERROR;                                  }                                  return result;                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null)                          {                                  hn = new int[1];                                  v = new int[vsize];                                  c = new int[BMAX + 1];                                  r = new int[3];                                  u = new int[BMAX];                                  x = new int[BMAX + 1];                          }                          else                          {                              if (v.Length < vsize)                              {                                  v = new int[vsize];                              }                              Array.Clear(v'0'vsize);                              Array.Clear(c'0'BMAX+1);                              r[0]=0; r[1]=0; r[2]=0;                              //  for(int i=0; i<BMAX; i++){u[i]=0;}                              //Array.Copy(c' 0' u' 0' BMAX);                              Array.Clear(u'0'BMAX);                              //  for(int i=0; i<BMAX+1; i++){x[i]=0;}                              //Array.Copy(c' 0' x' 0' BMAX + 1);                              Array.Clear(x'0'BMAX+1);                          }
Magic Number,Ionic.Zlib,InfTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null)                          {                                  hn = new int[1];                                  v = new int[vsize];                                  c = new int[BMAX + 1];                                  r = new int[3];                                  u = new int[BMAX];                                  x = new int[BMAX + 1];                          }                          else                          {                              if (v.Length < vsize)                              {                                  v = new int[vsize];                              }                              Array.Clear(v'0'vsize);                              Array.Clear(c'0'BMAX+1);                              r[0]=0; r[1]=0; r[2]=0;                              //  for(int i=0; i<BMAX; i++){u[i]=0;}                              //Array.Copy(c' 0' u' 0' BMAX);                              Array.Clear(u'0'BMAX);                              //  for(int i=0; i<BMAX+1; i++){x[i]=0;}                              //Array.Copy(c' 0' x' 0' BMAX + 1);                              Array.Clear(x'0'BMAX+1);                          }
Magic Number,Ionic.Zlib,WorkItem,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,ParallelDeflateOutputStream,The following statement contains a magic number: BuffersPerCore = 4;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,_PerpetualWriterMethod,The following statement contains a magic number: try              {                  do                  {                      // wait for the next session                      TraceOutput(TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(begin) PWM");                      _sessionReset.WaitOne();                      TraceOutput(TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.WaitOne(done)  PWM");                        if (_isDisposed) break;                        TraceOutput(TraceBits.Synch | TraceBits.WriterThread' "Synch    _sessionReset.Reset()        PWM");                      _sessionReset.Reset();                        // repeatedly write buffers as they become ready                      WorkItem workitem = null;                      Ionic.Zlib.CRC32 c= new Ionic.Zlib.CRC32();                      do                      {                          workitem = _pool[_nextToWrite % _pc];                          lock(workitem)                          {                              if (_noMoreInputForThisSegment)                                  TraceOutput(TraceBits.Write'                                                 "Write    drain    wi({0}) stat({1}) canuse({2})  cba({3})"'                                                 workitem.index'                                                 workitem.status'                                                 (workitem.status == (int)WorkItem.Status.Compressed)'                                                 workitem.compressedBytesAvailable);                                do                              {                                  if (workitem.status == (int)WorkItem.Status.Compressed)                                  {                                      TraceOutput(TraceBits.WriteBegin'                                                     "Write    begin    wi({0}) stat({1})              cba({2})"'                                                     workitem.index'                                                     workitem.status'                                                     workitem.compressedBytesAvailable);                                        workitem.status = (int)WorkItem.Status.Writing;                                      _outStream.Write(workitem.compressed' 0' workitem.compressedBytesAvailable);                                      c.Combine(workitem.crc' workitem.inputBytesAvailable);                                      _totalBytesProcessed += workitem.inputBytesAvailable;                                      _nextToWrite++;                                      workitem.inputBytesAvailable= 0;                                      workitem.status = (int)WorkItem.Status.Done;                                        TraceOutput(TraceBits.WriteDone'                                                     "Write    done     wi({0}) stat({1})              cba({2})"'                                                     workitem.index'                                                     workitem.status'                                                     workitem.compressedBytesAvailable);                                          Monitor.Pulse(workitem);                                      break;                                  }                                  else                                  {                                      int wcycles = 0;                                      // I've locked a workitem I cannot use.                                      // Therefore' wake someone else up' and then release the lock.                                      while (workitem.status != (int)WorkItem.Status.Compressed)                                      {                                          TraceOutput(TraceBits.WriteWait'                                                         "Write    waiting  wi({0}) stat({1}) nw({2}) nf({3}) nomore({4})"'                                                         workitem.index'                                                         workitem.status'                                                         _nextToWrite' _nextToFill'                                                         _noMoreInputForThisSegment );                                            if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)                                              break;                                            wcycles++;                                            // wake up someone else                                          Monitor.Pulse(workitem);                                          // release and wait                                          Monitor.Wait(workitem);                                            if (workitem.status == (int)WorkItem.Status.Compressed)                                              TraceOutput(TraceBits.WriteWait'                                                             "Write    A-OK     wi({0}) stat({1}) iba({2}) cba({3}) cyc({4})"'                                                             workitem.index'                                                             workitem.status'                                                             workitem.inputBytesAvailable'                                                             workitem.compressedBytesAvailable'                                                             wcycles);                                      }                                        if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)                                          break;                                    }                              }                              while (true);                          }                            if (_noMoreInputForThisSegment)                              TraceOutput(TraceBits.Write'                                             "Write    nomore  nw({0}) nf({1}) break({2})"'                                             _nextToWrite' _nextToFill' (_nextToWrite == _nextToFill));                            if (_noMoreInputForThisSegment && _nextToWrite == _nextToFill)                              break;                        } while (true);                          // Finish:                      // After writing a series of buffers' closing each one with                      // Flush.Sync' we now write the final one as Flush.Finish' and                      // then stop.                      byte[] buffer = new byte[128];                      ZlibCodec compressor = new ZlibCodec();                      int rc = compressor.InitializeDeflate(_compressLevel' false);                      compressor.InputBuffer = null;                      compressor.NextIn = 0;                      compressor.AvailableBytesIn = 0;                      compressor.OutputBuffer = buffer;                      compressor.NextOut = 0;                      compressor.AvailableBytesOut = buffer.Length;                      rc = compressor.Deflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                          throw new Exception("deflating: " + compressor.Message);                        if (buffer.Length - compressor.AvailableBytesOut > 0)                      {                          TraceOutput(TraceBits.WriteBegin'                                         "Write    begin    flush bytes({0})"'                                         buffer.Length - compressor.AvailableBytesOut);                            _outStream.Write(buffer' 0' buffer.Length - compressor.AvailableBytesOut);                            TraceOutput(TraceBits.WriteBegin'                                         "Write    done     flush");                      }                        compressor.EndDeflate();                        _Crc32 = c.Crc32Result;                        // signal that writing is complete:                      TraceOutput(TraceBits.Synch' "Synch    _writingDone.Set()           PWM");                      _writingDone.Set();                  }                  while (true);              }              catch (System.Exception exc1)              {                  lock(_eLock)                  {                      // expose the exception to the main thread                      if (_pendingException!=null)                          _pendingException = exc1;                  }              }
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & _DesiredTrace) != 0)              {                  lock(_outputLock)                  {                      int tid = Thread.CurrentThread.GetHashCode();                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);                      Console.Write("{0:000} PDOS "' tid);                      Console.WriteLine(format' varParams);                      Console.ResetColor();                  }              }
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & _DesiredTrace) != 0)              {                  lock(_outputLock)                  {                      int tid = Thread.CurrentThread.GetHashCode();                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);                      Console.Write("{0:000} PDOS "' tid);                      Console.WriteLine(format' varParams);                      Console.ResetColor();                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)              {                  n = s.heap[h];                  bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;                  if (bits > max_length)                  {                      bits = max_length; overflow++;                  }                  tree[n * 2 + 1] = (short) bits;                  // We overwrite tree[n*2+1] which is no longer needed                                                    if (n > max_code)                      continue; // not a leaf node                                                    s.bl_count[bits]++;                  xbits = 0;                  if (n >= base_Renamed)                      xbits = extra[n - base_Renamed];                  f = tree[n * 2];                  s.opt_len += f * (bits + xbits);                  if (stree != null)                      s.static_len += f * (stree[n * 2 + 1] + xbits);              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do               {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do               {                  bits = max_length - 1;                  while (s.bl_count[bits] == 0)                      bits--;                  s.bl_count[bits]--; // move one leaf down the tree                  s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother                  s.bl_count[max_length]--;                  // The brother of the overflow item also moves one step up'                  // but this does not affect bl_count[max_length]                  overflow -= 2;              }              while (overflow > 0);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)              {                  n = s.bl_count[bits];                  while (n != 0)                  {                      m = s.heap[--h];                      if (m > max_code)                          continue;                      if (tree[m * 2 + 1] != bits)                      {                          s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);                          tree[m * 2 + 1] = (short) bits;                      }                      n--;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)              {                  if (tree[n * 2] != 0)                  {                      s.heap[++s.heap_len] = max_code = n;                      s.depth[n] = 0;                  }                  else                  {                      tree[n * 2 + 1] = 0;                  }              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)              {                  node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);                  tree[node * 2] = 1;                  s.depth[node] = 0;                  s.opt_len--;                  if (stree != null)                      s.static_len -= stree[node * 2 + 1];                  // node is 0 or 1 so it does not have extra bits              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)                  s.pqdownheap(tree' n);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,build_tree,The following statement contains a magic number: do               {                  // n = node of least frequency                  n = s.heap[1];                  s.heap[1] = s.heap[s.heap_len--];                  s.pqdownheap(tree' 1);                  m = s.heap[1]; // m = node of next least frequency                                                    s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency                  s.heap[--s.heap_max] = m;                                                    // Create a new node father of n and m                  tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));                  s.depth[node] = (sbyte) (System.Math.Max((byte) s.depth[n]' (byte) s.depth[m]) + 1);                  tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;                                                    // and insert the new node in the heap                  s.heap[1] = node++;                  s.pqdownheap(tree' 1);              }              while (s.heap_len >= 2);
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));              }
Magic Number,Ionic.Zlib,Tree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)              {                  int len = tree[n * 2 + 1];                  if (len == 0)                      continue;                  // Now reverse the bits                  tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));              }
Magic Number,Ionic.Zlib,Adler,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: uint s2 = (uint) ((adler >> 16) & 0xffff);
Magic Number,Ionic.Zlib,Adler,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  int k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      //s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += buf[index++];                           s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,Ionic.Zlib,Adler,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  int k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      //s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      s1 += buf[index++]; s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += buf[index++];                           s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,Ionic.Zlib,Adler,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,Write,The following statement contains a magic number: do              {                  _z.OutputBuffer = workingBuffer;                  _z.NextOut = 0;                  _z.AvailableBytesOut = _workingBuffer.Length;                  int rc = (_wantCompress)                      ? _z.Deflate(_flushMode)                      : _z.Inflate(_flushMode);                  if (rc != ZlibConstants.Z_OK && rc != ZlibConstants.Z_STREAM_END)                      throw new ZlibException((_wantCompress ? "de" : "in") + "flating: " + _z.Message);                    //if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                  _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                    done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                    // If GZIP and de-compress' we're done when 8 bytes remain.                  if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                      done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                }              while (!done);
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,finish,The following statement contains a magic number: if (_streamMode == StreamMode.Writer)              {                  bool done = false;                  do                  {                      _z.OutputBuffer = workingBuffer;                      _z.NextOut = 0;                      _z.AvailableBytesOut = _workingBuffer.Length;                      int rc = (_wantCompress)                          ? _z.Deflate(FlushType.Finish)                          : _z.Inflate(FlushType.Finish);                        if (rc != ZlibConstants.Z_STREAM_END && rc != ZlibConstants.Z_OK)                      {                          string verb = (_wantCompress ? "de" : "in") + "flating";                          if (_z.Message == null)                              throw new ZlibException(String.Format("{0}: (rc = {1})"' verb' rc));                          else                              throw new ZlibException(verb + ": " + _z.Message);                      }                        if (_workingBuffer.Length - _z.AvailableBytesOut > 0)                      {                          _stream.Write(_workingBuffer' 0' _workingBuffer.Length - _z.AvailableBytesOut);                      }                        done = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;                      // If GZIP and de-compress' we're done when 8 bytes remain.                      if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)                          done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);                    }                  while (!done);                    Flush();                    // workitem 7159                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (_wantCompress)                      {                          // Emit the GZIP trailer: CRC32 and  size mod 2^32                          int c1 = crc.Crc32Result;                          _stream.Write(BitConverter.GetBytes(c1)' 0' 4);                          int c2 = (Int32)(crc.TotalBytesRead & 0x00000000FFFFFFFF);                          _stream.Write(BitConverter.GetBytes(c2)' 0' 4);                      }                      else                      {                          throw new ZlibException("Writing with decompression is not supported.");                      }                  }              }              // workitem 7159              else if (_streamMode == StreamMode.Reader)              {                  if (_flavor == ZlibStreamFlavor.GZIP)                  {                      if (!_wantCompress)                      {                          // workitem 8501: handle edge case (decompress empty stream)                          if (_z.TotalBytesOut == 0L)                              return;                            // Read and potentially verify the GZIP trailer: CRC32 and  size mod 2^32                          byte[] trailer = new byte[8];                            // workitem 8679                          if (_z.AvailableBytesIn != 8)                          {                              // Make sure we have read to the end of the stream                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' _z.AvailableBytesIn);                              int bytesNeeded = 8 - _z.AvailableBytesIn;                              int bytesRead = _stream.Read(trailer'                                                           _z.AvailableBytesIn'                                                           bytesNeeded);                              if (bytesNeeded != bytesRead)                              {                                  throw new ZlibException(String.Format("Protocol error. AvailableBytesIn={0}' expected 8"'                                                                        _z.AvailableBytesIn + bytesRead));                              }                          }                          else                          {                              Array.Copy(_z.InputBuffer' _z.NextIn' trailer' 0' trailer.Length);                          }                              Int32 crc32_expected = BitConverter.ToInt32(trailer' 0);                          Int32 crc32_actual = crc.Crc32Result;                          Int32 isize_expected = BitConverter.ToInt32(trailer' 4);                          Int32 isize_actual = (Int32)(_z.TotalBytesOut & 0x00000000FFFFFFFF);                            if (crc32_actual != crc32_expected)                              throw new ZlibException(String.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected));                            if (isize_actual != isize_expected)                              throw new ZlibException(String.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' isize_actual' isize_expected));                        }                      else                      {                          throw new ZlibException("Reading with compression is not supported.");                      }                  }              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] header = new byte[10];
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (n != 10)                  throw new ZlibException("Not a valid GZIP stream.");
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header[0] != 0x1F || header[1] != 0x8B || header[2] != 8)                  throw new ZlibException("Bad GZIP header.");
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if (header[0] != 0x1F || header[1] != 0x8B || header[2] != 8)                  throw new ZlibException("Bad GZIP header.");
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int32 timet = BitConverter.ToInt32(header' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x04) == 0x04)              {                  // read and discard extra field                  n = _stream.Read(header' 0' 2); // 2-byte length field                  totalBytesRead += n;                    Int16 extraLength = (Int16)(header[0] + header[1] * 256);                  byte[] extra = new byte[extraLength];                  n = _stream.Read(extra' 0' extra.Length);                  if (n != extraLength)                      throw new ZlibException("Unexpected end-of-file reading GZIP header.");                  totalBytesRead += n;              }
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x08) == 0x08)                  _GzipFileName = ReadZeroTerminatedString();
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x10) == 0x010)                  _GzipComment = ReadZeroTerminatedString();
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: if ((header[3] & 0x02) == 0x02)                  Read(_buf1' 0' 1);
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,UncompressString,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,Ionic.Zlib,ZlibBaseStream,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\ZlibBaseStream.cs,UncompressBuffer,The following statement contains a magic number: byte[] working = new byte[1024];
Duplicate Code,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (245' 264)' (186' 205)' (246' 265))
Duplicate Code,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 205)' (313' 332)' (348' 367)' (246' 265))
Missing Default,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockLight,The following switch statement is missing a default case: switch (edge) {                  case BlockCollectionEdge.EAST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' x' y' 0' x' y' zdim - 1);                          }                      }                      break;                    case BlockCollectionEdge.NORTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' 0' y' z' xdim - 1' y' z);                          }                      }                      break;                    case BlockCollectionEdge.WEST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' x' y' zdim - 1' x' y' 0);                          }                      }                      break;                    case BlockCollectionEdge.SOUTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestBlockLight(chunk' xdim - 1' y' z' 0' y' z);                          }                      }                      break;              }
Missing Default,Substrate.Core,BlockLight,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Core\BlockLight.cs,StitchBlockSkyLight,The following switch statement is missing a default case: switch (edge) {                  case BlockCollectionEdge.EAST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' x' y' 0' x' y' zdim - 1);                          }                      }                      break;                    case BlockCollectionEdge.NORTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' 0' y' z' xdim - 1' y' z);                          }                      }                      break;                    case BlockCollectionEdge.WEST:                      for (int x = 0; x < xdim; x++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' x' y' zdim - 1' x' y' 0);                          }                      }                      break;                    case BlockCollectionEdge.SOUTH:                      for (int z = 0; z < zdim; z++) {                          for (int y = 0; y < ydim; y++) {                              TestSkyLight(chunk' xdim - 1' y' z' 0' y' z);                          }                      }                      break;              }
Missing Default,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,ReadValue,The following switch statement is missing a default case: switch (type) {                  case TagType.TAG_END:                      return null;                    case TagType.TAG_BYTE:                      return ReadByte();                    case TagType.TAG_SHORT:                      return ReadShort();                    case TagType.TAG_INT:                      return ReadInt();                    case TagType.TAG_LONG:                      return ReadLong();                    case TagType.TAG_FLOAT:                      return ReadFloat();                    case TagType.TAG_DOUBLE:                      return ReadDouble();                    case TagType.TAG_BYTE_ARRAY:                      return ReadByteArray();                    case TagType.TAG_STRING:                      return ReadString();                    case TagType.TAG_LIST:                      return ReadList();                    case TagType.TAG_COMPOUND:                      return ReadCompound();                    case TagType.TAG_INT_ARRAY:                      return ReadIntArray();                                        case TagType.TAG_LONG_ARRAY:                      return ReadLongArray();                    case TagType.TAG_SHORT_ARRAY:                      return ReadShortArray();              }
Missing Default,Substrate.Nbt,NbtTree,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtTree.cs,WriteValue,The following switch statement is missing a default case: switch (val.GetTagType()) {                  case TagType.TAG_END:                      break;                    case TagType.TAG_BYTE:                      WriteByte(val.ToTagByte());                      break;                    case TagType.TAG_SHORT:                      WriteShort(val.ToTagShort());                      break;                    case TagType.TAG_INT:                      WriteInt(val.ToTagInt());                      break;                    case TagType.TAG_LONG:                      WriteLong(val.ToTagLong());                      break;                    case TagType.TAG_FLOAT:                      WriteFloat(val.ToTagFloat());                      break;                    case TagType.TAG_DOUBLE:                      WriteDouble(val.ToTagDouble());                      break;                    case TagType.TAG_BYTE_ARRAY:                      WriteByteArray(val.ToTagByteArray());                      break;                    case TagType.TAG_STRING:                      WriteString(val.ToTagString());                      break;                    case TagType.TAG_LIST:                      WriteList(val.ToTagList());                      break;                    case TagType.TAG_COMPOUND:                      WriteCompound(val.ToTagCompound());                      break;                    case TagType.TAG_INT_ARRAY:                      WriteIntArray(val.ToTagIntArray());                      break;                    case TagType.TAG_LONG_ARRAY:                      WriteLongArray(val.ToTagLongArray());                      break;                    case TagType.TAG_SHORT_ARRAY:                      WriteShortArray(val.ToTagShortArray());                      break;              }
Missing Default,Substrate.Nbt,NbtVerifier,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnMissingTag,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,NbtVerifier,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnInvalidTagType,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,NbtVerifier,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\NbtVerifier.cs,OnInvalidTagValue,The following switch statement is missing a default case: switch (code) {                          case TagEventCode.FAIL:                              return false;                          case TagEventCode.PASS:                              return true;                      }
Missing Default,Substrate.Nbt,SchemaNodeScaler,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\SchemaNodeScaler.cs,BuildDefaultTree,The following switch statement is missing a default case: switch (_type) {                  case TagType.TAG_STRING:                      return new TagNodeString();                    case TagType.TAG_BYTE:                      return new TagNodeByte();                    case TagType.TAG_SHORT:                      return new TagNodeShort();                    case TagType.TAG_INT:                      return new TagNodeInt();                    case TagType.TAG_LONG:                      return new TagNodeLong();                    case TagType.TAG_FLOAT:                      return new TagNodeFloat();                    case TagType.TAG_DOUBLE:                      return new TagNodeDouble();              }
Missing Default,Substrate.Nbt,JSONSerializer,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Source\Nbt\JSONSerializer.cs,SerializeScaler,The following switch statement is missing a default case: switch (tag.GetTagType()) {                  case TagType.TAG_STRING:                      str.Append("\"" + Escape(tag.ToTagString().Data) + "\"");                      break;                    case TagType.TAG_BYTE:                      str.Append(tag.ToTagByte().Data);                      break;                    case TagType.TAG_SHORT:                      str.Append(tag.ToTagShort().Data);                      break;                    case TagType.TAG_INT:                      str.Append(tag.ToTagInt().Data);                      break;                    case TagType.TAG_LONG:                      str.Append(tag.ToTagLong().Data);                      break;                    case TagType.TAG_FLOAT:                      str.Append(tag.ToTagFloat().Data);                      break;                    case TagType.TAG_DOUBLE:                      str.Append(tag.ToTagDouble().Data);                      break;                    case TagType.TAG_BYTE_ARRAY:                      str.Append(Convert.ToBase64String(tag.ToTagByteArray().Data));                      /*if (tag.ToTagByteArray().Length == (16 * 16 * 128 / 2)) {                          str.Append(Base16.Encode(tag.ToTagByteArray().Data' 1));                      }                      else {                          str.Append(Base16.Encode(tag.ToTagByteArray().Data' 2));                      }*/                      break;              }
Missing Default,Ionic.Zlib,DeflateManager,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor)              {                  case DeflateFlavor.Store:                      DeflateFunction = DeflateNone;                      break;                  case DeflateFlavor.Fast:                      DeflateFunction = DeflateFast;                      break;                  case DeflateFlavor.Slow:                      DeflateFunction = DeflateSlow;                      break;              }
Missing Default,Ionic.Zlib,InflateBlocks,C:\repos\minecraft-dotnet_Substrate\SubstrateCS\Vendor\DotNetZip\Zlib\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }
